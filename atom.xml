<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DZ&#39;s Gensokyo</title>
  
  <subtitle>Best Time, Best You and Me</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://derekz.cn/"/>
  <updated>2018-06-06T03:50:26.470Z</updated>
  <id>http://derekz.cn/</id>
  
  <author>
    <name>Derek Zhou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计网基础 持续更新ing</title>
    <link href="http://derekz.cn/posts/52924cd5/"/>
    <id>http://derekz.cn/posts/52924cd5/</id>
    <published>2018-01-25T07:40:00.000Z</published>
    <updated>2018-06-06T03:50:26.470Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;年底了，无心写代码，回头看看一些基础知识，持续更新中…<br><a id="more"></a></p><h3 id="网络层级"><a href="#网络层级" class="headerlink" title="网络层级"></a>网络层级</h3><ul><li><p>实体层<br>光纤，双绞线，无线电波等传输介质<br>实体层的使命是实现物理连接</p></li><li><p>数据链路层<br>0 1表示低高电位，根据0 1分组形式构成一组独特的电信号<br>链路层的使命是确定0 1分组</p><ul><li>以太网协议：<br>一组电信号构成一个数据包，称为一帧，一帧包含标头(head)和数据包(data)<br>一帧构成：<br>6个字节（6*8个二进制位，对应12个十六进制位，对应网卡地址）目的物理地址<br>6个字节 源物理地址 （MAC地址前6位是厂商编号，后6位是厂商的网卡流水号）<br>2个字节 类型（标识帧中所含信息的上层协议）<br>46-1500个字节 数据<br>4个字节 CRC（循环冗余检测）校验码<br>广播：以广播形式向本网络内所有计算机发送数据包，计算机根据head里的目的地址对比自身，相同则接收</li></ul></li><li><p>网络层<br>链路层能实现同一子网内的计算机间通信，但对于不同子网的两台计算机，不能通过广播和MAC地址联系起来<br>于是网络层定义了网络地址，用于判断计算机所处子网<br>网络层的使命是实现不同子网的主机到主机间的通信</p><ul><li>IP协议：<br>IP数据包放到以太网数据包的data部分，同样包含head和data两部分<br>IPV4规定网络地址由32个二进制位组成（0.0.0.0 - 255.255.255.255）<br>IP地址包括网络部分和主机部分，子网掩码为11111(网络部分位)000(主机部分位)，以IP地址和子网掩码相加判断是否位于同一子网<br>IP数据包head为20-60字节，head+data最大为65535字节，超过1500字节需要分割发送（链路层以太网协议）</li><li>ARP协议：<br>通过IP地址获取MAC地址<br>同一子网的所有计算机接收到一个包含目标IP地址和一个置空的MAC地址(FF:FF:FF:FF)的数据包，比对IP地址后作出回应，报告自己的MAC地址<br>不同子网交由网关处理<br>此时我们可以通过IP地址跨域子网间屏障，通过ARP协议根据IP地址再找到目标物理地址，实现互联网上任意两台主机的通信</li></ul></li><li><p>传输层<br>端口是使用网卡的程序的编号<br>主机+端口 = socket套接字<br>传输层使命是实现端口到端口的通信</p><ul><li>UDP协议：<br>数据包由head和data组成，head为8字节，总长不超过65535，一起放于IP数据包的data部分</li><li>TCP协议：<br>有确认机制的UDP，相比前者多了确认过程，更复杂也更可靠</li></ul></li><li><p>应用层<br>应用层使命是规定应用程序的数据格式（DHCP,DNS,HTTP,FTP,SSH等）</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;年底了，无心写代码，回头看看一些基础知识，持续更新中…&lt;br&gt;
    
    </summary>
    
      <category term="code" scheme="http://derekz.cn/categories/code/"/>
    
    
      <category term="计算机网络" scheme="http://derekz.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>dz-pj 在线音乐SPA</title>
    <link href="http://derekz.cn/posts/f0693436/"/>
    <id>http://derekz.cn/posts/f0693436/</id>
    <published>2018-01-19T05:04:54.000Z</published>
    <updated>2018-06-06T03:50:26.473Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;一时兴起，写了个简单的音乐站，满足自己平时听歌的需要。欢迎朋友们试用、提<a href="https://github.com/derekeeeeely/dz-music/issues" target="_blank" rel="noopener">issue</a>、<a href="https://github.com/derekeeeeely/dz-music" target="_blank" rel="noopener">star</a>~<br><a id="more"></a></p><p><img src="http://opo02jcsr.bkt.clouddn.com/0e03890a35c76d2eb7c7ec9c951bcd1e.png" alt=""></p><h3 id="相关技术点"><a href="#相关技术点" class="headerlink" title="相关技术点"></a>相关技术点</h3><ul><li>view<ul><li>react</li><li>antd<br>平时做中后台业务习惯了，图个方便直接拿来用了，也不是很丑…</li></ul></li><li>store<ul><li>mobx<br>相比于redux更轻，代码侵入小，虽然没有中间件，但小应用也够用来管理前端状态了</li></ul></li><li>server<ul><li>axios<br>图个方便简单…后续封装个完善的请求模块</li><li><a href="https://github.com/Binaryify/NeteaseCloudMusicApi" target="_blank" rel="noopener">NeteaseCloudMusicApi</a><br>在自己的server上clone了大佬的这个项目，跑起来以后为前端提供api，获取数据源</li></ul></li><li>打包部署<ul><li><a href="https://github.com/parcel-bundler/parcel" target="_blank" rel="noopener">parcel</a><br>如官网所说，零配置，作为嫌弃webpack麻烦到死的我来说真的是够用了。<ul><li>优势<br>自带热更新<br>零配置<br>速度快</li><li>劣势<br>热更新有问题<br>没有sourceMap，调试很麻烦</li></ul></li><li>nginx<ul><li>简单配置</li></ul></li><li>steps<ul><li>本地build</li><li>上传github repo</li><li>server上<code>git pull</code></li></ul></li></ul></li></ul><h3 id="项目核心"><a href="#项目核心" class="headerlink" title="项目核心"></a>项目核心</h3><p>&emsp;&emsp;由于audio和lyric是两个分开的组件，为了维护状态，这两个组件看起来都不是很独立。<br>&emsp;&emsp;后续考虑封装成一个更合理，更封闭的组件，比如对使用者来说只要传入musicList就可用。</p><h4 id="audio组件"><a href="#audio组件" class="headerlink" title="audio组件"></a>audio组件</h4><ul><li><p>思路</p><ul><li><p>监听audio组件的事件<br>举个栗子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实时进度条</span></span><br><span class="line"><span class="keyword">this</span>.audio.addEventListener(<span class="string">'timeupdate'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> progress = <span class="number">0</span></span><br><span class="line">  <span class="comment">// 下一首的时候会先进到这里？！没获取到长度的时候会报错</span></span><br><span class="line">  <span class="keyword">if</span> (!!<span class="keyword">this</span>.audio.duration) &#123;</span><br><span class="line">    progress = (<span class="keyword">this</span>.audio.currentTime / <span class="keyword">this</span>.audio.duration) * <span class="number">100</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.props.passTime(<span class="keyword">this</span>.audio.currentTime)</span><br><span class="line">  <span class="keyword">this</span>.props.form.setFieldsValue(&#123;</span><br><span class="line">    slider: progress</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    progress</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>播放过程中监听时间变化，显示实时进度条、定位实时歌词位置。</p></li></ul></li><li><p>使用</p><ul><li>props<ul><li>passTime (func)，用于将当前时间传出，存入store，方便lyric定位歌词位置</li><li>musicList，播放列表</li><li>insertMark，插入播放列表标志位 // 后续考虑优化</li><li>changeMark (func)，用于将当前歌曲在播放列表中位置传出，存入store，方便lyric获取歌词</li></ul></li><li>功能<ul><li>支持搜索歌曲，添加到播放列表</li><li>支持播放歌曲、切换上下首、切换循环单曲和列表顺序模式</li><li>支持播放中拖动进度条、显示当前时间、调节播放音量</li></ul></li></ul></li></ul><h4 id="lyric-flow组件"><a href="#lyric-flow组件" class="headerlink" title="lyric flow组件"></a>lyric flow组件</h4><ul><li><p>思路</p><ul><li><p>parse歌词字符串<br>从网易云获取到的歌词长这样：<br><img src="http://opo02jcsr.bkt.clouddn.com/cbae09421c6c201ec6a3e1bc7c084a00.png" alt=""><br>我想要的是这样的：<br><img src="http://opo02jcsr.bkt.clouddn.com/61b427ffe5b3fe9dcf6c5b3dd7b240d4.png" alt=""></p><p>parse细节如下，其实也很简单，只要把对应歌词和时间对应上就好了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">parse</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> lines = text.split(<span class="string">'\n'</span>)</span><br><span class="line">  <span class="keyword">const</span> pattern = <span class="regexp">/\[\d&#123;2&#125;:\d&#123;2&#125;.\d*\]/g</span></span><br><span class="line">  <span class="keyword">const</span> lyrics = []</span><br><span class="line">  lines.map(<span class="function"><span class="params">line</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> timeLines = line.match(pattern)</span><br><span class="line">    <span class="keyword">const</span> lyricLine = line.replace(pattern, <span class="string">""</span>)</span><br><span class="line">    <span class="keyword">if</span>(timeLines &amp;&amp; timeLines.length) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;timeLines.length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> timeLine = timeLines[i]</span><br><span class="line">        <span class="keyword">const</span> min = timeLine.replace(<span class="regexp">/(\[|\:|\]|\.)/g</span>, <span class="string">""</span>).slice(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">const</span> sec = timeLine.replace(<span class="regexp">/(\[|\:|\]|\.)/g</span>, <span class="string">""</span>).slice(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">const</span> seconds = (+min) * <span class="number">60</span> + (+sec)</span><br><span class="line">        lyrics.push(&#123;</span><br><span class="line">          [seconds]: lyricLine || <span class="string">'......'</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  lyrics.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> keyA = +<span class="built_in">Object</span>.keys(a)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">const</span> keyB = +<span class="built_in">Object</span>.keys(b)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> keyA - keyB</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> lyrics</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>监听播放时间，根据时间对应找到落在的歌词位置，显示旁边两条歌词</p></li></ul></li><li><p>使用</p><ul><li>props<ul><li>lyric 当前歌曲的歌词</li><li>currentTime 当前播放时间</li></ul></li><li>功能<ul><li>现在是显示两条，后续考虑做成文字走马灯，高亮当前播放的一条</li></ul></li></ul></li></ul><h3 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h3><h4 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h4><ul><li>audio<ul><li>以前基本没用过，现在至少知道了一些生命周期事件以及常用属性的</li></ul></li><li>mobx<ul><li>和redux思想感觉是蛮接近的，都是单一数据源，都符合flux思想</li><li>组件都需要去订阅store，mobx用inject，redux需要connect</li><li>redux把store搞成一个大块头，mobx把多个store分开</li><li>mobx直接通过action更新store，redux则通过action去调用reducer更新store</li><li>redux数据流的概念使得可以加入中间件，更好地处理异步请求</li><li>小型应用用mobx绝对是方便快捷的</li></ul></li><li>正则<ul><li>是个好东西，虽然以前基本不写，但感觉还是要好好学，学好将受益无穷啊</li></ul></li><li>willReceiveProps<ul><li>以前用得少，最近疯狂在用，是时候回顾下react生命周期了</li></ul></li></ul><h4 id="待挖掘"><a href="#待挖掘" class="headerlink" title="待挖掘"></a>待挖掘</h4><ul><li>react-router 4</li><li>react 16</li><li>parcel</li></ul><p>这些东西都用上了，但是没有去具体了解，接下来会找个项目的机会好好研究下。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;一时兴起，写了个简单的音乐站，满足自己平时听歌的需要。欢迎朋友们试用、提&lt;a href=&quot;https://github.com/derekeeeeely/dz-music/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;issue&lt;/a&gt;、&lt;a href=&quot;https://github.com/derekeeeeely/dz-music&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;star&lt;/a&gt;~&lt;br&gt;
    
    </summary>
    
      <category term="projects" scheme="http://derekz.cn/categories/projects/"/>
    
    
      <category term="react" scheme="http://derekz.cn/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>node-v8 Isolate和GC</title>
    <link href="http://derekz.cn/posts/5f9de541/"/>
    <id>http://derekz.cn/posts/5f9de541/</id>
    <published>2018-01-06T07:51:30.000Z</published>
    <updated>2018-06-06T03:50:26.470Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;Node/V8学习笔记系列1，关于Isolate（V8实例）和GC（垃圾回收机制）。</p><a id="more"></a><h3 id="JavaScript引擎"><a href="#JavaScript引擎" class="headerlink" title="JavaScript引擎"></a>JavaScript引擎</h3><p><img src="http://opo02jcsr.bkt.clouddn.com/7b6d799a60dcdda8f8321e54d4cd65db.png" alt=""></p><p>js引擎：源代码-&gt;抽象语法树AST-&gt;字节码-&gt;JIT-&gt;本地代码<br>V8：AST-&gt;JIT-&gt;本地代码</p><h3 id="V8"><a href="#V8" class="headerlink" title="V8"></a>V8</h3><h4 id="Isolate"><a href="#Isolate" class="headerlink" title="Isolate"></a>Isolate</h4><p>&emsp;&emsp;V8引擎实例，是一个独立的虚拟机，对应一个或多个线程，但同时只允许一个线程进入。Isolate之间完全隔离，不共享任何资源。</p><p><img src="http://opo02jcsr.bkt.clouddn.com/c5e9cafc6bd2eb777027f92b22eed647.png" alt=""></p><ul><li><p>Handle<br>&emsp;&emsp;V8对所有js值和对象的内存分配都是在Heap内，Heap由V8独立维护，失去引用的对象会被GC回收。Handle是对Heap中对象的引用，GC需要管理Handle，对象的Handle引用变化时GC可以回收该对象或者移动该对象的分区。<br>&emsp;&emsp;Handle分为Local和Persistance两种。前者为局部对象，后者类似全局对象，需要类似于C++的new和delete的操作Persistent::New, Persistent::Dispose进行内存管理。<br>&emsp;&emsp;Persistent::MakeWeak可以弱化引用，触发GC对被引用对象的回收。</p></li><li><p>Scope<br>&emsp;&emsp;作用域，是Handle（句柄）的容器，一个作用域内可以有很多句柄。<br>&emsp;&emsp;HandleScope用于管理Handle，Context::Scope用于管理Context对象</p></li><li><p>Context<br>&emsp;&emsp;上下文环境，也可以理解为运行环境。<br>&emsp;&emsp;例如：在A函数内有一个Context，调用B函数，又有一个Context，退出B回到A时又恢复了A的Context。</p></li></ul><h4 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h4><p>&emsp;&emsp;基本问题：识别需要回收的内存。<br>&emsp;&emsp;根对象或者被另一个活跃对象引用的对象是活跃的。</p><ul><li><p>V8的堆构成<br><img src="http://opo02jcsr.bkt.clouddn.com/dce361c2c729b461e24b5582c56c3d8f.png" alt=""></p></li><li><p>识别指针<br>&emsp;&emsp;通过在指针的末位标记这个字是指针还是对象</p></li><li><p>对象晋升<br>&emsp;&emsp;对象在经历了多次新生代的清理后还幸存的时候，会被移动到老生代，即被晋升</p></li><li><p>跨区指向<br>&emsp;&emsp;新对象诞生时并没有指向他的指针，比如在老生区对象写操作的时候，产生了一个队新对象的引用，此时在写缓冲区被记录下这样的跨区指向。</p></li><li><p>GC三步曲</p><ul><li>枚举根节点引用</li><li>发现并标记活跃对象</li><li>垃圾内存清理<br>分代回收分两种：Scavenge和Mark-Sweep<ul><li>Scavenge 分配指针达到新生代末尾时清理</li><li>Mark-Sweep 活跃超过两个小周期的对象，需要将其移动到老生区</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;Node/V8学习笔记系列1，关于Isolate（V8实例）和GC（垃圾回收机制）。&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="http://derekz.cn/categories/code/"/>
    
    
      <category term="node" scheme="http://derekz.cn/tags/node/"/>
    
      <category term="v8" scheme="http://derekz.cn/tags/v8/"/>
    
  </entry>
  
  <entry>
    <title>dz&#39;s 你好2018</title>
    <link href="http://derekz.cn/posts/8b1fc7d6/"/>
    <id>http://derekz.cn/posts/8b1fc7d6/</id>
    <published>2018-01-03T17:52:57.000Z</published>
    <updated>2018-06-06T03:50:26.473Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;可能很难实现但还是怀着希望认认真真写下来的新年计划。<br><a id="more"></a></p><h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><h4 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h4><ul><li>javaScript和typeScript<ul><li>2018希望能追上js的脚步，掌握js这门语言的本质和es6-8的一些新东西</li><li>typeScript希望能用起来，用得6起来</li></ul></li><li>node<ul><li>深入理解node的异步I/O实现，读一读libuv源码</li><li>读一读node的几个內建模块源码</li><li>尝试写npm包</li><li>用node手撸server，比如搞个爬虫</li></ul></li><li>浏览器<ul><li>尝试了解V8实现</li></ul></li><li>框架类库<ul><li>react源码学习，掌握react和全家桶</li><li>打包工具如webpack/Parcel熟练</li><li>dubbo框架深入理解</li></ul></li><li>maybe<ul><li>weex</li><li>小游戏、小程序</li><li>其他兴趣点</li></ul></li></ul><h4 id="全栈之路"><a href="#全栈之路" class="headerlink" title="全栈之路"></a>全栈之路</h4><ul><li>计算机几门课程<ul><li>计算机原理</li><li>计算机网络</li><li>编译原理</li><li>数据结构、算法</li></ul></li><li>学一门外语<ul><li>Python/go语言基础</li><li>用学的这门语言实现一个系统</li></ul></li><li>其他兴趣点</li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li>github<ul><li>写几个自己的项目</li></ul></li><li>技术博客<ul><li>记录每天的技术积累</li></ul></li><li>英语学习</li></ul><h3 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h3><h4 id="身体"><a href="#身体" class="headerlink" title="身体"></a>身体</h4><ul><li>运动<ul><li>每周至少运动两次</li><li>跑步、周末爬山、打球都可以</li></ul></li><li>早睡早起，好吃好喝<ul><li>平时8点起床，12点睡觉</li><li>早餐都要吃，周末在家好好多吃点</li></ul></li></ul><h4 id="灵魂"><a href="#灵魂" class="headerlink" title="灵魂"></a>灵魂</h4><ul><li>阅读写作<ul><li>每天至少阅读半小时非技术类书籍</li><li>每天一份工作笔记（quiver），一份日记（手写日记本）</li><li>每周至少一篇技术文章，一篇个人文章</li></ul></li><li>娱乐<ul><li>平时每天玩游戏时间不超过1小时</li><li>多听听歌，看看电影，追追剧还能练练听力</li></ul></li><li>摄影<ul><li>学习学习</li></ul></li></ul><h4 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h4><ul><li>每周给家里至少打一次电话</li><li>记住宝宝的喜好，记下每一次旅行，每一个特殊的时刻</li><li>记账，不乱花钱，学会攒钱，有机会学学理财</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;可能很难实现但还是怀着希望认认真真写下来的新年计划。&lt;br&gt;
    
    </summary>
    
      <category term="life" scheme="http://derekz.cn/categories/life/"/>
    
    
      <category term="thinking" scheme="http://derekz.cn/tags/thinking/"/>
    
  </entry>
  
  <entry>
    <title>dz&#39;s 2017那些事</title>
    <link href="http://derekz.cn/posts/815e4034/"/>
    <id>http://derekz.cn/posts/815e4034/</id>
    <published>2018-01-01T13:03:40.000Z</published>
    <updated>2018-06-06T03:50:26.472Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;这是一篇正经的需要上交的年度总结。<br><a id="more"></a></p><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>&emsp;&emsp;大概是第一次年度总结，大概率还会有第二次，希望有第二十次。<br>&emsp;&emsp;提笔前很自然地想，这一年经历了些什么，有什么是值得写下来的，为什么值得，为什么要写下来？<br>&emsp;&emsp;借着这次团队作业的机会，问问自己这些问题，写下来备忘。若有读来感到不适的内容，读者大大们可以自由略过啦~</p><p>&emsp;&emsp;曾经有过每天打开ONE（没错，就是岳父的那个one）看一句话的习惯，后来大概懒了忘了，开始好几天看一次，一次读完错过的那些天。于是会想时间每天、每秒匀速地流动，实际上每天都是一样的。为了让时间的流动可感受，我们结合地球运行的规律定义了我们日常的时间：从秒到年。我们把每年的开始作为节日，作为一个重要的刻度，赋予这一天特殊的身份，可实际上抛去我们自己定义的时间观念，这一天其实既平凡又渺小。</p><p>&emsp;&emsp;选择在这一天来做总结，不是因为这一天多么重要，而是因为知晓这一年你的感受、经历非常重要。时间会让人遗忘，遗忘的不止是做过什么，学过什么，更重要的是自己凭借对自己的拷问而定下的从开始到结束的目标。即便没有明确的目标，也有一条能够推导到这一目标的线索，即人对于自我的认识，这种认识在成长过程中也许会一点点修正，也许始终如一，我们需要用一个特定时刻来总结和记住的大概就是这样的对自我的认识。（对自我的认知当然包括自我感情的认知啦，例如对某某的爱意，介于这是一篇正经的需要上交的年度总结，还是跳过这部分啦）</p><p>&emsp;&emsp;这是我理解的必要性。</p><h4 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h4><p>&emsp;&emsp;要说去年今天的心情，还得提一提大学。介于现在并不想回忆大学时光，简单总结到一句话：学没学好，玩没玩够。<br>&emsp;&emsp;2016年毕业，毕业前是处境艰难的学渣阶级，绩点虽然没惨到毕不了业，但离保研的底线还是差了一些，美其名为不喜欢实验室做研究，准备落草工业界占山为王。4月边做毕设边实习，写下第一行js代码，毕业后转正，履历上多了个前端工程师的title。作为一只对力量一无所知的小绵羊，很幸运的一点是碰上了一个trust young的团队。一开始什么都不会写的时候，也是什么都可以写的时候，正好创业公司又缺人，几个月下来，前端、后台、数据组甚至运维大哥都成了可以一起干活的小伙伴。那个时候认识了个厉害的词叫全栈，后来知道我们的圈子太小，我的眼光太窄，我以为的全栈与真正的全栈相去甚远。</p><p>&emsp;&emsp;大学的时候对什么都不感兴趣，工作以后却好像对什么都感兴趣，然而事实我心知肚明，我只是不知道该干什么而已。</p><p>&emsp;&emsp;2017年1月1日，我心里没有答案。</p><h4 id="来杭前"><a href="#来杭前" class="headerlink" title="来杭前"></a>来杭前</h4><p>&emsp;&emsp;春节前，leader约谈绩效，第一次有人找我聊方向。<br>&emsp;&emsp;leader提醒我，我在做的事情有点杂了。我明白他的好意（leader人很好，非常庆幸能在第一份工作遇上他这样的领路人），我记得当时给他的回答是接下来会深入前端。我确实是这么想的，只是心里还抱着一个疑问没有和任何人提起：我为什么要选择写代码？<br>&emsp;&emsp;大学计算机专业，看起来写代码合情合理，但实际上任何时候选择都有很多，只是看自己愿不愿意。我的不愿意是因为害怕和对自己的不了解，害怕失败，害怕让家人失望，不了解自己的兴趣、长处和能力强弱。这些是大学里不需要思考的问题，懒了几年的我在猝不及防的毕业到来时没有勇气做出别的选择。</p><p>&emsp;&emsp;完成第一个需求以后，事情开始变得不太一样了。<br>&emsp;&emsp;需求本身可能很简单，但在开发者眼里，看到的可能是复杂的逻辑、无奈的实现，甚至是隐藏的bug。我们也许不关心一行代码对应哪些指令，操作哪几个寄存器，经历多少时钟周期，但我们不能遗忘这行代码长途跋涉，历经千山万水最终为我们实现功能的艰辛和执着。（读到这里感觉不适请快进。。。）这些都是属于开发者的东西，也是我在工作最初的一段时间内感到充实的原因。纯洁如白纸的我为了实现第一个需求开启了计算机人的自学模式，发现从不会到想办法解决的过程中自己异常的专注，不管问题有没有解决，至少感觉时间没有虚度。<br>&emsp;&emsp;这种充实在后来几个月却渐渐消失了，因为熟悉了以后开始做重复的工作，而且因为量大，这样的工作占据了一天绝大多数时间。不仅没有挑战，不需要学习，而且没有多少时间剩余去学自己想学的，写自己的代码。（所以个人觉得对于程序员来说一份好的工作要么应该是充满挑战的，要么是能让你有富余时间做自己的）</p><p>&emsp;&emsp;春节过后，公司突然慢了下来，工作外的时间变多了，就又开始做些有趣的事情了。<br>&emsp;&emsp;没记错的话那时候在和微信打交道，小程序啊公众号啊，觉得挺新奇的。（当初自作主张给公司的公众号接了个第三方的聊天机器人，至今好像还没被大佬们发现…）程序员的世界是这样的，一个问题抛出来，可能会变成一张网，想要彻底弄清楚一件事情，你会发现你的问题越来越多，所以需要不断地全面地去学习理解。这是我觉得很有意思，也很想做的事情，我理解的是要形成一个完整的知识体系需要持续的不懈的学习，从兴趣点出发去往外一点点拓展而不是刻意去按部就班学，会是更好的选择。<br>&emsp;&emsp;3月的时候，公司业绩被萨德影响却显得异常平静，而我则接了个整站重构的需求，和后台大兄弟两人坐在一块，起早贪黑撸起袖子干得不亦乐乎。可能重构的时候太投入了，并没有觉得公司会倒下。。。</p><p>&emsp;&emsp;4月，暴风雨袭来，公司开始大规模裁员，从CTO到普通员工接连出走。其实决定离开的时候还是有些不舍的，毕竟是毕业后第一份工作，遇上的第一批共事的可爱的人们，一个还不错的工作氛围。<br>&emsp;&emsp;离职前的一个月，处于放养状态的我开始手撸博客，用的正是为公司官网重构时学习的nuxt框架。作为一名渣渣前端新人，靠着吃大学仅有的一点老本完成开发、部署，搞了个自己的服务器，自己的博客站。哇，当时真是开心得不行，三天两头看阿里云服务器访问日志，结果可想而知，只有我自己。把这个东西勉强称为作品的话，虽然非常希望有人认可，但更重要的还是作品实现的过程中做出的努力和学到的东西。</p><p>&emsp;&emsp;生活的理想是为了理想的生活，对于人生经历尚浅的我来说，这是目前最能接受的一句话了。工作让我衣食无忧，碰巧程序员的世界里又不缺挑战，这些挑战让我的一年不是1*365天的重复，而是每天都能通过学习而收获，进而丰富自己的认知。学习中重要的不是仅仅几个框架、几门语言，而是实现目标的思维方式和逻辑过程，能够收获这些，大概就是我现阶段理想的生活了。</p><h4 id="香波地"><a href="#香波地" class="headerlink" title="香波地"></a>香波地</h4><p>&emsp;&emsp;6月转移阵地来杭州，加入点我达大家庭。</p><p>&emsp;&emsp;开始的几天感觉像是乡下孩子进城，眼前看到的都是新奇有趣的事情，才发现自己的池子有多浅，以至于一时沉迷学习无法自拔。碗里水少的一个好处在于能多装，学习react/redux/dubbo这些东西的过程比我想象得要顺利些。看项目的时候发现很多以前根本不知道的东西，瞬间觉得自己怎么这么菜，前端的水比自己想得深太多太多了。<br>&emsp;&emsp;新手保护结束后，提起键盘就是干。从小需求开始熟悉项目，主要是新老鹰眼，其实这两个项目本质上还是很接近的，react作为view层的实现，基于flux思想的数据流动分别由reflux和redux来实现。cs = 数据结构 + 算法，就做需求而言，我需要用到复杂算法的机会很少，所以了解了数据结构和数据整个流向其实开发问题就不大了。</p><p>&emsp;&emsp;前两个月基本上都是这样，感觉都是一个套路，需求完成得挺快也没什么问题，多余很多时间花在了自己看书学习上。然后问题出现了，简单的需求确实可以在知之不详的情况下快速开发，但碰到细节问题的时候凭着半吊子的水平就显得捉襟见肘了。只看到大概就以为理解了，实际上核心的实现以及隐藏的问题都需要花时间啃透，于是开始在卡住的地方尝试深挖，看看源码，各种查资料。踩坑学习之旅通常都是痛并快乐着的。<br>&emsp;&emsp;8月以后每天开始写小笔记，quiver上简单记一记，有项目时间安排，有学到的东西，也有未来几天的计划。好记性不如烂笔头，我的理解是记下来的好处更多的不是在于以后能翻出来看（我写的笔记好像基本没看过），而在于延长了学习的时间，动笔的时候会更深入地去思考这些内容，是不是有更深的地方可以挖掘。项目和计划写下来的好处是每天都有了时间规划，不会因为无聊而被迫去思考宇宙和人生，有效地保护了发际线。</p><p>&emsp;&emsp;解决了技术上的问题以后，碰到的是一些流程上的坑。可以感觉到的是我司其实一开始在项目开发流程上也是不太合理的，几个月调整下来，虽然还有些问题，但应该是比较稳定规范了。这个过程对我来说也促成了一种转变，上一家的时候，项目时间相对自由，即便有的时候开发时间限定死了，还是可以允许带bug提测。上线也是一样，除了app外没有严格限制时间，有问题可能临时修复，马上就发掉了。可以说对开发的质量要求并不高。。。近期我司的发布窗口和故障系统可以说很严格了，虽然带来了一些麻烦，但确实能够提高我们对自己的要求。<br>&emsp;&emsp;说到这里必须先检讨下近期的几个需求，好几个都是一眼就能够发现的问题却硬生生被忽略掉，上线才冒出头，命大没算故障，却是敲了好几道警钟。主要还是自己不够小心，一直很不喜欢去review自己的代码，因为要是去看的话大概率会想推倒重来。一方面还是要写代码的时候多想想可能的问题，一方面自测的时候要上心点，至少跑一遍测试用例，保证代码质量。<br>&emsp;&emsp;近两个月的话其实工作上还是照旧，只是需求一个个做下来，对需求理解更到位了，和服务对接时的成本更低了，开发过程中要开的会多了。忙里偷闲又搞了个博客，把之前手撸的那个干掉了，不知道这次这个博客能活多久。</p><p>&emsp;&emsp;坦白说，我个人是属于那种很难找到归属感的人。。。一个人、一群人，相处久了，感情都会自然沉淀，但是我不能把这种感情理解为团队归属感。我可以说很喜欢大家，是因为和大家在一起工作很舒服，一起吃饭聊天玩耍很开心。以人为镜我学到了很多，与人为伴使我感到温暖，也丰富了我的生活，为此我心存感激。但是这样的心情并不是只对团队中的大家才有的，虽然很遗憾，但我确实还找不到归属感。</p><h4 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h4><p>&emsp;&emsp;还是暂时不聊了。</p><h4 id="一言以蔽之"><a href="#一言以蔽之" class="headerlink" title="一言以蔽之"></a>一言以蔽之</h4><p>&emsp;&emsp;说是年度总结，其实也没怎么写具体的工作和收获内容，不是不愿，而是觉得这些才是我想写下来的，以后可能会翻一翻的内容。（如果需要具体工作内容总结大佬可以私聊下，回头我补一份。。。）写下这篇文章，希望在以后的某一天能够帮忙回忆起这一年的心中所想，是否和曾经的自己已经大不一样，生活是否如那年期许？</p><h4 id="2018-1-1"><a href="#2018-1-1" class="headerlink" title="2018.1.1"></a>2018.1.1</h4><p>&emsp;&emsp;越是学习，越觉得自己功力浅薄，好在今天的目标和6月定下的相差无二。<br>&emsp;&emsp;前路漫漫，惟愿日拱一卒。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;这是一篇正经的需要上交的年度总结。&lt;br&gt;
    
    </summary>
    
      <category term="life" scheme="http://derekz.cn/categories/life/"/>
    
    
      <category term="thinking" scheme="http://derekz.cn/tags/thinking/"/>
    
  </entry>
  
  <entry>
    <title>mvx 从todo mvc说起</title>
    <link href="http://derekz.cn/posts/c4697232/"/>
    <id>http://derekz.cn/posts/c4697232/</id>
    <published>2017-12-18T08:17:17.000Z</published>
    <updated>2018-06-06T03:50:26.470Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;在git上看到一个<a href="https://github.com/tastejs/todomvc" target="_blank" rel="noopener">to do mvc</a>的repo，一时有了兴致，记录下一些点。<br><a id="more"></a></p><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><h4 id="静态-展示-gt-动态-交互"><a href="#静态-展示-gt-动态-交互" class="headerlink" title="静态/展示-&gt;动态/交互"></a>静态/展示-&gt;动态/交互</h4><ul><li>web1.0时代，服务端直接将数据填充进模板，生成Html返回给浏览器，静态网页，纯展示</li><li>web2.0时代，动态网页，前端向服务端请求数据，然后自己处理数据，提供了用户和浏览器的交互</li></ul><h4 id="前端mv-的必要性"><a href="#前端mv-的必要性" class="headerlink" title="前端mv*的必要性"></a>前端mv*的必要性</h4><ul><li>前端进入到需要保存数据、处理数据和生成视图的web2.0时代</li><li>webapp的概念，web不再是页面级，而是application级别，所以需要思考应用的管理，数据的流向等</li></ul><p><img src="http://opo02jcsr.bkt.clouddn.com/ff5d456ff2abab2a42527f3bae237132.png" alt=""></p><h3 id="todo-mv"><a href="#todo-mv" class="headerlink" title="todo mv*"></a>todo mv*</h3><ul><li>其实差别就前端如何管理数据，以及数据如何和视图联系起来</li></ul><h4 id="backbone"><a href="#backbone" class="headerlink" title="backbone"></a>backbone</h4><ul><li>只有Model和View</li><li><p>结构<br>├── index.html<br>├── js</p><pre><code>├── app.js├── collections│   └── todos.js├── models│   └── todo.js├── routers│   └── router.js└── views    ├── app-view.js    └── todo-view.js</code></pre></li><li><p>以新增为例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// views/app-view.js</span></span><br><span class="line"><span class="comment">// 绑定节点</span></span><br><span class="line">el: <span class="string">'.todoapp'</span>,</span><br><span class="line"><span class="comment">// 声明事件</span></span><br><span class="line">events: &#123;</span><br><span class="line">  <span class="string">'keypress .new-todo'</span>: <span class="string">'createOnEnter'</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用户在view层enter，调用collection的方法创建新的todo model</span></span><br><span class="line">createOnEnter: <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e.which === ENTER_KEY &amp;&amp; <span class="keyword">this</span>.$input.val().trim()) &#123;</span><br><span class="line">    app.todos.create(<span class="keyword">this</span>.newAttributes());</span><br><span class="line">    <span class="keyword">this</span>.$input.val(<span class="string">''</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// collections/todos.js</span></span><br><span class="line"><span class="keyword">var</span> Todos = Backbone.Collection.extend(&#123;</span><br><span class="line">  <span class="comment">// Reference to this collection's model.</span></span><br><span class="line">  model: app.Todo,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// models/todo.js</span></span><br><span class="line">app.Todo = Backbone.Model.extend(&#123;</span><br><span class="line">  defaults: &#123;</span><br><span class="line">    title: <span class="string">''</span>,</span><br><span class="line">    completed: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// viwes/todo-views.js</span></span><br><span class="line"><span class="comment">// 绑定模板</span></span><br><span class="line">template: _.template($(<span class="string">'#item-template'</span>).html()),</span><br><span class="line"><span class="comment">// 监听model的change，注册回调render</span></span><br><span class="line">initialize: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.listenTo(<span class="keyword">this</span>.model, <span class="string">'change'</span>, <span class="keyword">this</span>.render);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// render方法，将model数据填充</span></span><br><span class="line">render: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.model.changed.id !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.$el.html(<span class="keyword">this</span>.template(<span class="keyword">this</span>.model.toJSON()));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义model和collection，在view层通过事件触发model层行为，改变数据后，通过事先注册的监听model变化的回调函数来更新view</p></li></ul><h4 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h4><ul><li>model, view, modelview (mvvm)</li><li>结构<br>├── index.html<br>├── js<br>│ ├── app.js<br>│ ├── routes.js<br>│ └── store.js</li><li><p>新增为例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="comment">// vue对象，连接view和model的vm</span></span><br><span class="line">exports.app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// 绑定节点</span></span><br><span class="line">  el: <span class="string">'.todoapp'</span>,</span><br><span class="line">  <span class="comment">// 定义数据模型</span></span><br><span class="line">  data: &#123;</span><br><span class="line">    todos: todoStorage.fetch(),</span><br><span class="line">    newTodo: <span class="string">''</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 修改数据模型的方法</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    addTodo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> value = <span class="keyword">this</span>.newTodo &amp;&amp; <span class="keyword">this</span>.newTodo.trim();</span><br><span class="line">      <span class="keyword">if</span> (!value) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.todos.push(&#123; <span class="attr">id</span>: <span class="keyword">this</span>.todos.length + <span class="number">1</span>, <span class="attr">title</span>: value, <span class="attr">completed</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">      <span class="keyword">this</span>.newTodo = <span class="string">''</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.html</span></span><br><span class="line"><span class="comment">// v-modal将数据（vm）和节点（v）绑定，通过事件触发vue对象的方法改变数据，并通过观察者模式和自定义的访问器实现view的更新</span></span><br><span class="line">&lt;input <span class="class"><span class="keyword">class</span></span>=<span class="string">"new-todo"</span> autofocus autocomplete=<span class="string">"off"</span> v-model=<span class="string">"newTodo"</span> @keyup.enter=<span class="string">"addTodo"</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p>vm实际上是简化的controller，将model数据简单处理，为view提供正确的数据</p></li></ul><h4 id="react"><a href="#react" class="headerlink" title="react"></a>react</h4><ul><li>react只是视图层解决方案，本质是将图形界面（GUI）函数化。</li><li>view是state的输出，引自阮一峰老师 <code>js view = f(state)</code></li><li>组件state/props用于数据存储流转，render函数输出view，事件驱动产生数据变化，setState重新render…</li><li>结构<br>├── index.html<br>├── js<br>│ ├── app.jsx<br>│ ├── footer.jsx<br>│ ├── todoItem.jsx<br>│ ├── todoModel.js<br>│ └── utils.js<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// todoModel.js</span></span><br><span class="line"><span class="comment">// 定义model，在原型上定义一些方法，比如存数据到localstorage里持久化</span></span><br><span class="line">app.TodoModel = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.key = key;</span><br><span class="line">  <span class="keyword">this</span>.todos = Utils.store(key);</span><br><span class="line">  <span class="keyword">this</span>.onChanges = [];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 注册回调进行订阅</span></span><br><span class="line">app.TodoModel.prototype.subscribe = <span class="function"><span class="keyword">function</span> (<span class="params">onChange</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.onChanges.push(onChange);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用inform时通知各个订阅者，执行回调</span></span><br><span class="line">app.TodoModel.prototype.inform = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  Utils.store(<span class="keyword">this</span>.key, <span class="keyword">this</span>.todos);</span><br><span class="line">  <span class="keyword">this</span>.onChanges.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">cb</span>) </span>&#123; cb(); &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// app.jsx</span></span><br><span class="line"><span class="keyword">var</span> TodoApp = React.createClass(&#123;</span><br><span class="line">  <span class="comment">// 初始化state</span></span><br><span class="line">  getInitialState: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      newTodo: <span class="string">''</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 事件触发，setState，重新render</span></span><br><span class="line">  handleChange: <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">newTodo</span>: e.target.value&#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;</span><br><span class="line">      &lt;input onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class="line">      &lt;div&gt;&#123;this.state.newTodo&#125;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">var model = new app.TodoModel('react-todos');</span><br><span class="line">function render() &#123;</span><br><span class="line">  React.render(</span><br><span class="line">    &lt;TodoApp model=&#123;model&#125;/&gt;,</span><br><span class="line">    document.getElementsByClassName('todoapp')[0]</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">model.subscribe(render);</span><br><span class="line">render()</span><br></pre></td></tr></table></figure></li></ul><h4 id="flux"><a href="#flux" class="headerlink" title="flux"></a>flux</h4><p><img src="http://opo02jcsr.bkt.clouddn.com/a1f71617fc991252b13bbb92ecf1f910.png" alt=""></p><ul><li>不同组件的state放在一个外部的通用的store里</li><li>每个组件订阅该store的一部分</li><li>组件内通过dispatch一个action去触发store的更新</li></ul><h4 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h4><p><img src="http://opo02jcsr.bkt.clouddn.com/fd0c3c8b8fdf803f8cc2adc1698a799e.png" alt=""></p><ul><li>状态都存放在store中，组件的重新渲染都由状态改变来触发</li><li><p>用户通过在view层dispatch action触发reducer，在reducer中 new = f(old) 计算得到新的state</p><p><img src="http://opo02jcsr.bkt.clouddn.com/98fc05f593a3c073b475091c9849ac92.png" alt=""></p></li><li><p>UI组件和容器组件</p><ul><li>UI组件负责页面外观</li><li>容器组件负责数据和行为，订阅store，处理store的数据然后传递给UI组件，例如connect方法</li></ul></li><li><p>Provider和connect</p><ul><li><p>前者将react应用包一层，使得组件和store可被连接，同时传入store</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(reducer);</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Provider&gt;,</span></span><br><span class="line"><span class="regexp">  document.body.appendChild(document.createElement('div'))</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure></li><li><p>store由redux得createStore方法提供，该方法接收reducer作为参数，实际上相当于定义了action list对应的处理对象和方案</p></li><li>connect将UI组件和容器组件连接，使得在我们的UI/业务组件中能够获取到最初定义好的store，并在UI组件中通过dispatch action去对上一条所说的处理对象执行处理方案</li></ul></li><li><p>reducer<br>-纯函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收旧的state和action，返回新的state</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state = &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  text: <span class="string">'你好，访问者'</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  name: <span class="string">'访问者'</span></span></span></span><br><span class="line"><span class="function"><span class="params">&#125;, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'change'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        name: action.payload,</span><br><span class="line">        text: <span class="string">'你好，'</span> + action.payload</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>典型的MV*，model对应于store，view对应于业务组件，连接起来或者说数据处理交由action reducer完成，适合于大型应用。</li></ul></li></ul><h4 id="Mobx"><a href="#Mobx" class="headerlink" title="Mobx"></a>Mobx</h4><ul><li>UI 层是观察者，Store 是被观察者。</li><li>🌰 下回分解<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;observable&#125; = mobx;</span><br><span class="line"><span class="keyword">const</span> &#123;observer&#125; = mobxReact;</span><br><span class="line"><span class="keyword">const</span> person = observable(&#123;<span class="attr">name</span>: <span class="string">"张三"</span>, <span class="attr">age</span>: <span class="number">31</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> App = observer(</span><br><span class="line">  (&#123; person &#125;) =&gt; &lt;h1&gt;&#123; person.name &#125;&lt;/h1&gt;</span><br><span class="line">);</span><br><span class="line">ReactDOM.render(&lt;App person=&#123;person&#125; /&gt;, document.body);</span><br><span class="line">person.name = "李四";</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;在git上看到一个&lt;a href=&quot;https://github.com/tastejs/todomvc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;to do mvc&lt;/a&gt;的repo，一时有了兴致，记录下一些点。&lt;br&gt;
    
    </summary>
    
      <category term="code" scheme="http://derekz.cn/categories/code/"/>
    
    
      <category term="mvx" scheme="http://derekz.cn/tags/mvx/"/>
    
  </entry>
  
  <entry>
    <title>dz-life 摄影小笔记</title>
    <link href="http://derekz.cn/posts/2082e7b0/"/>
    <id>http://derekz.cn/posts/2082e7b0/</id>
    <published>2017-12-13T17:34:59.000Z</published>
    <updated>2018-06-06T03:50:26.473Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;我能想到最浪漫的事…之一，就是用镜头记录下你最美的瞬间。<br><a id="more"></a></p><h2 id="小呆学摄影基础篇"><a href="#小呆学摄影基础篇" class="headerlink" title="小呆学摄影基础篇"></a>小呆学摄影基础篇</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="曝光"><a href="#曝光" class="headerlink" title="曝光"></a>曝光</h4><ul><li>也即是进光量，可以通过光圈、快门共同控制</li></ul><h4 id="快门"><a href="#快门" class="headerlink" title="快门"></a>快门</h4><ul><li>快门控制进光时间，高速快门（如1/8000）拍清晰瞬间（如猎豹抓🐑），低速快门拍运动过程（如丝绸状水流，动云+静山的动静结合图）</li></ul><h4 id="光圈"><a href="#光圈" class="headerlink" title="光圈"></a>光圈</h4><ul><li>光圈控制进光量，大光圈（数值小如1.2）可以配合快速快门，在曝光准确的情况下防抖</li><li>大光圈的清晰范围更少（小景深），造成前景清晰，背景模糊的虚实关系，画个图可以理解</li></ul><h3 id="单反"><a href="#单反" class="headerlink" title="单反"></a>单反</h3><h4 id="镜头"><a href="#镜头" class="headerlink" title="镜头"></a>镜头</h4><ul><li>物镜是一组凸透镜，变焦镜头支持一个区间的焦距，比如尼康18-140，属于中长焦的镜头</li><li>焦距影响的是目标物体占据成像区域的面积比例，emmm，画个图大概就清楚了，长焦拍得这个比例更大，看起来好像离物体更近</li></ul><h4 id="机身"><a href="#机身" class="headerlink" title="机身"></a>机身</h4><ul><li><p>全画幅/半画幅<br>通过相机的感光元件的成像面积区分，画个图应该能理解，全画幅能够达到拍摄范围更广的效果<br>是否支持全画幅要看机身类型</p></li><li><p>结构<br>单反的物镜兼职取景镜，利用毛玻璃反射和五棱镜/五面镜折射/反射，将倒立的像矫正完成光学取景<br>感光元件相当于曾经的底片，快门按下，毛玻璃弹起，光线射到感光元件成像</p></li></ul><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><h4 id="光圈优先-A-AV"><a href="#光圈优先-A-AV" class="headerlink" title="光圈优先 A/AV"></a>光圈优先 A/AV</h4><ul><li>光圈直接影响景深，所以这种模式适用广泛，拍人比如2.8，3.5大光圈，拍景物，为了前中后景都清晰，可以用8以上</li></ul><h4 id="快门优先-S-TV"><a href="#快门优先-S-TV" class="headerlink" title="快门优先 S/TV"></a>快门优先 S/TV</h4><ul><li>快门可以控制画面的运动效果，看是要高速瞬间还是丝滑轨迹</li><li>1/60 拍不动的人 1/400拍个汽车 1/2拍丝绸般水流</li></ul><h4 id="曝光补偿"><a href="#曝光补偿" class="headerlink" title="曝光补偿"></a>曝光补偿</h4><ul><li>看测光标尺，设置曝光补偿</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;我能想到最浪漫的事…之一，就是用镜头记录下你最美的瞬间。&lt;br&gt;
    
    </summary>
    
      <category term="life" scheme="http://derekz.cn/categories/life/"/>
    
    
      <category term="摄影" scheme="http://derekz.cn/tags/%E6%91%84%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>dubbo-rpc 初探rpc</title>
    <link href="http://derekz.cn/posts/c48da636/"/>
    <id>http://derekz.cn/posts/c48da636/</id>
    <published>2017-11-21T14:08:50.000Z</published>
    <updated>2018-06-06T03:50:26.470Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;抱着学习理解dubbo的心思，从各方大佬身上取经，记下学习笔记，方便自己，服务志同道合的小伙伴们。<br><a id="more"></a></p><h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><h4 id="远程过程调用协议（Remote-Procedure-Call-Protocol）"><a href="#远程过程调用协议（Remote-Procedure-Call-Protocol）" class="headerlink" title="远程过程调用协议（Remote Procedure Call Protocol）"></a>远程过程调用协议（Remote Procedure Call Protocol）</h4><ul><li><p>speak chinese:<br>&emsp;部署在A服务器上的应用a需要调用部署在B服务器上的b应用提供的c函数/方法，这个时候就需要实现远程过程调用，RPC就是实现这一功能的协议。</p></li><li><p>本地过程调用:<br>&emsp;举个🌰</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> c = a + b;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b1 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> c1 = add(a1, b1);</span><br></pre></td></tr></table></figure><p><code>int c1 = add(a1, b1)</code>执行过程：</p><ul><li>将a1, b1值压栈</li><li>进入add函数，取出栈中a1, b1，赋值给a, b</li><li>计算a + b，将结果存在c</li><li>c压栈，从add函数返回</li><li>从栈中取出c的值，赋值给c1</li></ul></li><li><p>那么问题来了<br>&emsp;本地调用由于函数/参数都存在内存中，可以直接调用/读取，合情合理，不需要做特别处理。<br>&emsp;而上面栗子中的a应用要完成使命，首先需要和b应用通过网络建立进程间通信，然后将参数以某种b应用能够理解的形式传递过去，并且b应用需要按照某种约定准确找到c函数/方法，返回结果的过程类似。<br>&emsp;对于负责业务代码的程序员来说，我们不关注远程调用的细节，我们希望的是远程调用能够做到和本地调用看起来是一样的，这样我们所写的代码不需要考虑调用场景特殊化处理。这一点需要实现以下几部分：</p><ul><li>call ID 映射<br>本地调用函数直接会找到函数指针，远程调用时，地址空间毫无关联，所以需要给所有的函数一个ID，消费端和提供端都需要维护这样一个ID映射，在远程调用时，消费者会带上这个ID，提供端根据ID找到相应的函数再去执行。</li><li>序列化/反序列化<br>由于必须通过网络传输传递参数，传输两端需要能够理解交换的数据，原本存储在内存中的参数值在消费端进行序列化，到达提供端后进行反序列化恢复成内存中的表达形式，然后在提供端执行函数/方法，返回结果类似，同样需要序列化和反序列化。</li><li>网络传输<br>网络传输这一块大部分RPC框架使用TCP协议，实际上能够实现网络传输目的的其他一些协议也是适用的。</li></ul></li></ul><h4 id="RPC结构"><a href="#RPC结构" class="headerlink" title="RPC结构"></a>RPC结构</h4><ul><li><p>图解<br><img src="http://opo02jcsr.bkt.clouddn.com/94086df8115831bd40ef99719aacae9c.jpeg" alt=""></p><ul><li>&emsp;RPC 服务方通过 <code>RpcServer</code> 去export远程接口方法，而客户方通过 <code>RpcClient</code> 去import远程接口方法。</li><li>&emsp;客户方像调用本地方法一样去调用远程接口方法，RPC 框架提供接口的代理实现，实际的调用将委托给代理 <code>RpcProxy</code> 。</li><li>&emsp;代理封装调用信息并将调用转交给 <code>RpcInvoker</code> 去实际执行。</li><li>&emsp;在客户端的 <code>RpcInvoker</code> 通过连接器 <code>RpcConnector</code> 去维持与服务端的通道 <code>RpcChannel</code>，并使用 <code>RpcProtocol</code> 执行协议encode并将编码后的请求消息通过通道发送给服务方。</li><li>&emsp;RPC 服务端接收器 <code>RpcAcceptor</code> 接收客户端的调用请求，同样使用 <code>RpcProtocol</code> 执行协议decode。解码后的调用信息传递给 <code>RpcProcessor</code> 去控制处理调用过程，最后再委托调用给 <code>RpcInvoker</code> 去实际执行并返回调用结果。</li></ul></li></ul><h4 id="RPC组件"><a href="#RPC组件" class="headerlink" title="RPC组件"></a>RPC组件</h4><ul><li><code>RpcServer</code> 用于服务方导出远程接口方法，<code>RpcClient</code> 用于客户方引入接口方法的代理实现</li><li><code>RpcProxy</code> 是远程接口方法的代理实现</li><li><code>RpcInvoker</code><ul><li>客户方实现：负责编码调用信息和发送调用请求到服务方并等待调用结果返回</li><li>服务方实现：负责调用服务端接口的具体实现并返回调用结果</li></ul></li><li><code>RpcProtocol</code> 负责编解码</li><li><code>RpcConnector</code> 负责维持客户方和服务方的连接通道和发送数据到服务方</li><li><code>RpcAcceptor</code> 负责接收客户方请求并返回请求结果</li><li><code>RpcProcessor</code> 负责服务方控制调用过程，包括管理调用线程池、超时时间等</li><li><p><code>RpcChannel</code> 数据传输通道</p><p>组件具体实现后续参考dubbo框架再来学习</p></li></ul><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul><li>远程调用可能由于网络问题没有到达服务方，所以调用未必一定执行</li><li>远程调用抛出的异常可能是RPC框架运行时异常</li><li>远程调用消耗肯定是高于本地调用的，所以考虑导出为远程接口的前提是计算消耗远大于RPC的固有消耗</li></ul><p>上述内容部分引用自 <a href="http://blog.csdn.net/mindfloating/article/details/39474123" target="_blank" rel="noopener">深入浅出 RPC - 深入篇</a></p><h3 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h3><h4 id="惯例吹一波"><a href="#惯例吹一波" class="headerlink" title="惯例吹一波"></a>惯例吹一波</h4><ul><li><p>基于java的高性能开源RPC框架，主要实现了RPC远程调用、集群容错和负载均衡、服务管理和监控三大块功能。</p><p><img src="http://opo02jcsr.bkt.clouddn.com/deabda567257a04070d7183bef92e860.png" alt=""></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;抱着学习理解dubbo的心思，从各方大佬身上取经，记下学习笔记，方便自己，服务志同道合的小伙伴们。&lt;br&gt;
    
    </summary>
    
      <category term="code" scheme="http://derekz.cn/categories/code/"/>
    
    
      <category term="rpc" scheme="http://derekz.cn/tags/rpc/"/>
    
      <category term="dubbo" scheme="http://derekz.cn/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>js-es6 异步篇</title>
    <link href="http://derekz.cn/posts/7819203f/"/>
    <id>http://derekz.cn/posts/7819203f/</id>
    <published>2017-11-07T05:41:34.000Z</published>
    <updated>2018-06-06T03:50:26.472Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;承上一篇，本文记录了es6的Promise对象、Generator函数和async await语法糖，异步真是让人又爱又恨。<br><a id="more"></a></p><h2 id="lesson1-Promise"><a href="#lesson1-Promise" class="headerlink" title="lesson1 Promise"></a>lesson1 Promise</h2><h3 id="你的名字"><a href="#你的名字" class="headerlink" title="你的名字"></a>你的名字</h3><ul><li><code>Promise</code> 诞于社区，初为异步编程之解决方案，后有ES6将其写入语言标准，终成今人所言之 <code>Promise</code> 对象<ul><li>Promise对象特点有二：状态不受外界影响、一旦状态改变后不会再次改变</li></ul></li></ul><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ul><li><p>Promise对象为一个构造函数，用于生成Promise实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接受一个函数作为参数，函数参数有两个，为js引擎内部实现的两个函数</span></span><br><span class="line"><span class="keyword">let</span> pr = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> () &#123;</span><br><span class="line">    resolve() <span class="comment">// pending -&gt; resolved</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject() <span class="comment">// pending -&gt; rejected</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>Promise实例生成后可以使用then方法指定两种状态下的回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二个函数可选</span></span><br><span class="line">pr.then( <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// throw error</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>so…<br>封装一个函数，返回一个Promise对象，在Promise实例创建时传入的函数参数内进行逻辑处理（决定何时改变状态并传递值到回调函数）<br>利用Promise实例的then方法接收上一步的传递值处理后续（resolve传递的值可以为Promise对象，reject传递的值多为Error对象）</p><ul><li>注意：resolve或reject并不会终结 Promise 的参数函数的执行，因为立即resolve或reject的Promise是在本次时间循环尾部，晚于本轮的同步任务</li><li>注意：一般resolve或者reject之后Promise任务完成了，后续应该写在then的回调函数内，所以可以这样<code>return resolve(value)</code></li></ul></li></ul><h3 id="我愚蠢的孩子们"><a href="#我愚蠢的孩子们" class="headerlink" title="我愚蠢的孩子们"></a>我愚蠢的孩子们</h3><h4 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then"></a>Promise.prototype.then</h4><ul><li><p>参数：两个函数，后一个可选</p></li><li><p>返回：新的Promise实例<br>可以采用链式写法，上一个回调函数的返回值会作为参数传递到下一个回调函数内<br>若上一个回调函数返回的是Promise则需要等状态改变再调用下一个回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">"/post/1.json"</span>).then(</span><br><span class="line">  <span class="comment">// 返回的是一个Promise，其状态改变后根据状态选择调用下面的then中的哪个回调函数</span></span><br><span class="line">  post =&gt; getJSON(post.commentURL)</span><br><span class="line">).then(</span><br><span class="line">  comments =&gt; <span class="built_in">console</span>.log(<span class="string">"resolved: "</span>, comments),</span><br><span class="line">  err =&gt; <span class="built_in">console</span>.log(<span class="string">"rejected: "</span>, err)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><h4 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch"></a>Promise.prototype.catch</h4><ul><li>实际上：是<code>.then(null, rejection)</code>的别名</li><li>链式写法最后一个catch可以捕获前面任何一个Promise对象then方法抛出的error</li><li>推荐使用catch，而不是两个回调函数作为参数</li><li>若没有指定错误处理的回调，Promise会吃掉错误，不会退出进程、终止脚本运行</li><li>catch方法里还可以再抛错，再链式catch…</li></ul><h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h4><ul><li>参数： 具有Iterator接口</li><li><p>返回： Promise实例们</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>p1, p2, p3都为fullfilled时p才fullfilled，其中一个rejected则p就rejected<br>如果其中一个Promise实例定义了catch，错误会被自己的catch捕获然后返回一个新的Promise实例，在执行完catch后该实例也resolved，所以不会被外部p的catch捕获到，若没有，当然会被外面捕获到啦</p></li></ul><h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h4><ul><li>概述：同样是多个Promise实例，第一个状态改变的Promise实例会使得p状态跟着改变</li><li>用处🌰：一定时间内获取不到就rejected<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([</span><br><span class="line">  fetch(<span class="string">'/resource-that-may-take-a-while'</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'request timeout'</span>)), <span class="number">5000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">]);</span><br><span class="line">p.then(<span class="function"><span class="params">response</span> =&gt;</span> <span class="built_in">console</span>.log(response));</span><br><span class="line">p.catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error));</span><br></pre></td></tr></table></figure></li></ul><h4 id="Promise-resolve-Promise-reject"><a href="#Promise-resolve-Promise-reject" class="headerlink" title="Promise.resolve/Promise.reject"></a>Promise.resolve/Promise.reject</h4><ul><li><p>嗯</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>)</span><br><span class="line"><span class="comment">// 等价于下面，即生成一个Promise实例，状态为resolved，且将值传给回调函数</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="string">'foo'</span>))</span><br></pre></td></tr></table></figure></li><li><p>情况</p><ul><li>参数为thenable对象，即具有then方法的对象 =&gt;<br>将对象封装为Promise对象，立即执行原对象的then方法，然后在根据状态变化去调用Promise.then的回调函数</li><li>不是thenable对象或者不是对象<br>参见<code>嗯</code></li><li>不传参数，返回一个resolved的Promise对象</li></ul></li><li><p>注意：立即resolve的Promise对象，是在本轮“事件循环”（event loop）的结束时，而不是在下一轮“事件循环”的开始时</p></li><li>注意：Promise.reject(res)有一点不同，在于参数res直接作为rejected的理由，原封不动地被catch</li></ul><h4 id="Promise-done-Promise-finally"><a href="#Promise-done-Promise-finally" class="headerlink" title="Promise.done/Promise.finally"></a>Promise.done/Promise.finally</h4><ul><li>前者表示无论如何都会接收到可能的错误，全局抛出，后者是无论如何都会在最后执行传入的callback<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// done</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.done = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.then(onFulfilled, onRejected)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 抛出一个全局错误</span></span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;, <span class="number">0</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// finally</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.finally = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> P = <span class="keyword">this</span>.constructor;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">    value  =&gt; P.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> value),</span><br><span class="line">    reason =&gt; P.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Promise-try"><a href="#Promise-try" class="headerlink" title="Promise.try"></a>Promise.try</h4><ul><li>提案：模拟try，是异步就异步，是同步就同步，就提提，再说</li></ul><h2 id="lesson2-Generator"><a href="#lesson2-Generator" class="headerlink" title="lesson2 Generator"></a>lesson2 Generator</h2><h3 id="初探"><a href="#初探" class="headerlink" title="初探"></a>初探</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li>一个遍历器生成函数，一个状态机</li><li>调用Generator函数，返回一个遍历器，代表Generator函数的内部指针（此时yield后的表达式不会求值）</li><li>每次调用next方法会执行下一个yield前的语句并且返回一个{value, done}对象，其中value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值，done属性是一个布尔值，表示是否遍历结束</li><li>若没有yield了，next执行到函数结束，并将return结果作为value返回，若无return则为undefined。</li><li>这之后调用next将返回{value: undefined, done: true}</li></ul><h4 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h4><ul><li><p>惰性<br>调用next方法时，将yield后的表达式的值作为value返回，只有下次再调用next才会执行这之后的语句，达到了暂停执行的效果，相当于具备了一个惰性求值的功能</p></li><li><p>没有yield时，Generator函数为一个单纯的暂缓执行函数（需要调用next执行）</p></li><li>yield只能用于Generator函数</li></ul><h4 id="Iterator接口"><a href="#Iterator接口" class="headerlink" title="Iterator接口"></a>Iterator接口</h4><ul><li>Generator函数为遍历器生成函数，可以赋给对象的Symbol.iterator方法，本身也具有Symbol.iterator属性<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line">g[<span class="built_in">Symbol</span>.iterator]() === g</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h4><ul><li>Generator函数返回的是遍历器对象，可以直接用for…of访问</li><li>注意：done为true的会被for…of忽略</li><li>利用Generator为对象实现Iterator接口<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">objectEntries</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> propKeys = <span class="built_in">Object</span>.keys(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> propKey <span class="keyword">of</span> propKeys) &#123;</span><br><span class="line">    <span class="keyword">yield</span> [propKey, <span class="keyword">this</span>[propKey]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> jane = &#123; <span class="attr">first</span>: <span class="string">'Jane'</span>, <span class="attr">last</span>: <span class="string">'Doe'</span> &#125;;</span><br><span class="line">jane[<span class="built_in">Symbol</span>.iterator] = objectEntries;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> jane) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first: Jane</span></span><br><span class="line"><span class="comment">// last: Doe</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="Generator-prototype-next"><a href="#Generator-prototype-next" class="headerlink" title="Generator.prototype.next()"></a><code>Generator.prototype.next()</code></h4><ul><li>参数<br>通过传入参数为Generator函数内部注入不同的值来调整函数接下来的行为<br>第一次next传递的参数会被忽略（实在想传得包一层）<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里利用参数实现了重置</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; <span class="literal">true</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> reset = <span class="keyword">yield</span> i;</span><br><span class="line">    <span class="keyword">if</span>(reset) &#123; i = <span class="number">-1</span>; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = f();</span><br><span class="line">g.next() <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br><span class="line">g.next() <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="comment">// 传递的参数会被赋值给i（yield后的表达式的值(i)），然后执行var reset = i赋值给reset</span></span><br><span class="line">g.next(<span class="literal">true</span>) <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="Generator-prototype-throw"><a href="#Generator-prototype-throw" class="headerlink" title="Generator.prototype.throw()"></a><code>Generator.prototype.throw()</code></h4><ul><li>Generator函数返回的对象都具有throw方法，用于在函数体外抛出错误，在函数体内可以捕获（只能catch一次）</li><li>参数可以为Error对象</li><li>如果函数体内没有部署try…catch代码块，那么throw抛出的错会被外部try…catch代码块捕获，如果外部也没有，则程序报错，中断执行</li><li>throw方法被内部catch以后附带执行一次next</li><li>函数内部的error可以被外部catch</li><li>如果Generator执行过程中内部抛错，且没被内部catch，则不会再执行下去了，下次调用next会视为该Generator已运行结束</li><li>Generator函数返回的对象在被next访问完后内部属性<code>[[GeneratorStatus]]</code>值变为’closed’了</li></ul><h4 id="Generator-prototype-return"><a href="#Generator-prototype-return" class="headerlink" title="Generator.prototype.return()"></a><code>Generator.prototype.return()</code></h4><ul><li><code>try ... finally</code>存在时，return会在finally执行完后执行，最后的返回结果是return方法的参数，这之后Generator运行结束，下次访问会得到{value: undefined, done: true}</li><li><code>try ... finally</code>不存在时，直接执行return，后续和上一条一致</li></ul><h4 id="实际上"><a href="#实际上" class="headerlink" title="实际上"></a>实际上</h4><ul><li>以上三种方法都是让Generator恢复执行，并用语句替换yield表达式</li></ul><h3 id="yield-表达式"><a href="#yield-表达式" class="headerlink" title="yield*表达式"></a><code>yield*</code>表达式</h3><ul><li><p>在一个Generator内部直接调用另一个Generator是没用的，如果需要在一个Generator内部yield另一个Generator对象的成员，则需要使用<code>yield*</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'a'</span></span><br><span class="line">  <span class="comment">// yield outer() // 返回一个遍历器对象</span></span><br><span class="line">  <span class="keyword">yield</span>* outer() <span class="comment">// 返回一个遍历器对象的内部值</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'d'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'b'</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'c'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> s = inner()</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125; <span class="comment">// a b c d</span></span><br></pre></td></tr></table></figure></li><li><p><code>yield*</code>后跟一个遍历器对象（所有实现了iterator的数据结构实际上都可以被<code>yield*</code>遍历）</p></li><li><p>被代理的Generator函数如果有return，return的值会被for…of忽略，所以next不会返回，但是实际上可以向外部Generetor内部返回一个值，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"foo"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> v = <span class="keyword">yield</span> *foo();</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">"v: "</span> + v );</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> it = bar();</span><br><span class="line">it.next()</span><br><span class="line"><span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">it.next()</span><br><span class="line"><span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line">it.next()</span><br><span class="line"><span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line">it.next();</span><br><span class="line"><span class="comment">// "v: foo"</span></span><br><span class="line"><span class="comment">// &#123;value: 4, done: false&#125;</span></span><br><span class="line">it.next()</span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>举个🌰</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理嵌套数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">Tree</span>(<span class="params">tree</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(tree))&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;tree.length;i++) &#123;</span><br><span class="line">      <span class="keyword">yield</span>* Tree(tree[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> tree</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> ss = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],<span class="number">6</span>,[<span class="number">7</span>]]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> Tree(ss)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125; <span class="comment">// 1 2 3 4 5 6 7</span></span><br><span class="line"><span class="comment">// 理解for ...of 实际上是一个while循环</span></span><br><span class="line"><span class="keyword">var</span> it = iterateJobs(jobs);</span><br><span class="line"><span class="keyword">var</span> res = it.next();</span><br><span class="line"><span class="keyword">while</span> (!res.done)&#123;</span><br><span class="line">  <span class="keyword">var</span> result = res.value;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  res = it.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><h4 id="作为对象的属性的Generator函数"><a href="#作为对象的属性的Generator函数" class="headerlink" title="作为对象的属性的Generator函数"></a>作为对象的属性的Generator函数</h4><ul><li>写法很清奇<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  * sss() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = =&#123;</span><br><span class="line">  sss: <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Generator函数的this"><a href="#Generator函数的this" class="headerlink" title="Generator函数的this"></a>Generator函数的this</h4><ul><li><p>Generator函数返回的是遍历器对象，会继承prototype的方法，但是由于返回的不是this，所以会出现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">ss</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f = ss()</span><br><span class="line">f.a <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li><li><p>想要在内部的this绑定遍历器对象？js灵活特性尽显…</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">ss</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="keyword">this</span>.b = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="keyword">this</span>.c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f = ss.call(ss.prototype) <span class="comment">// 由于f.__proto__ === ss.prototype，传入遍历器对象的隐藏原型给this</span></span><br><span class="line">f.next()</span><br><span class="line">f.next()</span><br><span class="line">f.a <span class="comment">// 1</span></span><br><span class="line">f.b <span class="comment">// 2</span></span><br><span class="line">f.c <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ul><li><p>举个🌰</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用暂停状态的特性</span></span><br><span class="line"><span class="keyword">let</span> clock = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'tick'</span>)</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'tock'</span>)</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>异步操作的同步化表达</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Generator函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">yield</span> request(<span class="string">"http://some.url"</span>);</span><br><span class="line">  <span class="keyword">var</span> resp = <span class="built_in">JSON</span>.parse(result);</span><br><span class="line">    <span class="built_in">console</span>.log(resp.value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ajax请求函数，回调函数中要将response传给next方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  makeAjaxCall(url, <span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">    it.next(response);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 需要第一次执行next方法，返回yield后的表达式，触发异步请求，跳到request函数中执行</span></span><br><span class="line"><span class="keyword">var</span> it = main();</span><br><span class="line">it.next();</span><br></pre></td></tr></table></figure></li><li><p>控制流管理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步steps</span></span><br><span class="line"><span class="keyword">let</span> steps = [step1Func, step2Func, step3Func];</span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">iterateSteps</span>(<span class="params">steps</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt; steps.length; i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> step = steps[i];</span><br><span class="line">    <span class="keyword">yield</span> step();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 异步后续讨论</span></span><br></pre></td></tr></table></figure></li><li><p>部署Iterator接口</p></li><li>看做数组结构使用</li></ul><h2 id="lesson3-Generator的异步应用"><a href="#lesson3-Generator的异步应用" class="headerlink" title="lesson3 Generator的异步应用"></a>lesson3 Generator的异步应用</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><ul><li>一个任务拆分成两个阶段，比如任务是读取一个文件并返回一个结果a。拆分为向操作系统发起请求，然后执行别的操作，再在操作系统返回文件以后去返回一个结果a。不连续的执行，称为异步</li></ul><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><ul><li>传统的异步实现是通过将第二阶段的操作以函数形式作为参数传递到任务处理方法内，在第一阶段的执行有了结果以后，回调函数才会执行</li><li>node约定，回调函数的第一个参数必须为错误对象，因为第一阶段执行完后，任务得上下文环境结束了。这之后抛出的错误需要传入回调函数才能被捕获处理</li><li>Promise其实只是写法上的区别，依然是以回调函数的方式实现异步</li></ul><h4 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h4><ul><li><p>协程coroutine<br>协程A执行-&gt;协程A暂停，执行权转交给协程B-&gt;一段时间后执行权交还A-&gt;A恢复执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// yield是异步两个阶段的分割线</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">asyncJob</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...其他代码</span></span><br><span class="line">  <span class="keyword">var</span> f = <span class="keyword">yield</span> readFile(fileA);</span><br><span class="line">  <span class="comment">// ...其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Generator函数实现协程<br>Generator函数实际上可以作为异步任务的容器，在异步任务需要暂停的地方加上yield注明即可</p></li><li><p>Generator函数的错误处理和数据交换<br>next方法使得Generator可以接收外部参数，next返回值的value属性是Generator向外的输出值（数据交换实现）<br>错误处理上一课有讲述</p></li></ul><h3 id="Thunk函数"><a href="#Thunk函数" class="headerlink" title="Thunk函数"></a>Thunk函数</h3><h4 id="参数的求值策略"><a href="#参数的求值策略" class="headerlink" title="参数的求值策略"></a>参数的求值策略</h4><ul><li>传名调用和传值调用之争</li><li>后者更简单，但是可能会有需要大量计算求值却没有用到这个参数的情况，造成性能损失</li></ul><h4 id="js中的Thunk函数"><a href="#js中的Thunk函数" class="headerlink" title="js中的Thunk函数"></a>js中的Thunk函数</h4><ul><li>传统的Thunk函数是传名调用的一种实现，即将参数作为一个临时函数的返回值，在需要用到参数的地方对临时函数进行求值</li><li><p>js中的Thunk函数略有不同<br>js中的Thunk函数是将多参数函数替换为单参数函数（这个参数为回调函数）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Thunk = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> fn.call(<span class="keyword">this</span>, ...args, callback);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看起来只是换了个样子，好像并没有什么用</p></li></ul><h4 id="Thunk函数实现Generator函数自动执行"><a href="#Thunk函数实现Generator函数自动执行" class="headerlink" title="Thunk函数实现Generator函数自动执行"></a>Thunk函数实现Generator函数自动执行</h4><ul><li><p>Generator函数自动执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> a <span class="comment">// 表达式a</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g = gen()</span><br><span class="line"><span class="keyword">let</span> res = g.next()</span><br><span class="line"><span class="keyword">while</span>(!res.done) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res.value)</span><br><span class="line">  res = g.next() <span class="comment">// 表达式b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>但是，这不适合异步操作。如果必须保证前一步执行完，才能执行后一步，上面的自动执行就不可行。<br><del>上面这句话是不是可以这样理解，比如表达式a是一个异步操作，回调函数中设置了延时执行，而这个回调函数执行前表达式b可能已经被执行了，进入到下一个循环。所以无法保证执行顺序，所以需要管理回调函数</del><br>next方法是同步的，执行时必须立刻返回值，yield后是同步操作当然没问题，是异步操作时就不可以了。处理方式就是返回一个Thunk函数或者Promise对象。此时value值为该函数/对象，done值还是按规矩办事。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"><span class="keyword">var</span> r1 = g.next();</span><br><span class="line"><span class="comment">// 重复传入一个回调函数</span></span><br><span class="line">r1.value(<span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="keyword">var</span> r2 = g.next(data);</span><br><span class="line">  r2.value(<span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    g.next(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></blockquote></li><li><p>Thunk函数的自动流程管理<br>思路：Generator函数中yield 异步Thunk函数，通过yield将控制权转交给Thunk函数，然后在Thunk函数的回调函数中调用Generator的next方法，将控制权交回给Generator。此时，异步操作确保完成，开启下一个任务。<br>Generator是一个异步操作的容器，实现自动执行需要一个机制，这个机制的关键是控制权的交替，在异步操作有了结果以后自动交回控制权，而回调函数执行正是这么个时间点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Generator函数的执行器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> gen = fn()</span><br><span class="line">  <span class="comment">// 传给Thunk函数的回调函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">cb</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 控制权交给Generator，获取下一个yield表达式（异步任务）</span></span><br><span class="line">    <span class="keyword">let</span> result = gen.next(data)</span><br><span class="line">    <span class="comment">// 没任务了，返回</span></span><br><span class="line">    <span class="keyword">if</span> (result.done) <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// 控制权交给Thunk函数，传入回调</span></span><br><span class="line">    result.value(cb)</span><br><span class="line">  &#125;</span><br><span class="line">  cb()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Generator函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> f1 = <span class="keyword">yield</span> readFileThunk(<span class="string">'/a'</span>)</span><br><span class="line">  <span class="keyword">let</span> f2 = <span class="keyword">yield</span> readFileThunk(<span class="string">'/b'</span>)</span><br><span class="line">  <span class="keyword">let</span> f3 = <span class="keyword">yield</span> readFileThunk(<span class="string">'/c'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Thunk函数readFileThunk</span></span><br><span class="line"><span class="keyword">const</span> Thunk = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> fn.call(<span class="keyword">this</span>, ...args, callback);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> readFileThunk = Thunk(fs.readFile);</span><br><span class="line">readFileThunk(fileA)(callback);</span><br><span class="line"><span class="comment">// 自动执行</span></span><br><span class="line">run(g)</span><br></pre></td></tr></table></figure></li></ul><h3 id="co模块"><a href="#co模块" class="headerlink" title="co模块"></a>co模块</h3><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul><li>不用手写上述的执行器，co模块其实就是将基于Thunk函数和Promise对象的两种自动Generator执行器包装成一个模块</li><li>使用条件：yield后只能为Thunk函数或Promise对象或Promise对象数组</li></ul><h4 id="基于Promise的执行器"><a href="#基于Promise的执行器" class="headerlink" title="基于Promise的执行器"></a>基于Promise的执行器</h4><ul><li>实现<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> gen = fn()</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">cb</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 将上一个任务返回的data作为参数传给next方法，控制权交回到Generator</span></span><br><span class="line">    <span class="comment">//这里将result变量引用&#123;value, done&#125;对象，不要和Generator中的`let result = yield xxx`搞混</span></span><br><span class="line">    <span class="keyword">let</span> result = gen.next(data)</span><br><span class="line">    <span class="keyword">if</span> (result.done) <span class="keyword">return</span> result.value</span><br><span class="line">    result.value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">      <span class="comment">// resolved之后会执行cb(data)，开启下一次循环，实现自动执行</span></span><br><span class="line">      cb(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  cb()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><ul><li><p>其实和上面的实现类似</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> args = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>) <span class="comment">// 除第一个参数外的所有参数</span></span><br><span class="line">  <span class="comment">// 返回一个Promise对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果是Generator函数，执行获取遍历器对象gen</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> gen === <span class="string">'function'</span>) gen = gen.apply(ctx, args);</span><br><span class="line">    <span class="keyword">if</span> (!gen || <span class="keyword">typeof</span> gen.next !== <span class="string">'function'</span>) <span class="keyword">return</span> resolve(gen);</span><br><span class="line">    <span class="comment">// 第一次执行遍历器对象gen的next方法获取第一个任务</span></span><br><span class="line">    onFulfilled();</span><br><span class="line">    <span class="comment">// 每次异步任务执行完，resolved以后会调用，控制权又交还给Generator</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onFulfilled</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> ret;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        ret = gen.next(res); <span class="comment">// 获取&#123;value,done&#125;对象，控制权在这里暂时交给异步任务，执行yield后的异步任务</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">      next(ret); <span class="comment">// 进入next方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 同理可得</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> ret;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        ret = gen.throw(err);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">      next(ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关键</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">ret</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 遍历执行完异步任务后，置为resolved，并将最后value值返回</span></span><br><span class="line">      <span class="keyword">if</span> (ret.done) <span class="keyword">return</span> resolve(ret.value);</span><br><span class="line">      <span class="comment">// 获取下一个异步任务，并转为Promise对象</span></span><br><span class="line">      <span class="keyword">var</span> value = toPromise.call(ctx, ret.value);</span><br><span class="line">      <span class="comment">// 异步任务结束后会调用onFulfilled方法（在这里为yield后的异步任务设置then的回调参数）</span></span><br><span class="line">      <span class="keyword">if</span> (value &amp;&amp; isPromise(value)) <span class="keyword">return</span> value.then(onFulfilled, onRejected);</span><br><span class="line">      <span class="keyword">return</span> onRejected(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'You may only yield a function, promise, generator, array, or object, '</span></span><br><span class="line">        + <span class="string">'but the following object was passed: "'</span> + <span class="built_in">String</span>(ret.value) + <span class="string">'"'</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实还是一样，为Promise对象then方法指定回调函数，在异步任务完成后出发回调函数，在回调函数中执行Generator的next方法，进入下一个异步任务，实现自动执行。<br>举个🌰</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> co =<span class="built_in">require</span>(<span class="string">'co'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    fs.readFile(filename, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, res</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(err);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> resolve(res);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">co(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">yield</span> read(<span class="string">'./a.js'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>处理并发的异步操作<br>把并发操作放数组/对象中放yield后面</p></li></ul><h2 id="lesson4-async函数"><a href="#lesson4-async函数" class="headerlink" title="lesson4 async函数"></a>lesson4 async函数</h2><h3 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h3><ul><li><p>比较</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">asyncReadFile</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> asyncReadFile = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">await</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">await</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看起来只是写法的替换，实际上有这样的区别</p><ul><li>async函数内置执行器，不需要手动执行next方法，不需要引入co模块</li><li>async适用更广，co模块对yield后的内容严格限制为Thunk函数或Promise对象，而await后可以是Promise对象或原始类型值</li><li>返回Promise，这点和co比较像</li></ul></li><li><p>用法</p><ul><li>async标识该函数内部有异步操作</li><li>由于async函数返回的是Promise，所以可以将async函数作为await命令的参数</li><li>async函数可以使用在函数、方法适用的许多场景</li></ul></li></ul><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="返回的Promise"><a href="#返回的Promise" class="headerlink" title="返回的Promise"></a>返回的Promise</h4><ul><li>async函数只有在所有await后的Promise执行完以后才会改变返回的Promise对象的状态（return或者抛错除外）即只有在内部操作完成以后才会执行then方法</li><li>async函数内部return的值会作为返回的Promise的then方法回调函数的参数</li><li>async函数内部抛出的错误会使得返回的Promise变成rejected状态，同时错误会被catch捕获</li></ul><h4 id="async命令及其后的Promise"><a href="#async命令及其后的Promise" class="headerlink" title="async命令及其后的Promise"></a>async命令及其后的Promise</h4><ul><li>async命令后如果不是一个Promise对象，则会被转成一个resolved的Promise</li><li>async命令后的Promise如果抛错了变成rejected状态或者直接rejected了，都会使得async函数的执行中断，错误可以被then方法的回调函数catch到</li><li>如果希望async的一个await Promise不影响到其他的await Promise，可以将这个await Promise放到一个try…catch代码块中，这样后面的依然会正常执行，也可以将多个await Promise放在一个try…catch代码块中，此外还可以加上错误重试</li></ul><h4 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h4><ul><li><p>相互独立的异步任务可以改造下让其并发执行（Promise.all）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo, bar] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([getFoo(), getBar()]);</span><br><span class="line"><span class="comment">// 听说下面这种也可以？</span></span><br><span class="line"><span class="keyword">let</span> fooPromise = getFoo();</span><br><span class="line"><span class="keyword">let</span> barPromise = getBar();</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> fooPromise;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> barPromise;</span><br></pre></td></tr></table></figure></li><li><p>forEach</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">forEach(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> m = <span class="keyword">await</span> pro</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这种写法可能不能正常工作，因为forEach时的若干个操作是并行的，应改为for循环</p></li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul><li>其实就是将执行器和Generator函数封装在一起，详见上一课</li></ul><h3 id="举举🌰"><a href="#举举🌰" class="headerlink" title="举举🌰"></a>举举🌰</h3><ul><li>并发请求，顺序输出<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">logInOrder</span>(<span class="params">urls</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 并发读取远程URL</span></span><br><span class="line">  <span class="keyword">const</span> textPromises = urls.map(<span class="keyword">async</span> url =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(url);</span><br><span class="line">    <span class="keyword">return</span> response.text();</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 按次序输出</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> textPromise <span class="keyword">of</span> textPromises) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> textPromise);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="异步遍历器"><a href="#异步遍历器" class="headerlink" title="异步遍历器"></a>异步遍历器</h3><h4 id="回到过去"><a href="#回到过去" class="headerlink" title="回到过去"></a>回到过去</h4><ul><li>Generator的next方法是同步的，需要立即返回结果，所以在处理异步操作时我们返回的实际上是{value: Promise, done: false}类似这样的对象。理解没错的话Promise对象创建时传入的函数会立即执行，异步操作例如读取文件请求就开始了。而后我们为这个Promise对象指定then方法的参数回调函数去接收异步操作完成的信号，然后在回调函数中再次调用next获取下一个{value: Promise, done: false}</li><li>提案：为异步操作提供原生的遍历器接口，使得value和done值都可以异步返回，称为异步遍历器</li></ul><h4 id="more"><a href="#more" class="headerlink" title="more"></a>more</h4><ul><li>累了，困了，不开心看了，下次再补充</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;承上一篇，本文记录了es6的Promise对象、Generator函数和async await语法糖，异步真是让人又爱又恨。&lt;br&gt;
    
    </summary>
    
      <category term="code" scheme="http://derekz.cn/categories/code/"/>
    
    
      <category term="js" scheme="http://derekz.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js-es6 新特性篇</title>
    <link href="http://derekz.cn/posts/f1e10a9/"/>
    <id>http://derekz.cn/posts/f1e10a9/</id>
    <published>2017-11-06T06:12:52.000Z</published>
    <updated>2018-06-06T03:50:26.472Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;承上一篇，本笔记包含es6的一些新东西，如Reflect，Proxy，Iterator，Symbol等。<br><a id="more"></a></p><h2 id="lesson1-Symbol"><a href="#lesson1-Symbol" class="headerlink" title="lesson1 Symbol"></a>lesson1 Symbol</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li><p>javaScript第七种原始数据类型Symbol<br><code>let s = Symbol(&#39;foo&#39;)</code><br>通过Symbol函数生成，每个Symbol类型的变量值都独一无二，作为一种类似于字符串的数据结构，可以避免变量名冲突<br>Symbol函数接收一个参数用于描述该Symbol实例，不影响生成的Symbol实例的值<br>Symbol值不能与其他类型进行运算（模板字符串中也不可以），可以显示转为字符串和布尔值（String(), Boolean()）</p></li><li><p>Symbol作为属性名</p><ul><li>不能用<code>.</code>，因为<code>.</code>是去取字符串对应属性名</li><li>在对象中使用作为属性名时，需使用<code>[s]</code>否则也会被当做字符串</li></ul></li><li><p><code>Symbol.for</code>, <code>Symbol.keyFor</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s1) <span class="comment">// "foo"</span></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>); <span class="comment">// 先搜索全局，已存在该key则返回已存在的</span></span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s2) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="内置Symbol值"><a href="#内置Symbol值" class="headerlink" title="内置Symbol值"></a>内置Symbol值</h3><ul><li><p><code>Symbol.hasInstance</code><br>对象的<code>Symbol.hasInstance</code>属性指向一个内部方法，其他对象使用instanceOf判断实例时，会调用这个内部方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Even</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> [<span class="built_in">Symbol</span>.hasInstance](obj) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Number</span>(obj) % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span> instanceOf Even</span><br></pre></td></tr></table></figure></li><li><p><code>Symbol.isConcatSpreadable</code><br>表示该对象用于Array.prototype.concat()时是否可以展开，数组默认可展开，默认值为undefined，对象默认不可展开</p></li><li><p><code>Symbol.species</code><br>指向当前对象的构造函数，创造实例时会调用这个方法，即使用该属性返回的函数作为构造函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> get [<span class="built_in">Symbol</span>.species]() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>Symbol.match</code>, <code>Symbol.replace</code>, <code>Symbol.split</code>, <code>Symbol.search</code></p></li><li><code>Symbol.iterator</code><br>指向该对象的默认遍历器方法<br>对象进行for…of循环时，会调用Symbol.iterator方法，返回该对象的默认遍历器<br>详见后续章节</li><li><code>Symbol.toPrimitive</code></li><li><code>Symbol.toStringTag</code><br>指向一个方法，在该对象上调用<code>Object.prototype.toString()</code>时，如果该属性存在，则他的返回值会出现在toString方法返回的字符串之中，比如[Object Array]<br>新增内置对象举个例子：<code>JSON[Symbol.toStringTag]：&#39;JSON&#39;</code></li></ul><h2 id="lesson2-Set和Map"><a href="#lesson2-Set和Map" class="headerlink" title="lesson2 Set和Map"></a>lesson2 Set和Map</h2><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h4><ul><li><p>Set构造函数生成，成员值唯一，(判断与===区别在于NaN)，两个空对象视为不同</p></li><li><p>实例属性和方法</p><ul><li>属性： <code>Set.prototype.constructor</code>, <code>Set.prototype.size</code></li><li>方法： <code>add(value)</code>, <code>delete(value)</code>, <code>has(value)</code>, <code>clear()</code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from可以将<span class="built_in">Set</span>转为数组</span><br><span class="line"><span class="comment">// 数组去重</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dedupe</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(array));</span><br><span class="line">  <span class="comment">// return [...new Set(array)]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>遍历</p><ul><li>keys(), values(), entries(), forEach() 方法</li><li>遍历顺序为插入顺序，或可用于设置指定顺序的回调函数</li><li>Set的键名键值相同</li><li>Set默认可遍历，默认遍历器生成函数是values方法，这意味着，可以省略values方法，直接用for…of循环遍历 Set<br><code>Set.prototype[Symbol.iterator] === Set.prototype.values</code></li><li><code>...</code>内部使用<code>for ... of</code>，故可以使用<code>[...Set]</code>，转为数组后可以方便使用数组方法如map和filter</li></ul></li></ul><h4 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h4><ul><li>成员只能为对象</li><li>弱引用，垃圾回收机制对对象引用计数时不考虑WeakSet中对对象的引用</li><li><code>new WeakSet()</code> 可以接收任何具有 <code>Iterable</code> 接口的对象作为参数，但必须注意加入<code>WeakSet</code>的成员必须为对象</li><li>WeakSet有以下三个方法：<code>add(value)</code>, <code>delete(value)</code>, <code>has(value)</code>，没有size属性，不可遍历（没有forEach和clear方法）</li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="基本-1"><a href="#基本-1" class="headerlink" title="基本"></a>基本</h4><ul><li>键值对的集合（Hash结构），键和对象不一样，不局限于字符串。</li><li>任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构都可以作为Map构造函数的参数</li><li><p>只有对同一个对象的引用或者严格相等的简单类型（包括NaN）才会生成一样的Map</p></li><li><p>实例属性和方法</p><ul><li>属性： <code>Map.prototype.constructor</code>, <code>Map.prototype.size</code></li><li>方法： <code>set()</code>, <code>get()</code>, <code>delete(value)</code>, <code>has(value)</code>, <code>clear()</code></li></ul></li><li><p>遍历</p><ul><li>类似上述Set的遍历</li><li>Map 结构的默认遍历器接口（Symbol.iterator属性），就是entries方法</li></ul></li></ul><h4 id="与其他数据结构转换"><a href="#与其他数据结构转换" class="headerlink" title="与其他数据结构转换"></a>与其他数据结构转换</h4><ul><li>数组，对象，JSON互转<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strMapToObj</span>(<span class="params">strMap</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> [k,v] <span class="keyword">of</span> strMap) &#123;</span><br><span class="line">    obj[k] = v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h4><ul><li>键名只能为对象</li><li>WeakMap的键名所指向的对象，不计入垃圾回收机制</li><li>WeakMap有以下三个方法：<code>get</code>, <code>set</code>, <code>delete(value)</code>, <code>has(value)</code>，没有size属性，不可遍历（没有forEach和clear方法）</li></ul><p><img src="http://opo02jcsr.bkt.clouddn.com/a3ca4dc0aad89c377838dcf51642e109.jpg" alt=""></p><h2 id="lesson3-Proxy"><a href="#lesson3-Proxy" class="headerlink" title="lesson3 Proxy"></a>lesson3 Proxy</h2><h3 id="观察"><a href="#观察" class="headerlink" title="观察"></a>观察</h3><ul><li><p>举个栗子<br>当你为对象a赋值a.b=c时，你希望在b属性赋值时有一个范围大小的校验，超出范围抛错，这个时候我们可能会想到重载set方法,比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(a, <span class="string">'b'</span>, &#123;</span><br><span class="line">  set(x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x&gt;<span class="number">100</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RangeError</span>(<span class="string">'invalid range'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.b = x</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>动手以后发现一个问题…这样会栈溢出，因为在set内再set了b的值，无限循环…变通一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(a, <span class="string">'b'</span>, &#123;</span><br><span class="line">  get(x) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.c</span><br><span class="line">  &#125;</span><br><span class="line">  set(x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x&gt;<span class="number">100</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RangeError</span>(<span class="string">'invalid range'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.c = x</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然而总要这么写感觉很麻烦，而且如果是对一类属性进行操作时，重复写很没必要，换用Proxy写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">  set(obj, prop, value, receiver) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">'b'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (value&gt;<span class="number">100</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RangeError</span>(<span class="string">'invalid range'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    obj[prop] = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(a, handler)</span><br></pre></td></tr></table></figure><p>看起来也舒服多了，而且可以根据属性名在set方法内做判断，更可扩展</p></li></ul><h3 id="庖丁解牛"><a href="#庖丁解牛" class="headerlink" title="庖丁解牛"></a>庖丁解牛</h3><ul><li><p>代理proxy</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> handler = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="comment">// 将代理的所有内部方法转发至目标</span></span><br><span class="line">proxy.a = <span class="number">1</span> =&gt; target.a = <span class="number">1</span>;</span><br><span class="line">target.b = <span class="number">4</span> =&gt; proxy.b = <span class="number">4</span>;</span><br><span class="line">target !== proxy</span><br><span class="line">target.__proto__ === proxy.__proto__</span><br><span class="line"><span class="comment">// 应在代理对象上操作，代理才能生效</span></span><br><span class="line">handler = &#123;get()&#123;<span class="keyword">return</span> <span class="number">12</span>&#125;&#125;</span><br><span class="line">target.v <span class="comment">// undefined</span></span><br><span class="line">proxy.v <span class="comment">// 12</span></span><br></pre></td></tr></table></figure></li><li><p>Proxy支持的拦截操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">get(target, propKey, receiver) <span class="comment">// proxy.foo, proxy['foo']</span></span><br><span class="line">set(target, propKey, value, receiver) <span class="comment">//proxy.foo = v, proxy['foo'] = v</span></span><br><span class="line">has(target, propKey) <span class="comment">// propKey in proxy</span></span><br><span class="line">deleteProperty(target, propKey) <span class="comment">// delete proxy[propKey]</span></span><br><span class="line">ownKeys(target) <span class="comment">// Object.getOwnPropertyNames(proxy), Object.getOwnPropertySymbols(proxy), Object.keys(proxy)</span></span><br><span class="line">getOwnPropertyDescriptor(target, propKey) <span class="comment">// Object.getOwnPropertyDescriptor(proxy, propKey)</span></span><br><span class="line">defineProperty(target, propKey, propDesc) <span class="comment">// Object.defineProperty(proxy, propKey, propDesc), Object.defineProperties(proxy, propDescs)</span></span><br><span class="line">preventExtensions(target) <span class="comment">// Object.preventExtensions(proxy)</span></span><br><span class="line">getPrototypeOf(target) <span class="comment">// Object.getPrototypeOf(proxy)</span></span><br><span class="line">isExtensible(target) <span class="comment">// Object.isExtensible(proxy)</span></span><br><span class="line">setPrototypeOf(target, proto) <span class="comment">// Object.setPrototypeOf(proxy, proto)</span></span><br><span class="line">apply(target, object, args) <span class="comment">// 拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)</span></span><br><span class="line">construct(target, args) <span class="comment">// new proxy(...args)</span></span><br></pre></td></tr></table></figure></li><li><p>代理句柄handler<br>句柄对象的方法可以复写代理的内部方法，具体为上述的14种。</p><ul><li><p>举个🌰</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Tree</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, handler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span> (<span class="params">target, key, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> target)) &#123;</span><br><span class="line">      target[key] = Tree();  <span class="comment">// 自动创建一个子树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> tree = <span class="keyword">new</span> Tree()</span><br><span class="line">tree.branch1.branch2.twig = <span class="string">"green"</span></span><br></pre></td></tr></table></figure></li><li><p>再来个🌰</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现对in操作符隐藏属性</span></span><br><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  has (target, key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">'_'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> key <span class="keyword">in</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">_prop</span>: <span class="string">'foo'</span>, <span class="attr">prop</span>: <span class="string">'foo'</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="string">'_prop'</span> <span class="keyword">in</span> proxy <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><p>特别注意<br>如果目标对象不可扩展或者目标对象的属性不可写或者不可配置时，代理不能生效，可能会报错<br>需注意一些特定的方法对返回值有要求，不如重写isExtensible方法时，返回值与目标对象的isExtensible属性应一致，否则会报错<br>利用代理重写可以做很多事情比如隐藏属性、对某些属性、操作符屏蔽、拦截内在方法并且加上自己想要的逻辑处理去得到预期结果等</p></li></ul></li></ul><h3 id="饭后甜点"><a href="#饭后甜点" class="headerlink" title="饭后甜点"></a>饭后甜点</h3><ul><li><p>Proxy.revocable<br>返回一个对象，proxy属性对应Proxy实例，revoke属性为revoke方法可以取消Proxy实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;proxy, revoke&#125; = <span class="built_in">Proxy</span>.revocable(target, handler);</span><br><span class="line">proxy.foo = <span class="number">1</span></span><br><span class="line">revoke()</span><br><span class="line">proxy.foo <span class="comment">// TypeError: Revoked</span></span><br></pre></td></tr></table></figure></li><li><p>this问题</p><ul><li>代理以后目标对象内部的this指向的是Proxy实例而不是目标对象</li><li><p>有时候可能因为this指向问题导致代理达不到预期效果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jane的name属性实际存储在外部的WeakMap对象的_name上，导致后续取不到值</span></span><br><span class="line"><span class="keyword">const</span> _name = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    _name.set(<span class="keyword">this</span>, name);</span><br><span class="line">  &#125;</span><br><span class="line">  get name() &#123;</span><br><span class="line">    <span class="keyword">return</span> _name.get(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> jane = <span class="keyword">new</span> Person(<span class="string">'Jane'</span>);</span><br><span class="line">jane.name <span class="comment">// 'Jane'</span></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(jane, &#123;&#125;);</span><br><span class="line">proxy.name <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li><li><p>某些原生对象的部分属性需要this指向原生对象时才能获取，如Date.getDate()，此时proxy get时需要注意this绑定原始对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2015-01-01'</span>);</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  get(target, prop) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">'getDate'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> target.getDate.bind(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, prop);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line">proxy.getDate() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><ul><li>TO BE CONTINUED!</li></ul><h2 id="lesson4-Reflect"><a href="#lesson4-Reflect" class="headerlink" title="lesson4 Reflect"></a>lesson4 Reflect</h2><h3 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h3><ul><li>Reflect对象与Proxy对象一样，是为了操作对象而提供的新API，存在的原因如下：<ul><li>将Object对象的一些内部方法添加到Reflect对象上，且以后的新方法都部署到Reflect对象上，完成分离</li><li>让对象操作变成函数行为</li><li>修改Object对象一些内部方法在出错时的返回</li><li>Proxy覆写对象方法时，提供一个Reflect对象用来获取原始方法，以设置默认值，再此基础上再做功能添加和修改</li></ul></li></ul><h3 id="揭面"><a href="#揭面" class="headerlink" title="揭面"></a>揭面</h3><ul><li><p>静态方法<br>对应于Proxy可覆写的方法，有13个静态方法</p></li><li><p>注意</p><ul><li><p>Proxy和Reflect联用的时候要小心，可能一个拦截会触发另一个拦截</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = &#123;</span><br><span class="line">  a: <span class="string">'a'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">  set(target, key, value, receiver) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'set'</span>);</span><br><span class="line">    <span class="built_in">Reflect</span>.set(target, key, value, receiver)</span><br><span class="line">  &#125;,</span><br><span class="line">  defineProperty(target, key, attribute) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'defineProperty'</span>);</span><br><span class="line">    <span class="built_in">Reflect</span>.defineProperty(target, key, attribute);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(p, handler);</span><br><span class="line">obj.a = <span class="string">'A'</span>;</span><br><span class="line"><span class="comment">// set</span></span><br><span class="line"><span class="comment">// defineProperty</span></span><br></pre></td></tr></table></figure><p>在Reflect.set传入receiver的时候触发了Proxy.defineProperty，不传入receiver时不会触发defineProperty拦截</p></li><li><p>对于参数的要求、转换和报错处理</p></li></ul></li></ul><h3 id="🌰"><a href="#🌰" class="headerlink" title="🌰"></a>🌰</h3><ul><li>使用Proxy实现观察者模式<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = observable(&#123;</span><br><span class="line">  name: <span class="string">'张三'</span>,</span><br><span class="line">  age: <span class="number">20</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;person.name&#125;</span>, <span class="subst">$&#123;person.age&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">observe(print);</span><br><span class="line">person.name = <span class="string">'李四'</span>;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// 李四, 20</span></span><br><span class="line"><span class="comment">/**************************/</span></span><br><span class="line"><span class="keyword">const</span> queuedObservers = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="keyword">const</span> observe = <span class="function"><span class="params">fn</span> =&gt;</span> queuedObservers.add(fn);</span><br><span class="line"><span class="keyword">const</span> observable = <span class="function"><span class="params">obj</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;set&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params">target, key, value, receiver</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">  queuedObservers.forEach(<span class="function"><span class="params">observer</span> =&gt;</span> observer());</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="lesson5-遍历器Iterator"><a href="#lesson5-遍历器Iterator" class="headerlink" title="lesson5 遍历器Iterator"></a>lesson5 遍历器Iterator</h2><h3 id="遇见"><a href="#遇见" class="headerlink" title="遇见"></a>遇见</h3><ul><li><p>why Iterator<br>js中数据集合的概念越来越多，如果能有一种统一的访问方式将是极好的。Iterator的设计就基于此，通过为相应数据结构部署iterator接口让该数据结构可通过统一的方式:for…of遍历</p></li><li><p>遍历过程：</p><ul><li>创建一个指针对象指向当前数据结构的初始位置（遍历器对象实际为一个指针对象）</li><li>调用指针对象的next方法，直到指向数据结构的结束位置<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历器生成函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeIterator</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> nextIndex &lt; array.length ?</span><br><span class="line">        &#123;<span class="attr">value</span>: array[nextIndex++]&#125; :</span><br><span class="line">        &#123;<span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>一种数据结构，只要部署了Iterator接口，就视为可遍历的</p></li></ul><h3 id="相识"><a href="#相识" class="headerlink" title="相识"></a>相识</h3><h4 id="默认Iterator接口"><a href="#默认Iterator接口" class="headerlink" title="默认Iterator接口"></a>默认Iterator接口</h4><ul><li>默认的Iterator接口部署在[Symbol.iterator]属性上，<code>Symbol.iterator</code>属性键为Symbol对象，值为一个函数，即遍历器生成函数，执行该函数会返回一个遍历器对象，该对象具有一个next方法，调用该方法可以返回{value, done}对象，代表了当前成员的信息</li><li>部分数据结构如Array、Set、Map、String等已经部署了Iterator接口，对象则需要手动添加这样的方法实现Iterator接口</li><li>对于非线性数据结构，Iterator接口实际上就是一种线性转换，下例为class实现遍历器<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RangeIterator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(start, stop) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = start;</span><br><span class="line">    <span class="keyword">this</span>.stop = stop;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line">  next() &#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="keyword">this</span>.value;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.stop) &#123;</span><br><span class="line">      <span class="keyword">this</span>.value++;</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: value&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">range</span>(<span class="params">start, stop</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RangeIterator(start, stop);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> range(<span class="number">0</span>, <span class="number">3</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// 0, 1, 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="举个🌰"><a href="#举个🌰" class="headerlink" title="举个🌰"></a>举个🌰</h4><ul><li><p>实现指针</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.value = value;</span><br><span class="line">  <span class="keyword">this</span>.next = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// for...of时会调用改遍历器生成函数</span></span><br><span class="line">Node.prototype[<span class="built_in">Symbol</span>.iterator]= <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回的遍历器对象</span></span><br><span class="line">  <span class="keyword">var</span> iterator = &#123;</span><br><span class="line">    next: next</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当前成员</span></span><br><span class="line">  <span class="keyword">var</span> current = <span class="keyword">this</span></span><br><span class="line">  next() &#123;</span><br><span class="line">    <span class="keyword">if</span>(current) &#123;</span><br><span class="line">      <span class="keyword">var</span> value = current.value;</span><br><span class="line">      <span class="comment">// 移动指针</span></span><br><span class="line">      current = current.next;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: value &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> iterator</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 新建对象，因为在原型上实现的遍历器生成函数，所以每个实例都实现了遍历器接口</span></span><br><span class="line"><span class="keyword">var</span> one = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> two = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> three = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 当前成员的next指向下一个成员，在next方法中实现指针移动</span></span><br><span class="line">one.next = two;</span><br><span class="line">two.next = three;</span><br><span class="line"><span class="comment">// 对对象使用for...of时，去查找[Symbol.iterator]属性，找到后循环调用next方法，直到返回值得done属性为true</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">of</span> one)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// 1, 2, 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果<code>Symbol.iterator</code>方法对应的不是遍历器生成函数，则会报错</p></li></ul><h3 id="在何方"><a href="#在何方" class="headerlink" title="在何方"></a>在何方</h3><h4 id="调用场合"><a href="#调用场合" class="headerlink" title="调用场合"></a>调用场合</h4><ul><li>解构赋值</li><li><p>扩展运算符<br>任何实现了Iterator接口（可遍历）的数据结构都可以通过<code>...</code>将其转化为数组</p></li><li><p><code>yield*</code>后跟一个可遍历数据结构时，会调用该结构的遍历器接口</p></li><li><code>for...of</code>, <code>Array.from</code>, <code>Map</code>, <code>Set</code>, <code>Promise.all()</code>, <code>Promise.race()</code></li></ul><h4 id="字符串、数组等的遍历器"><a href="#字符串、数组等的遍历器" class="headerlink" title="字符串、数组等的遍历器"></a>字符串、数组等的遍历器</h4><ul><li><p>字符串<br>for…of能够正确识别32位UTF-16字符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someString = <span class="string">"hi"</span>;</span><br><span class="line"><span class="keyword">typeof</span> someString[<span class="built_in">Symbol</span>.iterator]</span><br><span class="line"><span class="comment">// "function"</span></span><br><span class="line"><span class="keyword">var</span> iterator = someString[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="comment">// 当然你也可以修改Symbol.iterator方法达到你想要的遍历结果</span></span><br><span class="line">iterator.next()  <span class="comment">// &#123; value: "h", done: false &#125;</span></span><br><span class="line">iterator.next()  <span class="comment">// &#123; value: "i", done: false &#125;</span></span><br><span class="line">iterator.next()  <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>return, throw方法<br>这两个方法都是在设置遍历器生成函数时可选的，一般配合generator使用，所以下次再说</p></li><li><p>数组</p><ul><li>for … of 只返回具有数字索引的键值的值</li><li>类数组对象可以使用数组的默认遍历生成器达到遍历效果（要求是数字索引以及具有length属性）</li></ul></li><li><p>Map, Set</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map遍历返回的是数组[k, v]，Set返回的是值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">' : '</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类数组对象<br>利用Array.from将其转化为数组，再使用数组的遍历器接口用for…of实现遍历</p></li></ul><h4 id="for-…-of-注意"><a href="#for-…-of-注意" class="headerlink" title="for … of 注意"></a>for … of 注意</h4><ul><li>可以结合break、continue、return使用</li><li>提供了多种数据结构的统一访问方式</li><li>相比for … in，后者遍历的是键，且键名为字符串，还可能会遍历原型上的键</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;承上一篇，本笔记包含es6的一些新东西，如Reflect，Proxy，Iterator，Symbol等。&lt;br&gt;
    
    </summary>
    
      <category term="code" scheme="http://derekz.cn/categories/code/"/>
    
    
      <category term="js" scheme="http://derekz.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js-es6 基础篇</title>
    <link href="http://derekz.cn/posts/96174113/"/>
    <id>http://derekz.cn/posts/96174113/</id>
    <published>2017-10-30T18:17:11.000Z</published>
    <updated>2018-06-06T03:50:26.472Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;大佬们es7, es8写得嗨皮的时候，我却还在es6学习…本文为阅读阮一峰老师的系列文章记下的es6基础篇笔记。<br><a id="more"></a></p><h2 id="lesson1-introduce"><a href="#lesson1-introduce" class="headerlink" title="lesson1 introduce"></a>lesson1 introduce</h2><h3 id="新的语法成为标准的过程"><a href="#新的语法成为标准的过程" class="headerlink" title="新的语法成为标准的过程"></a>新的语法成为标准的过程</h3><ul><li>stage<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stage 0 - Strawman（展示阶段）</span><br><span class="line">Stage 1 - Proposal（征求意见阶段）</span><br><span class="line">Stage 2 - Draft（草案阶段）</span><br><span class="line">Stage 3 - Candidate（候选人阶段）</span><br><span class="line">Stage 4 - Finished（定案阶段）</span><br></pre></td></tr></table></figure></li></ul><h3 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h3><ul><li><p>.babelrc</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev babel-preset-latest</span><br><span class="line">&#123;</span><br><span class="line">    presets: [</span><br><span class="line">        <span class="string">"latest"</span>,</span><br><span class="line">        <span class="string">"react"</span>,</span><br><span class="line">        <span class="string">"stage-2"</span></span><br><span class="line">    ],</span><br><span class="line">    plugins: []</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># presets的值集有latest，react，stage-0 to stage-3（对应不同阶段的提案，选择一个）</span></span><br></pre></td></tr></table></figure></li><li><p>babel-cli</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -s生成sourcemap，-o指定文件，-d指定目录</span></span><br><span class="line">babel example.js -o compiled.js -s</span><br><span class="line"><span class="comment"># babel-node提供支持ES6的REPL环境，目标文件不需要考虑转码</span></span><br><span class="line">babel-node es6.js</span><br></pre></td></tr></table></figure></li><li><p>babel-register</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">提供一个钩子，在require加载`.js`, `.jsx`, `.es`, `.es6`后缀的文件时先用babel实时转码，需在require别的文件前先require该模块</span><br><span class="line">require(<span class="string">"babel-register"</span>);</span><br><span class="line">require(<span class="string">"./index.js"</span>);</span><br></pre></td></tr></table></figure></li><li><p>babel-core</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">需要调用babel的api时，需要require该模块</span><br><span class="line">var babel = require(<span class="string">'babel-core'</span>);</span><br><span class="line">// 字符串转码</span><br><span class="line">babel.transform(<span class="string">'code();'</span>, options);</span><br></pre></td></tr></table></figure></li><li><p>babel-polyfill</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">默认情况下babel只转句法，不转一些es6新的对象以及方法，这种情况下需要在脚本头部引入该模块转换使其可用</span><br><span class="line">import <span class="string">'babel-polyfill'</span>;</span><br></pre></td></tr></table></figure></li><li><p>Traceur</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">google提供的babel替代品</span><br></pre></td></tr></table></figure></li></ul><h2 id="lesson2-let-const"><a href="#lesson2-let-const" class="headerlink" title="lesson2 let/const"></a>lesson2 let/const</h2><h3 id="TDZ"><a href="#TDZ" class="headerlink" title="TDZ"></a>TDZ</h3><p>只在声明的块级作用域域内有效、不可重复声明、TDZ</p><ul><li><p>循环体和循环条件中的i有单独的作用域</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="string">'abc'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">//输出3次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>TDZ</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在该区域内let/const定义的变量，只有等到声明以后才可以获取/使用</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// TDZ开始</span></span><br><span class="line">  tmp = <span class="string">'abc'</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">let</span> tmp; <span class="comment">// TDZ结束</span></span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// undefined</span></span><br><span class="line">  tmp = <span class="number">123</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// 123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：带来的问题是typeof不再绝对安全</p></blockquote></li></ul><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><ul><li><p>没有块级作用域的问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 场景1</span></span><br><span class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(tmp);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = <span class="string">'hello world'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">f(); <span class="comment">// undefined因为变量提升，所以在函数执行的上下文中找到了tmp的定义，但是没有完成赋值，所以是undefined</span></span><br><span class="line"><span class="comment">// 场景2 典型的for循环将i变成了全局变量</span></span><br></pre></td></tr></table></figure></li><li><p>块级作用域</p><ul><li>告别丑陋的IIFE</li><li><p>对于es6的浏览器环境还说，函数声明类似于var，可以理解成先函数变量提升<code>var f = undefined</code>，然后再继续后面，所以以下代码是会报错的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am outside!'</span>); &#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="comment">// 重复声明一次函数f</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am inside!'</span>); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f();</span><br><span class="line">&#125;());</span><br><span class="line"><span class="comment">// Uncaught TypeError: f is not a function</span></span><br></pre></td></tr></table></figure></li><li><p>do提案</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在代码块前加<span class="keyword">do</span>，返回最后执行表达式的值</span><br><span class="line"><span class="keyword">let</span> x = <span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> t = f();</span><br><span class="line">  t * t + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><ul><li><p>freeze<br>对于复杂类型变量，const保证的是指向该变量的内存空间的地址是不变的，变量若是可写的是可以修改变量的属性值的。<br>要想冻结变量，需使用<code>Object.freeze()</code>冻结对象及对象所有属性，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> constantize = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">Object</span>.freeze(obj);</span><br><span class="line">    <span class="built_in">Object</span>.keys(obj).forEach( <span class="function">(<span class="params">key, i</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="keyword">typeof</span> obj[key] === <span class="string">'object'</span> ) &#123;</span><br><span class="line">        constantize( obj[key] );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>var function let const class<br>前两者声明的全局变量依然是顶层对象（window/global）的属性，后三者不再是，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩</p></li></ul><h3 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h3><ul><li>考虑到不同环境下顶层对象不同，提案在语言标准层面引入<code>global</code>对象作为顶层对象，即所有环境下global对象都是存在的，如下<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将顶层对象放入变量global中</span></span><br><span class="line"><span class="comment">// CommonJS 的写法</span></span><br><span class="line"><span class="keyword">var</span> global = <span class="built_in">require</span>(<span class="string">'system.global'</span>)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 模块的写法</span></span><br><span class="line"><span class="keyword">import</span> getGlobal <span class="keyword">from</span> <span class="string">'system.global'</span>;</span><br><span class="line"><span class="keyword">const</span> global = getGlobal();</span><br></pre></td></tr></table></figure></li></ul><h2 id="lesson3-解构"><a href="#lesson3-解构" class="headerlink" title="lesson3 解构"></a>lesson3 解构</h2><h3 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h3><ul><li><p>数组解构的本质是<code>模式匹配</code>，只要某种数据结构具有<code>Iterator</code>接口，就都可以采用数组形式解构。egs: Array, Set, Generator.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解构赋值设置默认值是根据右侧是否===undefined来决定右侧是否有值，有则覆盖默认值</span></span><br><span class="line"><span class="keyword">let</span> [i = <span class="number">1</span>] = [] <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">let</span> [i = <span class="number">1</span>] = [<span class="literal">undefined</span>] <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">let</span> [i = <span class="number">1</span>] = [<span class="literal">null</span>] <span class="comment">// null</span></span><br><span class="line"><span class="comment">// 下例可以看出默认值先设置，再进行解构赋值</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// x=1; y=2</span></span><br></pre></td></tr></table></figure><blockquote><p><code>[a, b, c] = arr</code> equals <code>a = arr[0] b = arr[1]</code></p></blockquote></li></ul><h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h3><ul><li><p>对象的解构赋值需要变量与对象属性名相同，本质是先找到同名的属性，然后把值赋给对应的变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo是匹配模式，不是变量，sss是被赋值的变量</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: sss, <span class="attr">bar</span>: ddd &#125; = &#123; <span class="attr">foo</span>: <span class="string">"aaa"</span>, <span class="attr">bar</span>: <span class="string">"bbb"</span> &#125;;</span><br><span class="line">foo <span class="comment">// foo is not defined</span></span><br><span class="line">sss <span class="comment">// "aaa"</span></span><br><span class="line"><span class="comment">// 默认值生效的条件是，对象的属性值严格等于undefined，结构失败为undefined</span></span><br><span class="line"><span class="keyword">let</span> &#123; x = <span class="number">2</span> &#125; = &#123; <span class="attr">x</span>: <span class="literal">null</span> &#125;</span><br><span class="line">x<span class="comment">// null</span></span><br><span class="line"><span class="comment">// 如果解构模式是嵌套的对象，父属性不存在时会报错</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">foo</span>: &#123;bar&#125;&#125; = &#123;<span class="attr">baz</span>: <span class="string">'baz'</span>&#125;</span><br><span class="line"><span class="comment">// 理解下面的为三次解构 node.loc node.loc.start node.loc.start.line</span></span><br><span class="line"><span class="keyword">let</span> &#123; loc, <span class="attr">loc</span>: &#123; start &#125;, <span class="attr">loc</span>: &#123; <span class="attr">start</span>: &#123; line &#125;&#125; &#125; = node</span><br></pre></td></tr></table></figure><blockquote><p>原来项目里天天写的<code>const {a, b} = this.state</code>是解构赋值！<br><code>let {a:c, b:d} = obj</code> equals <code>c = obj.a d = obj.b</code></p></blockquote></li></ul><h3 id="字符串、数值、布尔值、null、undefined"><a href="#字符串、数值、布尔值、null、undefined" class="headerlink" title="字符串、数值、布尔值、null、undefined"></a>字符串、数值、布尔值、null、undefined</h3><ul><li><p>如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b,c] = <span class="string">'skt'</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span>: len&#125; = <span class="string">'skt'</span></span><br></pre></td></tr></table></figure></li><li><p>如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等号右边先转为对象再进行解构赋值，故undefined和null会报错</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="number">123</span>;</span><br><span class="line">s === <span class="built_in">Number</span>.prototype.toString <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><ul><li><p>交换变量值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x, y] = [y, x]</span><br></pre></td></tr></table></figure></li><li><p>从函数返回多个值</p></li><li><p>函数参数的定义、默认值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数是一组有次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[x, y, z]</span>) </span>&#123; ... &#125;</span><br><span class="line">f([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="comment">// 参数是一组无次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123;x, y, z&#125;</span>) </span>&#123; ... &#125;</span><br><span class="line">f(&#123;<span class="attr">z</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure></li><li><p>提取JSON数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData;</span><br></pre></td></tr></table></figure></li><li><p>遍历map</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取key、value</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">" is "</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取输入模块的指定方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SourceMapConsumer, SourceNode &#125; = <span class="built_in">require</span>(<span class="string">"source-map"</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="lesson4-字符串扩展"><a href="#lesson4-字符串扩展" class="headerlink" title="lesson4 字符串扩展"></a>lesson4 字符串扩展</h2><ul><li>unicode表示<br>js中，可以用\uxxxx表示字符，xxxx为该字符的Unicode码位。js内部，字符以UTF-16格式存储，即每个字符为2个字节(0x0000-0xFFFF)，对于需要4字节存储的例如汉字，在处理时可能会出现误判。</li><li><p><code>codePointAt</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否为4字节组成</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is32Bit</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> c.codePointAt(<span class="number">0</span>) &gt; <span class="number">0xFFFF</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>String.fromCodePoint</code><br>返回码点对应字符，支持4字节，即32位UTF-16字符</p></li><li>字符串遍历<br><code>for ... of ...</code>遍历字符串，可以做到支持32位UTF-16字符</li><li>提案 <code>at</code><br>charAt返回的是UTF-16字符的前两个字节，提案at可以支持4字节UTF-16字符，需要垫片库支持</li><li><code>include(), startsWith(), endsWith()</code><br>字面理解，注意可以传一个下标参数，表示查找位置</li><li><p><code>repeat(), padStart(5, s = &#39;&#39;), padEnd(5, e = &#39;&#39;)</code><br>padStart填充在前，padEnd填充在后，若原字符串长度大于第一个参数，则不填充返回原字符串，若加起来大于第一个参数则保留原，去除需添加的多余的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'123456'</span>.padStart(<span class="number">10</span>, <span class="string">'0'</span>) <span class="comment">// "0000123456"</span></span><br><span class="line"><span class="string">'12'</span>.padStart(<span class="number">10</span>, <span class="string">'YYYY-MM-DD'</span>) <span class="comment">// "YYYY-MM-12"</span></span><br></pre></td></tr></table></figure></li><li><p>模板字符串</p></li><li><p>标签模板</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> total = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">let</span> msg = passthru<span class="string">`The total is <span class="subst">$&#123;total&#125;</span> (<span class="subst">$&#123;total*<span class="number">1.05</span>&#125;</span> with tax)`</span>;</span><br><span class="line"><span class="comment">// ['The total is ', ' ', ' (', ' with tax)'], 30, 31.5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">passthru</span>(<span class="params">literals, ...values</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> output = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">let</span> index;</span><br><span class="line"><span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; values.length; index++) &#123;</span><br><span class="line">    output += literals[index] + values[index];</span><br><span class="line">&#125;</span><br><span class="line">output += literals[index]</span><br><span class="line"><span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line">msg <span class="comment">// "The total is 30 (31.5 with tax)"</span></span><br></pre></td></tr></table></figure><blockquote><p>过滤字符串</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">let</span> message =</span><br><span class="line">SaferHTML<span class="string">`&lt;p&gt;<span class="subst">$&#123;sender&#125;</span> has sent you a message.&lt;/p&gt;`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">SaferHTML</span>(<span class="params">templateData</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> s = templateData[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> arg = <span class="built_in">String</span>(<span class="built_in">arguments</span>[i]);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Escape special characters in the substitution.</span></span><br><span class="line">      s += arg.replace(<span class="regexp">/&amp;/g</span>, <span class="string">"&amp;amp;"</span>)</span><br><span class="line">              .replace(<span class="regexp">/&lt;/g</span>, <span class="string">"&amp;lt;"</span>)</span><br><span class="line">              .replace(<span class="regexp">/&gt;/g</span>, <span class="string">"&amp;gt;"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Don't escape special characters in the template.</span></span><br><span class="line">      s += templateData[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>其他用途有：i18n、模板处理、引入其他语言等</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面的hashTemplate函数</span></span><br><span class="line"><span class="comment">// 是一个自定义的模板处理函数</span></span><br><span class="line"><span class="keyword">let</span> libraryHtml = hashTemplate<span class="string">`</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string">    #for book in <span class="subst">$&#123;myBooks&#125;</span></span></span><br><span class="line"><span class="string">    &lt;li&gt;&lt;i&gt;#&#123;book.title&#125;&lt;/i&gt; by #&#123;book.author&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="string">    #end</span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="lesson5-数值扩展"><a href="#lesson5-数值扩展" class="headerlink" title="lesson5 数值扩展"></a>lesson5 数值扩展</h2><ul><li>0o/0O 八进制 0b/0B 二进制</li><li><code>Number.isFinite</code> <code>Number.isNaN</code><br>与全局<code>isFinite</code>、<code>isNaN</code>的差别在于前者只对数值有效，非数值一律返回<code>false</code>后者是先将非数值转化为数值再判断。</li><li><code>Number.ParseInt</code> <code>Number.ParseFloat</code> <code>Number.isInteger</code><br>逐步减少全局性方法，使得语言逐步模块化</li><li><code>Number.EPSILON</code> 可以接受的最小误差范围</li><li><p><code>isSafeInteger</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">9007199254740993</span>)</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">990</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">9007199254740993</span> - <span class="number">990</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="number">9007199254740993</span> - <span class="number">990</span></span><br><span class="line"><span class="comment">// 返回结果 9007199254740002</span></span><br><span class="line"><span class="comment">// 正确答案应该是 9007199254740003</span></span><br></pre></td></tr></table></figure><p>9007199254740993不是一个安全整数，但是Number.isSafeInteger会返回结果，显示计算结果是安全的。这是因为，这个数超出了精度范围，导致在计算机内部，以9007199254740992的形式储存</p></li><li>Math对象扩展<ul><li>指数运算符<code>**</code></li><li><code>提案</code> Integer</li></ul></li></ul><h2 id="lesson6-函数扩展"><a href="#lesson6-函数扩展" class="headerlink" title="lesson6 函数扩展"></a>lesson6 函数扩展</h2><h3 id="参数设置默认值、rest参数"><a href="#参数设置默认值、rest参数" class="headerlink" title="参数设置默认值、rest参数"></a>参数设置默认值、rest参数</h3><ul><li>basic</li><li><p>with解构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m1</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m2</span>(<span class="params">&#123;x, y&#125; = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理解二者区别即可，其余可参见<a href="http://www.derekz.cn/posts/78048d04/" target="_blank" rel="noopener">解构</a></p></li><li><p>函数的<code>length</code>属性：未指定默认值的参数个数</p></li><li><p>参数一旦设置了默认值，函数在声明初始化时会形成单独的作用域，初始化结束后释放掉。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m</span>(<span class="params">y=x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">2</span></span><br><span class="line">    <span class="built_in">console</span>.log(y)</span><br><span class="line">&#125;</span><br><span class="line">m()<span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 如果全局x不存在会报错，第二行相当于发生了let y = x, x指向全局的x, 不受内部x影响</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y = function(</span>) </span>&#123; x = <span class="number">2</span>; &#125;) &#123;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line">y();</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 理解：这里有三个作用域，三个x，各不相干 3</span></span><br><span class="line"><span class="comment">// 去掉var以后参数中的两个x和函数体内x是一样的，外部还是不变 2</span></span><br></pre></td></tr></table></figure></li><li><p>应用<br>指定参数必传，否则报错，即给参数赋值一个默认的函数抛错的结果，没传时得到的是这个抛出的错<br>用默认赋值undefined表示该参数可省略</p></li><li>函数的length不包含rest参数</li><li>rest参数之后不能再有参数</li><li>只要参数使用了默认值、解构赋值、或者扩展运算符，就不能显式指定严格模式</li></ul><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><ul><li><p>注意</p><ul><li>箭头函数体内的this指向函数定义时的对象，不是对应运行时的对象</li><li>不可以当做构造函数</li><li>不可以使用yield</li><li>不可以使用arguments</li><li>不可以使用bind、call、apply来改变箭头函数this指向</li></ul></li><li><p>this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> headAndTail = <span class="function">(<span class="params">head, ...tail</span>) =&gt;</span> [head, tail];</span><br><span class="line">headAndTail(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) <span class="comment">// [1,[2,3,4,5]]</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><p>双冒号运算符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj::func === func.bind(obj)</span><br><span class="line">foo::bar(...arguments) === bar.apply(foo, <span class="built_in">arguments</span>)</span><br></pre></td></tr></table></figure></li><li><p>尾调用优化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数f的最后一步为函数g调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> g(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数调用会在内存在生成调用记录，即调用帧，如A函数中调用B函数，则会在A的调用帧上方形成B的调用帧，B调用完后，返回至A才会消失。尾调用实际上已经不用保存外层A的调用帧了，可以优化。<br><strong>只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”</strong></p></li><li><p>尾递归优化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非尾递归</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( n &lt;= <span class="number">1</span> ) &#123;<span class="keyword">return</span> <span class="number">1</span>&#125;;</span><br><span class="line">  <span class="keyword">return</span> Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 尾递归</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci2</span> (<span class="params">n , ac1 = <span class="number">1</span> , ac2 = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>( n &lt;= <span class="number">1</span> ) &#123;<span class="keyword">return</span> ac2&#125;;</span><br><span class="line">  <span class="keyword">return</span> Fibonacci2 (n - <span class="number">1</span>, ac2, ac1 + ac2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">传统递归需要保存相当多的调用帧，尾递归只保存一个，节省内存，避免发生栈溢出</span><br></pre></td></tr></table></figure></li><li><p>柯里化<br>将多参数函数变成单参数形式（具体下次再论）</p></li><li>es2017支持函数最后一个参数尾逗号</li><li>在不需要错误实例的时候，提案try…catch…菜单catch块不需要参数</li></ul><h2 id="lesson7-数组扩展"><a href="#lesson7-数组扩展" class="headerlink" title="lesson7 数组扩展"></a>lesson7 数组扩展</h2><h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><ul><li><code>...</code> 可以理解为rest参数的逆运算，将数组转化为逗号分隔的参数序列，如<code>Math.max(...[14, 3, 77])</code></li><li><p>复制数组（直接赋值是引用，指向相同地址）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// es5</span></span><br><span class="line">a1 = [<span class="number">1</span>,<span class="number">2</span>];    a2 = a1.concat()</span><br><span class="line"><span class="comment">// es6</span></span><br><span class="line">a1 = [<span class="number">1</span>,<span class="number">2</span>];    a2 = [...a1]</span><br></pre></td></tr></table></figure></li><li><p>合并数组</p></li><li><p>与解构结合<br>扩展运算符用于数组赋值时，只能作为最后一个参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, ...b] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure></li><li><p>字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成数组</span></span><br><span class="line">[...<span class="string">'hello'</span>]</span><br><span class="line"><span class="comment">// 返回字符串正确长度，兼容4字节UTF-16编码的Unicode字符</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">length</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> [...str].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现了 Iterator 接口的对象（下回分解）</p></li><li>Map Set Generator（下回分解）</li></ul><h3 id="Array方法"><a href="#Array方法" class="headerlink" title="Array方法"></a>Array方法</h3><ul><li><p><code>Array.from()</code><br>将<code>arraylike</code>对象和可遍历对象转为数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Array.prototype.slice</span></span><br><span class="line"><span class="built_in">Array</span>.from</span><br><span class="line"><span class="comment">// Array.from(arrayLike).map(x =&gt; x * x)</span></span><br><span class="line"><span class="comment">// 接收第二个参数，类似map，可用于如NodeList对象等处理，获取dom节点的属性</span></span><br><span class="line"><span class="built_in">Array</span>.from(arrayLike, x =&gt; x * x)</span><br><span class="line"><span class="built_in">Array</span>.from([<span class="number">1</span>, , <span class="number">2</span>, , <span class="number">3</span>], (n) =&gt; n || <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 第三个参数，可以绑定this</span></span><br></pre></td></tr></table></figure><p><code>...</code>调用的是遍历器接口（<code>Symbol.iterator</code>），若对象没有部署这个接口，就不能转化为数组，<code>Array.from</code>可以转换任何有length属性的对象</p><p>因吹斯听</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="number">2</span> &#125;, () =&gt; <span class="string">'jack'</span>)</span><br><span class="line">效果：第一个参数为第二个参数（函数）指定执行次数</span><br></pre></td></tr></table></figure></li><li><p><code>Array.of</code><br>总是返回参数值组成的数组，如果没有参数，就返回一个空数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 弥补构造函数Array()的不足（1-2个参数时）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArrayOf</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>copyWithin</code> 用途不明</p></li><li><code>find</code> <code>findIndex</code> 前者返回第一个值/<code>undefined</code>，后者返回位置/-1</li><li><code>fill</code> 数组填充，可以指定起始、结束位置</li><li><code>keys()</code> <code>values()</code> <code>entries()</code> 用于遍历数组，返回遍历器对象，可以使用for…of循环也可以手动调用遍历器对象的next方法。分别对应 键、值、键值对（[0,’a’]）</li><li><code>includes()</code> 判断数组中是否包含某个值，解决了indexOf对NaN的误判（因为NaN!==NaN，indexOf是===判断）</li><li>空位，es6上述数组扩展对空位处理比较一致，值设为undefined，遍历时视为存在</li></ul><h2 id="lesson8-对象扩展"><a href="#lesson8-对象扩展" class="headerlink" title="lesson8 对象扩展"></a>lesson8 对象扩展</h2><h3 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h3><ul><li><p>属性、方法简写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; a &#125; &#123; a() &#123;&#125; &#125;</span><br></pre></td></tr></table></figure></li><li><p>属性名表达式、方法名表达式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; [<span class="string">'a'</span> + <span class="string">'bc'</span>]: <span class="string">'a'</span> &#125;</span><br><span class="line">&#123; [<span class="string">'a'</span> + <span class="string">'bc'</span>]() &#123;&#125; &#125;</span><br><span class="line"><span class="comment">// 注意属性名为对象时，会自动转为字符串`[object Object]`</span></span><br></pre></td></tr></table></figure></li><li><p>方法名name</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这种情况下`obj.foo.name`会报错</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    get foo() &#123;&#125;,</span><br><span class="line">    set foo(x) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 正确写法</span></span><br><span class="line"><span class="keyword">const</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'foo'</span>);</span><br><span class="line">descriptor.get.name <span class="comment">// get foo</span></span><br><span class="line"><span class="comment">// special</span></span><br><span class="line">(<span class="keyword">new</span> <span class="built_in">Function</span>()).name <span class="comment">// "anonymous"</span></span><br><span class="line">doSomething.bind().name <span class="comment">// "bound doSomething"</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is"></a><code>Object.is</code></h4><ul><li>比较<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 除了下列情况外和===的表现一致</span></span><br><span class="line">+<span class="number">0</span> === <span class="number">-0</span> <span class="comment">//true</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a><code>Object.assign</code></h4><ul><li><p>用于对象合并，将源对象的所有可枚举属性复制到目标对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</span><br></pre></td></tr></table></figure></li><li><p>注意<br>非对象出现在第一个参数会被转为对象，出现在后面只有字符串会以字符数组形式参与合并。（因为只有字符串的包装对象，会产生可枚举属性）<br>对于undefined和null无法转为对象，多以出现在第一个参数位会报错，出现在后面会被忽略。<br>浅拷贝，即如果源对象的某个属性是对象，则目标对象拷贝的是该对象的引用</p></li><li><p>用途</p><ul><li>为对象添加属性、方法</li><li><p>克隆对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只克隆原有可枚举属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">origin</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, origin);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 保持继承链</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">origin</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> originProto = <span class="built_in">Object</span>.getPrototypeOf(origin);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.assign(<span class="built_in">Object</span>.create(originProto), origin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>合并多个对象</p></li><li>为属性设置默认值（利用覆盖，注意应为简单类型）</li></ul></li></ul><h4 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors"></a><code>Object.getOwnPropertyDescriptors</code></h4><ul><li>返回指向对象的所有自身属性的描述对象</li><li>由于Object.assign是赋值拷贝，所以无法正确拷贝对象的get和set方法，所以需要有方式去获取描述对象，再结合defineProperties进行</li><li>结合Object.create使用，浅拷贝</li></ul><h4 id="Object-getPropertyOf-Object-setPropertyOf-proto"><a href="#Object-getPropertyOf-Object-setPropertyOf-proto" class="headerlink" title="Object.getPropertyOf, Object.setPropertyOf, __proto__"></a><code>Object.getPropertyOf</code>, <code>Object.setPropertyOf</code>, <code>__proto__</code></h4><ul><li><p><code>__proto__</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj = <span class="built_in">Object</span>.create(someOtherObj);</span><br><span class="line">obj.__proto__ = someOtherObj;</span><br></pre></td></tr></table></figure></li><li><p><code>Object.setPrototypeOf(obj, proto)</code><br>将proto对象设为obj的原型，第一个参数为undefined和null时报错，非对象时自动转</p></li><li><p><code>Object.getPrototypeOf(obj)</code></p></li></ul><h4 id="super"><a href="#super" class="headerlink" title="super"></a><code>super</code></h4><ul><li>指向当前对象的原型对象，只有对象的方法的简写模式中有效，否则报错</li><li><code>super.foo</code>等同于<code>Object.getPrototypeOf(this).foo</code></li></ul><h4 id="Object-keys-Object-values-Object-entries"><a href="#Object-keys-Object-values-Object-entries" class="headerlink" title="Object.keys, Object.values, Object.entries"></a><code>Object.keys</code>, <code>Object.values</code>, <code>Object.entries</code></h4><ul><li><code>Object.entries</code> 用途：<code>new Map(Object.entries(obj))</code></li></ul><h3 id="属性的可枚举和遍历"><a href="#属性的可枚举和遍历" class="headerlink" title="属性的可枚举和遍历"></a>属性的可枚举和遍历</h3><h4 id="可枚举"><a href="#可枚举" class="headerlink" title="可枚举"></a>可枚举</h4><ul><li><p>获取属性的描述对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'foo'</span>)</span><br><span class="line"><span class="comment">//  &#123;</span></span><br><span class="line"><span class="comment">//    value: 123,</span></span><br><span class="line"><span class="comment">//    writable: true,</span></span><br><span class="line"><span class="comment">//    enumerable: true,</span></span><br><span class="line"><span class="comment">//    configurable: true</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>忽略 enumerable为false的操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ... in <span class="comment">// 会返回继承的属性</span></span><br><span class="line"><span class="built_in">Object</span>.keys()</span><br><span class="line"><span class="built_in">JSON</span>.stringify()</span><br><span class="line"><span class="built_in">Object</span>.assign()</span><br></pre></td></tr></table></figure></li><li><p>遍历</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ... in <span class="comment">// 遍历自身和继承的**可枚举**属性，不包含Symbol属性</span></span><br><span class="line"><span class="built_in">Object</span>.keys <span class="comment">// 返回一个数组，只包含自身所有**可枚举**属性，不包含Symbol属性</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(obj) <span class="comment">// 返回一个数组，包含对象自身的**所有**属性，不包含Symbol属性</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(obj) <span class="comment">// 返回一个数组，包含对象本身的所有Symbol属性</span></span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(obj) <span class="comment">// 返回一个数组，包含自身**所有键名**</span></span><br><span class="line"><span class="comment">// 共性：遍历顺序为 数值键-字符串键-Symbol属性</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="扩展运算符-1"><a href="#扩展运算符-1" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><h3 id="Null传导运算符（提案）"><a href="#Null传导运算符（提案）" class="headerlink" title="Null传导运算符（提案）"></a>Null传导运算符（提案）</h3><ul><li><code>obj?.prop, obj?.[expr], func?.(...args), new C?.(...args)</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;大佬们es7, es8写得嗨皮的时候，我却还在es6学习…本文为阅读阮一峰老师的系列文章记下的es6基础篇笔记。&lt;br&gt;
    
    </summary>
    
      <category term="code" scheme="http://derekz.cn/categories/code/"/>
    
    
      <category term="js" scheme="http://derekz.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Hexo快速搭建博客</title>
    <link href="http://derekz.cn/posts/d76cea4a/"/>
    <id>http://derekz.cn/posts/d76cea4a/</id>
    <published>2017-10-25T11:01:33.000Z</published>
    <updated>2018-06-06T03:50:26.469Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;利用一天时间搭一个简单漂亮的静态博客，平时记记笔记、写写文章，日积月累，收获也许会让你意想不到。<br><a id="more"></a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;对于酷爱尝新的程序员们来说，博客可能是为数不多的仍被广泛使用的旧东西之一了。不论是为了技术积累，还是为了提高逼格，多数程序员心中都曾有过搭建博客站的想法。</p><p>&emsp;在搭建博客的时候，大佬或者不麻烦会死星人都喜欢撸起袖子自己干，然而对于像我一样的一批渣渣小白来说要脱离现成框架自己搞出个名堂来绝非易事。换工作的空档期，忙得只剩下时间，也手撸了个<a href="http://blog.derekz.cn/" target="_blank" rel="noopener">博客站</a>，除去编码时间，大部分的时间花在服务器部署上，对于一名前端切图狗来说，还是费了不少心思的，有兴趣的这里送上<a href="https://github.com/derekeeeeely/nuxt-derekzhou" target="_blank" rel="noopener">传送门</a>。</p><p>&emsp;就效果来说自己动手肯定是可以学到更多东西的，愿意投入时间是值得去尝试的，而且自己开发是可以根据需要个性化定制的，这是第三方服务不能很好地提供的。随之而来的坏处其一是开发成本和学习成本，独立博客站需要一定的技术积累，有一定的门槛，并不适合所有人。其二是即便你有能力有时间做到，后期是否会花心思去维护打理也是一个问题。想起我自己一开始满腔热血，下定决心要搞出个完美博客，结果七天草草收工，预先想加上的功能一个个都无疾而终，甚至到昨天域名都还没备案。</p><p>&emsp;我以为独立博客站适合于自由职业者或者能够在短时间内把自己的需要实现的大佬们，因为这两者后期要么有时间维护要么不需要过多时间去维护。在博客站搭建完成以后他们就可以把重心放回到自己的工作和生活当中，在有技术积累或者装逼需要的时候只需要记录、上传这些简单的操作。</p><p>&emsp;更加省心的选择是成熟的第三方框架，比如本站所用的<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo</a>，不得不说Hexo提供的功能和样式都是很有吸引力的，本身也不需要多少学习成本，甚至于非程序员也可以跟着教程实现。本文还是针对对于git有了解的想要快速搭建博客的程序员们，如果这方面有问题的话，也可以先去了解下git相关的东西。</p><h2 id="Hexo-走你"><a href="#Hexo-走你" class="headerlink" title="Hexo 走你"></a>Hexo 走你</h2><h3 id="大胆假设"><a href="#大胆假设" class="headerlink" title="大胆假设"></a>大胆假设</h3><ul><li>你的SSH key配置无误</li><li>你安装好了node/npm</li><li>你在你的Github上建了一个 your_user_name.github.io 的 repo</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局安装hexo</span></span><br><span class="line">cnpm install hexo -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装hexo deploy包</span></span><br><span class="line">cnpm install hexo-deployer-git --save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化博客目录</span></span><br><span class="line"><span class="built_in">cd</span> your_blog_dir</span><br><span class="line">hexo init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装依赖包</span></span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动本地服务，访问127.0.0.1:4000，bingo！你将看到hexo默认首页</span></span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><h3 id="Hexo设置"><a href="#Hexo设置" class="headerlink" title="Hexo设置"></a>Hexo设置</h3><h4 id="基本设置"><a href="#基本设置" class="headerlink" title="基本设置"></a>基本设置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑根目录下的配置文件</span></span><br><span class="line">vi _config.yml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署配置</span></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repository: git@github.com:derekeeeeely/derekeeeeely.github.io.git</span><br><span class="line">  branch: master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 站点设置</span></span><br><span class="line">title: DZ<span class="string">'s Gensokyo</span></span><br><span class="line"><span class="string">subtitle: Best Time, Best You and Me</span></span><br><span class="line"><span class="string">description: life are flashes and here is my life</span></span><br><span class="line"><span class="string">author: Derek Zhou</span></span><br><span class="line"><span class="string">language: zh-Hans</span></span><br><span class="line"><span class="string">timezone:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 你的域名</span></span><br><span class="line"><span class="string">url: http://derekz.cn</span></span><br></pre></td></tr></table></figure><blockquote><p>完成基本设置后可以使用系一部分提到的命令进行创建文章、生成文件、部署到Git等操作</p></blockquote><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新建文章</span></span><br><span class="line">hexo new XXX</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在source目录下生成一个XXX文件夹，可以配置到head的导航处（后面有说明）</span></span><br><span class="line">hexo new page XXX</span><br><span class="line"></span><br><span class="line"><span class="comment"># local server, 简化hexo s</span></span><br><span class="line">hexo server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成静态页面，简化hexo g</span></span><br><span class="line">hexo generate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署到Github，简化hexo d</span></span><br><span class="line">hexo deploy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除public，修改未生效时（有待研究hexo的热更新）</span></span><br><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成+部署</span></span><br><span class="line">hexo d -g</span><br></pre></td></tr></table></figure><h3 id="Hexo主题-—-Next"><a href="#Hexo主题-—-Next" class="headerlink" title="Hexo主题 — Next"></a>Hexo主题 — Next</h3><p>&emsp;Hexo 提供了很多主题的选项，本站使用的是Next，也是比较流行，个人认为比较好看的主题。笔者用的版本是5.1.3，应该是比较高的版本，本身已经集成了很多有用的插件，配置起来更方便一些。其他版本和其他主题应该也多有相似之处，可供参考。</p><h4 id="Next-安装"><a href="#Next-安装" class="headerlink" title="Next 安装"></a>Next 安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 项目根目录clone Next主题代码</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next.git themes/next</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改项目配置，设置主题为Next，后续的很多设置都在Next的_config.yml 文件中进行，可以看成一个extend的关系</span></span><br><span class="line">vi _config.yml</span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure><h4 id="Next-插件篇"><a href="#Next-插件篇" class="headerlink" title="Next 插件篇"></a>Next 插件篇</h4><blockquote><p>敲黑板，划重点啦，好不好用，逼格高不高就看这里了。</p></blockquote><h5 id="导航条"><a href="#导航条" class="headerlink" title="导航条"></a>导航条</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># menu设置</span></span><br><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  categories: /categories/ || th</span><br><span class="line">  tags: /tags/ || tags</span><br><span class="line">  archives: /archives/ || archive</span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment"># sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  commonweal: /404.html || heartbeat</span><br><span class="line">  about: /about/ || user</span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable/Disable menu icons.</span></span><br><span class="line">menu_icons:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Next的四种主题，Mist表现中规中矩</span></span><br><span class="line">scheme: Mist</span><br></pre></td></tr></table></figure><p>&emsp;menu对应Next的Mist主题下头部导航，需要new出相应的页面，其中归档(archives)是默认有的，分类(categories)、标签(tags)、404页面和关于(about)是需要创建或编辑的。</p><h5 id="站内搜索"><a href="#站内搜索" class="headerlink" title="站内搜索"></a>站内搜索</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装依赖包</span></span><br><span class="line">cnpm install hexo-generator-search --save</span><br><span class="line">cnpm install hexo-generator-searchdb --save</span><br><span class="line"></span><br><span class="line"><span class="comment"># Local search 打开</span></span><br><span class="line">local_search:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure><h5 id="阅读量统计"><a href="#阅读量统计" class="headerlink" title="阅读量统计"></a>阅读量统计</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># leanCloud配置 （Next config已存在）</span></span><br><span class="line">leancloud_visitors:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  app_id: ssssssssssssssssssssssss</span><br><span class="line">  app_key: sssssssssssssssssssssss</span><br></pre></td></tr></table></figure><p>&emsp;使用leancloud做统计，Next的插件目录底下的<code>lean-analytics.swig</code>文件已经存在leanCloud的引入和统计代码，我们只需要注册leanCloud，使用<code>app_id</code>和<code>app_key</code>做身份校验，按如上填写好就可以了。</p><h5 id="字数统计和阅读时间估计"><a href="#字数统计和阅读时间估计" class="headerlink" title="字数统计和阅读时间估计"></a>字数统计和阅读时间估计</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装依赖包</span></span><br><span class="line">cnpm install hexo-wordcount --save</span><br><span class="line"></span><br><span class="line"><span class="comment"># wordcount 设置（Next config已存在）</span></span><br><span class="line">post_wordcount:</span><br><span class="line">  item_text: <span class="literal">true</span></span><br><span class="line">  wordcount: <span class="literal">true</span></span><br><span class="line">  min2read: <span class="literal">true</span></span><br><span class="line">  totalcount: <span class="literal">false</span></span><br><span class="line">  separated_meta: <span class="literal">true</span></span><br></pre></td></tr></table></figure><h5 id="siderbar设置"><a href="#siderbar设置" class="headerlink" title="siderbar设置"></a>siderbar设置</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 社交链接/icon设置</span></span><br><span class="line">social:</span><br><span class="line">  GitHub: https://github.com/derekeeeeely</span><br><span class="line">  微博: http://weibo.com/u/3248682277</span><br><span class="line">social_icons:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  GitHub: github</span><br><span class="line">  微博: weibo</span><br><span class="line"></span><br><span class="line"><span class="comment"># links友情链接</span></span><br><span class="line">links:</span><br><span class="line">  我的小站: http://119.23.217.75</span><br></pre></td></tr></table></figure><p>&emsp;Next的icon默认使用的是Font Awesome库，需要注意的是key应该保持一致。友情链接可以放些自己的或者自己收藏的社区啊论坛啊大佬博客之类的，方便快速跳转。本站这里是因为自己另一个博客的域名没备案，所以放了IP，不要在意这些细节。有关于RSS和头像这部分没有累列出来，RSS是因为最后得到的是一个XML，老实说我不知道这个XML拿来有啥用，头像的话其实就改样式，不想自己写的话<a href="http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html" target="_blank" rel="noopener">随便搜搜</a>都有的，也就不贴出来了2333。</p><h5 id="文件压缩"><a href="#文件压缩" class="headerlink" title="文件压缩"></a>文件压缩</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装依赖包</span></span><br><span class="line">cnpm install hexo-all-minifier --save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在根目录配置文件中添加</span></span><br><span class="line">html_minifier:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  ignore_error: <span class="literal">false</span></span><br><span class="line">  exclude:</span><br><span class="line">css_minifier:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  exclude:</span><br><span class="line">    - <span class="string">'*.min.css'</span></span><br><span class="line">js_minifier:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  mangle: <span class="literal">true</span></span><br><span class="line">  output:</span><br><span class="line">  compress:</span><br><span class="line">  exclude:</span><br><span class="line">    - <span class="string">'*.min.js'</span></span><br><span class="line">image_minifier:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  interlaced: <span class="literal">false</span></span><br><span class="line">  multipass: <span class="literal">false</span></span><br><span class="line">  optimizationLevel: 2</span><br><span class="line">  pngquant: <span class="literal">false</span></span><br><span class="line">  progressive: <span class="literal">false</span></span><br></pre></td></tr></table></figure><h5 id="文章链接唯一化"><a href="#文章链接唯一化" class="headerlink" title="文章链接唯一化"></a>文章链接唯一化</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装依赖包</span></span><br><span class="line">npm install hexo-abbrlink --save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在根目录配置文件中修改</span></span><br><span class="line">permalink: posts/:abbrlink/  <span class="comment"># “posts/” 可自行更换</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># abbrlink config</span></span><br><span class="line">abbrlink:</span><br><span class="line">  alg: crc32  <span class="comment"># 算法：crc16(default) and crc32</span></span><br><span class="line">  rep: hex    <span class="comment"># 进制：dec(default) and hex</span></span><br></pre></td></tr></table></figure><h3 id="进阶黑科技"><a href="#进阶黑科技" class="headerlink" title="进阶黑科技"></a>进阶黑科技</h3><h4 id="SEO-观察效果ing"><a href="#SEO-观察效果ing" class="headerlink" title="SEO (观察效果ing)"></a>SEO (观察效果ing)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装依赖包</span></span><br><span class="line">cnpm install hexo-generator-sitemap --save</span><br><span class="line">cnpm install hexo-generator-baidu-sitemap --save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根目录配置中添加</span></span><br><span class="line">sitemap:</span><br><span class="line">  path: sitemap.xml</span><br><span class="line">baidusitemap:</span><br><span class="line">  path: baidusitemap.xml</span><br><span class="line"></span><br><span class="line"><span class="comment"># source目录添加robots.txt</span></span><br><span class="line">User-agent: *</span><br><span class="line">Allow: /</span><br><span class="line">Allow: /archives/</span><br><span class="line">Allow: /categories/</span><br><span class="line">Allow: /tags/</span><br><span class="line"></span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /js/</span><br><span class="line">Disallow: /css/</span><br><span class="line">Disallow: /fonts/</span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /fancybox/</span><br><span class="line"></span><br><span class="line">Sitemap: http://www.derekz.cn/sitemap.xml</span><br><span class="line">Sitemap: http://www.derekz.cn/baidusitemap.xml</span><br></pre></td></tr></table></figure><p>&emsp;上述配置完后需要自备梯子翻墙登录google search console，按照提示一步一步走，验证域名所有权-&gt;抓取对应路由页面数据-&gt;加入资源索引，由于次数有限制，需要确定好哦。</p><h4 id="七牛云及图床"><a href="#七牛云及图床" class="headerlink" title="七牛云及图床"></a>七牛云及图床</h4><p>&emsp;七牛云注册以后会提供10G的免费存储空间，一般来说存些图片是够用的了，问题在于我们在写markdown的时候图片链接复制是在是太麻烦了。这里提供几个选项：</p><ul><li>ipic 免费版图片上传至微博，每月付费可上传至七牛云（RMB玩家可以考虑）</li><li>picU 只支持七牛云，可以一键截图上传并复制好图片链接（比较好用，但是笔者的这个不知道为啥用得好好的某一天突然就验证不通过了）</li><li><a href="https://github.com/jiwenxing/qiniu-image-tool" target="_blank" rel="noopener">qiniu-image-tool</a> 需要安装qshell（七牛云的一个命令行工具）以及 Alfred（非RMB玩家能接受破解版的话可以去<a href="http://xclient.info" target="_blank" rel="noopener">这里</a>下载哦）</li></ul><h4 id="域名指向"><a href="#域名指向" class="headerlink" title="域名指向"></a>域名指向</h4><p>&emsp;推荐<a href="https://wanwang.aliyun.com/domain/" target="_blank" rel="noopener">阿里云</a>，顺便一提，阿里云的ECS最低配首年只要300块，有服务器需求的可以尝试。<br>&emsp;注册好域名后需要添加域名解析，讲道理的话配置CNAME为www和@、记录值为XXX.github.io就可以的，但是实际操作上我在阿里云域名解析这里尝试配置第二条的时候一直报错，没办法，ping了下XXX.github.io拿到IP后加了一条记录类型为A、记录值为IP的记录，如下图所示：<img src="http://opo02jcsr.bkt.clouddn.com/2ca6bdd66256d44f70c4e6217c16f99f.jpg" alt="域名解析"></p><p>&emsp;还需要做的一件事是在source目录底下创建一个CNAME文件，内容的话就填写你的域名，然后push到远端，重新部署。</p><h4 id="保存文件"><a href="#保存文件" class="headerlink" title="保存文件"></a>保存文件</h4><p>&emsp;为了保留本地文件，参考前辈做法，在自己的这个repo上checkout一个新的分支derekzhou，将代码提交。以后每次更新文章时先push到derekzhou分支，然后执行hexo的命令去生成public文件deploy到master。这样就算本机坏了也没影响，源代码还是可以从git上clone下来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .gitignore</span></span><br><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.<span class="built_in">log</span></span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br><span class="line">/.deploy_git</span><br><span class="line">/public</span><br><span class="line"><span class="comment"># /_config.yml</span></span><br></pre></td></tr></table></figure><p>&emsp;有任何疑问，欢迎<a href="https://github.com/derekeeeeely/derekeeeeely.github.io/issues" target="_blank" rel="noopener">git</a>、<a href="http://weibo.com/u/3248682277" target="_blank" rel="noopener">weibo</a>各种方式@我，博客的评论功能这两天会加上，因为好像现在梯子都被砍，第三方的一些评论服务也不好用了，有时间再看看吧。感谢各位看官老爷们~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;利用一天时间搭一个简单漂亮的静态博客，平时记记笔记、写写文章，日积月累，收获也许会让你意想不到。&lt;br&gt;
    
    </summary>
    
      <category term="code" scheme="http://derekz.cn/categories/code/"/>
    
    
      <category term="hexo" scheme="http://derekz.cn/tags/hexo/"/>
    
  </entry>
  
</feed>
