<!DOCTYPE HTML><html><head><meta charset="utf-8"><title>js-es6 异步篇 | DZ&#39;s Gensokyo | Best Time, Best You and Me</title><meta name="author" content="Derek Zhou"><meta name="description" content="life are flashes and here is my life"><meta name="keywords" content="js"><meta id="viewport" name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,minimal-ui"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta property="og:title" content="js-es6 异步篇"><meta property="og:site_name" content="DZ&#39;s Gensokyo"><meta property="og:image" content="/favicon.ico"><link href="/favicon.ico" rel="icon"><link rel="alternate" href="/atom.xml" title="DZ&#39;s Gensokyo" type="application/atom+xml"><link rel="stylesheet" href="/css/style.css" media="screen" type="text/css"></head><body><div class="blog"><div class="content"><header><div class="site-branding"><h1 class="site-title"><a href="/">DZ&#39;s Gensokyo</a></h1><p class="site-description">Best Time, Best You and Me</p></div><nav class="site-navigation"><ul><li><a href="/">主页</a></li><li><a href="/archives">归档</a></li></ul></nav></header><main class="site-main posts-loop"><article><h3 class="article-title"><span>js-es6 异步篇</span></h3><div class="article-top-meta"><span class="posted-on"><a href="/posts/7819203f/" rel="bookmark"><time class="entry-date published" datetime="2017-11-07T05:41:34.000Z">2017-11-07</time></a></span></div><div class="article-content"><div class="entry"><p>&emsp;&emsp;承上一篇，本文记录了es6的Promise对象、Generator函数和async await语法糖，异步真是让人又爱又恨。<br><a id="more"></a></p><h2 id="lesson1-Promise"><a href="#lesson1-Promise" class="headerlink" title="lesson1 Promise"></a>lesson1 Promise</h2><h3 id="你的名字"><a href="#你的名字" class="headerlink" title="你的名字"></a>你的名字</h3><ul><li><code>Promise</code> 诞于社区，初为异步编程之解决方案，后有ES6将其写入语言标准，终成今人所言之 <code>Promise</code> 对象<ul><li>Promise对象特点有二：状态不受外界影响、一旦状态改变后不会再次改变</li></ul></li></ul><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ul><li><p>Promise对象为一个构造函数，用于生成Promise实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接受一个函数作为参数，函数参数有两个，为js引擎内部实现的两个函数</span></span><br><span class="line"><span class="keyword">let</span> pr = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> () &#123;</span><br><span class="line">    resolve() <span class="comment">// pending -&gt; resolved</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject() <span class="comment">// pending -&gt; rejected</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>Promise实例生成后可以使用then方法指定两种状态下的回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二个函数可选</span></span><br><span class="line">pr.then( <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// throw error</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>so…<br>封装一个函数，返回一个Promise对象，在Promise实例创建时传入的函数参数内进行逻辑处理（决定何时改变状态并传递值到回调函数）<br>利用Promise实例的then方法接收上一步的传递值处理后续（resolve传递的值可以为Promise对象，reject传递的值多为Error对象）</p><ul><li>注意：resolve或reject并不会终结 Promise 的参数函数的执行，因为立即resolve或reject的Promise是在本次时间循环尾部，晚于本轮的同步任务</li><li>注意：一般resolve或者reject之后Promise任务完成了，后续应该写在then的回调函数内，所以可以这样<code>return resolve(value)</code></li></ul></li></ul><h3 id="我愚蠢的孩子们"><a href="#我愚蠢的孩子们" class="headerlink" title="我愚蠢的孩子们"></a>我愚蠢的孩子们</h3><h4 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then"></a>Promise.prototype.then</h4><ul><li><p>参数：两个函数，后一个可选</p></li><li><p>返回：新的Promise实例<br>可以采用链式写法，上一个回调函数的返回值会作为参数传递到下一个回调函数内<br>若上一个回调函数返回的是Promise则需要等状态改变再调用下一个回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">"/post/1.json"</span>).then(</span><br><span class="line">  <span class="comment">// 返回的是一个Promise，其状态改变后根据状态选择调用下面的then中的哪个回调函数</span></span><br><span class="line">  post =&gt; getJSON(post.commentURL)</span><br><span class="line">).then(</span><br><span class="line">  comments =&gt; <span class="built_in">console</span>.log(<span class="string">"resolved: "</span>, comments),</span><br><span class="line">  err =&gt; <span class="built_in">console</span>.log(<span class="string">"rejected: "</span>, err)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><h4 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch"></a>Promise.prototype.catch</h4><ul><li>实际上：是<code>.then(null, rejection)</code>的别名</li><li>链式写法最后一个catch可以捕获前面任何一个Promise对象then方法抛出的error</li><li>推荐使用catch，而不是两个回调函数作为参数</li><li>若没有指定错误处理的回调，Promise会吃掉错误，不会退出进程、终止脚本运行</li><li>catch方法里还可以再抛错，再链式catch…</li></ul><h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h4><ul><li>参数： 具有Iterator接口</li><li><p>返回： Promise实例们</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>p1, p2, p3都为fullfilled时p才fullfilled，其中一个rejected则p就rejected<br>如果其中一个Promise实例定义了catch，错误会被自己的catch捕获然后返回一个新的Promise实例，在执行完catch后该实例也resolved，所以不会被外部p的catch捕获到，若没有，当然会被外面捕获到啦</p></li></ul><h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h4><ul><li>概述：同样是多个Promise实例，第一个状态改变的Promise实例会使得p状态跟着改变</li><li>用处🌰：一定时间内获取不到就rejected<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([</span><br><span class="line">  fetch(<span class="string">'/resource-that-may-take-a-while'</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'request timeout'</span>)), <span class="number">5000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">]);</span><br><span class="line">p.then(<span class="function"><span class="params">response</span> =&gt;</span> <span class="built_in">console</span>.log(response));</span><br><span class="line">p.catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error));</span><br></pre></td></tr></table></figure></li></ul><h4 id="Promise-resolve-Promise-reject"><a href="#Promise-resolve-Promise-reject" class="headerlink" title="Promise.resolve/Promise.reject"></a>Promise.resolve/Promise.reject</h4><ul><li><p>嗯</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>)</span><br><span class="line"><span class="comment">// 等价于下面，即生成一个Promise实例，状态为resolved，且将值传给回调函数</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="string">'foo'</span>))</span><br></pre></td></tr></table></figure></li><li><p>情况</p><ul><li>参数为thenable对象，即具有then方法的对象 =&gt;<br>将对象封装为Promise对象，立即执行原对象的then方法，然后在根据状态变化去调用Promise.then的回调函数</li><li>不是thenable对象或者不是对象<br>参见<code>嗯</code></li><li>不传参数，返回一个resolved的Promise对象</li></ul></li><li><p>注意：立即resolve的Promise对象，是在本轮“事件循环”（event loop）的结束时，而不是在下一轮“事件循环”的开始时</p></li><li>注意：Promise.reject(res)有一点不同，在于参数res直接作为rejected的理由，原封不动地被catch</li></ul><h4 id="Promise-done-Promise-finally"><a href="#Promise-done-Promise-finally" class="headerlink" title="Promise.done/Promise.finally"></a>Promise.done/Promise.finally</h4><ul><li>前者表示无论如何都会接收到可能的错误，全局抛出，后者是无论如何都会在最后执行传入的callback<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// done</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.done = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.then(onFulfilled, onRejected)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 抛出一个全局错误</span></span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;, <span class="number">0</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// finally</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.finally = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> P = <span class="keyword">this</span>.constructor;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">    value  =&gt; P.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> value),</span><br><span class="line">    reason =&gt; P.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Promise-try"><a href="#Promise-try" class="headerlink" title="Promise.try"></a>Promise.try</h4><ul><li>提案：模拟try，是异步就异步，是同步就同步，就提提，再说</li></ul><h2 id="lesson2-Generator"><a href="#lesson2-Generator" class="headerlink" title="lesson2 Generator"></a>lesson2 Generator</h2><h3 id="初探"><a href="#初探" class="headerlink" title="初探"></a>初探</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li>一个遍历器生成函数，一个状态机</li><li>调用Generator函数，返回一个遍历器，代表Generator函数的内部指针（此时yield后的表达式不会求值）</li><li>每次调用next方法会执行下一个yield前的语句并且返回一个{value, done}对象，其中value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值，done属性是一个布尔值，表示是否遍历结束</li><li>若没有yield了，next执行到函数结束，并将return结果作为value返回，若无return则为undefined。</li><li>这之后调用next将返回{value: undefined, done: true}</li></ul><h4 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h4><ul><li><p>惰性<br>调用next方法时，将yield后的表达式的值作为value返回，只有下次再调用next才会执行这之后的语句，达到了暂停执行的效果，相当于具备了一个惰性求值的功能</p></li><li><p>没有yield时，Generator函数为一个单纯的暂缓执行函数（需要调用next执行）</p></li><li>yield只能用于Generator函数</li></ul><h4 id="Iterator接口"><a href="#Iterator接口" class="headerlink" title="Iterator接口"></a>Iterator接口</h4><ul><li>Generator函数为遍历器生成函数，可以赋给对象的Symbol.iterator方法，本身也具有Symbol.iterator属性<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line">g[<span class="built_in">Symbol</span>.iterator]() === g</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h4><ul><li>Generator函数返回的是遍历器对象，可以直接用for…of访问</li><li>注意：done为true的会被for…of忽略</li><li>利用Generator为对象实现Iterator接口<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">objectEntries</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> propKeys = <span class="built_in">Object</span>.keys(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> propKey <span class="keyword">of</span> propKeys) &#123;</span><br><span class="line">    <span class="keyword">yield</span> [propKey, <span class="keyword">this</span>[propKey]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> jane = &#123; <span class="attr">first</span>: <span class="string">'Jane'</span>, <span class="attr">last</span>: <span class="string">'Doe'</span> &#125;;</span><br><span class="line">jane[<span class="built_in">Symbol</span>.iterator] = objectEntries;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> jane) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first: Jane</span></span><br><span class="line"><span class="comment">// last: Doe</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="Generator-prototype-next"><a href="#Generator-prototype-next" class="headerlink" title="Generator.prototype.next()"></a><code>Generator.prototype.next()</code></h4><ul><li>参数<br>通过传入参数为Generator函数内部注入不同的值来调整函数接下来的行为<br>第一次next传递的参数会被忽略（实在想传得包一层）<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里利用参数实现了重置</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; <span class="literal">true</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> reset = <span class="keyword">yield</span> i;</span><br><span class="line">    <span class="keyword">if</span>(reset) &#123; i = <span class="number">-1</span>; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = f();</span><br><span class="line">g.next() <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br><span class="line">g.next() <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="comment">// 传递的参数会被赋值给i（yield后的表达式的值(i)），然后执行var reset = i赋值给reset</span></span><br><span class="line">g.next(<span class="literal">true</span>) <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="Generator-prototype-throw"><a href="#Generator-prototype-throw" class="headerlink" title="Generator.prototype.throw()"></a><code>Generator.prototype.throw()</code></h4><ul><li>Generator函数返回的对象都具有throw方法，用于在函数体外抛出错误，在函数体内可以捕获（只能catch一次）</li><li>参数可以为Error对象</li><li>如果函数体内没有部署try…catch代码块，那么throw抛出的错会被外部try…catch代码块捕获，如果外部也没有，则程序报错，中断执行</li><li>throw方法被内部catch以后附带执行一次next</li><li>函数内部的error可以被外部catch</li><li>如果Generator执行过程中内部抛错，且没被内部catch，则不会再执行下去了，下次调用next会视为该Generator已运行结束</li><li>Generator函数返回的对象在被next访问完后内部属性<code>[[GeneratorStatus]]</code>值变为’closed’了</li></ul><h4 id="Generator-prototype-return"><a href="#Generator-prototype-return" class="headerlink" title="Generator.prototype.return()"></a><code>Generator.prototype.return()</code></h4><ul><li><code>try ... finally</code>存在时，return会在finally执行完后执行，最后的返回结果是return方法的参数，这之后Generator运行结束，下次访问会得到{value: undefined, done: true}</li><li><code>try ... finally</code>不存在时，直接执行return，后续和上一条一致</li></ul><h4 id="实际上"><a href="#实际上" class="headerlink" title="实际上"></a>实际上</h4><ul><li>以上三种方法都是让Generator恢复执行，并用语句替换yield表达式</li></ul><h3 id="yield-表达式"><a href="#yield-表达式" class="headerlink" title="yield*表达式"></a><code>yield*</code>表达式</h3><ul><li><p>在一个Generator内部直接调用另一个Generator是没用的，如果需要在一个Generator内部yield另一个Generator对象的成员，则需要使用<code>yield*</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'a'</span></span><br><span class="line">  <span class="comment">// yield outer() // 返回一个遍历器对象</span></span><br><span class="line">  <span class="keyword">yield</span>* outer() <span class="comment">// 返回一个遍历器对象的内部值</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'d'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'b'</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'c'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> s = inner()</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125; <span class="comment">// a b c d</span></span><br></pre></td></tr></table></figure></li><li><p><code>yield*</code>后跟一个遍历器对象（所有实现了iterator的数据结构实际上都可以被<code>yield*</code>遍历）</p></li><li><p>被代理的Generator函数如果有return，return的值会被for…of忽略，所以next不会返回，但是实际上可以向外部Generetor内部返回一个值，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"foo"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> v = <span class="keyword">yield</span> *foo();</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">"v: "</span> + v );</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> it = bar();</span><br><span class="line">it.next()</span><br><span class="line"><span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">it.next()</span><br><span class="line"><span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line">it.next()</span><br><span class="line"><span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line">it.next();</span><br><span class="line"><span class="comment">// "v: foo"</span></span><br><span class="line"><span class="comment">// &#123;value: 4, done: false&#125;</span></span><br><span class="line">it.next()</span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>举个🌰</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理嵌套数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">Tree</span>(<span class="params">tree</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(tree))&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;tree.length;i++) &#123;</span><br><span class="line">      <span class="keyword">yield</span>* Tree(tree[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> tree</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> ss = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],<span class="number">6</span>,[<span class="number">7</span>]]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> Tree(ss)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125; <span class="comment">// 1 2 3 4 5 6 7</span></span><br><span class="line"><span class="comment">// 理解for ...of 实际上是一个while循环</span></span><br><span class="line"><span class="keyword">var</span> it = iterateJobs(jobs);</span><br><span class="line"><span class="keyword">var</span> res = it.next();</span><br><span class="line"><span class="keyword">while</span> (!res.done)&#123;</span><br><span class="line">  <span class="keyword">var</span> result = res.value;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  res = it.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><h4 id="作为对象的属性的Generator函数"><a href="#作为对象的属性的Generator函数" class="headerlink" title="作为对象的属性的Generator函数"></a>作为对象的属性的Generator函数</h4><ul><li>写法很清奇<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  * sss() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = =&#123;</span><br><span class="line">  sss: <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Generator函数的this"><a href="#Generator函数的this" class="headerlink" title="Generator函数的this"></a>Generator函数的this</h4><ul><li><p>Generator函数返回的是遍历器对象，会继承prototype的方法，但是由于返回的不是this，所以会出现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">ss</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f = ss()</span><br><span class="line">f.a <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li><li><p>想要在内部的this绑定遍历器对象？js灵活特性尽显…</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">ss</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="keyword">this</span>.b = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="keyword">this</span>.c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f = ss.call(ss.prototype) <span class="comment">// 由于f.__proto__ === ss.prototype，传入遍历器对象的隐藏原型给this</span></span><br><span class="line">f.next()</span><br><span class="line">f.next()</span><br><span class="line">f.a <span class="comment">// 1</span></span><br><span class="line">f.b <span class="comment">// 2</span></span><br><span class="line">f.c <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ul><li><p>举个🌰</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用暂停状态的特性</span></span><br><span class="line"><span class="keyword">let</span> clock = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'tick'</span>)</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'tock'</span>)</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>异步操作的同步化表达</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Generator函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">yield</span> request(<span class="string">"http://some.url"</span>);</span><br><span class="line">  <span class="keyword">var</span> resp = <span class="built_in">JSON</span>.parse(result);</span><br><span class="line">    <span class="built_in">console</span>.log(resp.value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ajax请求函数，回调函数中要将response传给next方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  makeAjaxCall(url, <span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">    it.next(response);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 需要第一次执行next方法，返回yield后的表达式，触发异步请求，跳到request函数中执行</span></span><br><span class="line"><span class="keyword">var</span> it = main();</span><br><span class="line">it.next();</span><br></pre></td></tr></table></figure></li><li><p>控制流管理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步steps</span></span><br><span class="line"><span class="keyword">let</span> steps = [step1Func, step2Func, step3Func];</span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">iterateSteps</span>(<span class="params">steps</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt; steps.length; i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> step = steps[i];</span><br><span class="line">    <span class="keyword">yield</span> step();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 异步后续讨论</span></span><br></pre></td></tr></table></figure></li><li><p>部署Iterator接口</p></li><li>看做数组结构使用</li></ul><h2 id="lesson3-Generator的异步应用"><a href="#lesson3-Generator的异步应用" class="headerlink" title="lesson3 Generator的异步应用"></a>lesson3 Generator的异步应用</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><ul><li>一个任务拆分成两个阶段，比如任务是读取一个文件并返回一个结果a。拆分为向操作系统发起请求，然后执行别的操作，再在操作系统返回文件以后去返回一个结果a。不连续的执行，称为异步</li></ul><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><ul><li>传统的异步实现是通过将第二阶段的操作以函数形式作为参数传递到任务处理方法内，在第一阶段的执行有了结果以后，回调函数才会执行</li><li>node约定，回调函数的第一个参数必须为错误对象，因为第一阶段执行完后，任务得上下文环境结束了。这之后抛出的错误需要传入回调函数才能被捕获处理</li><li>Promise其实只是写法上的区别，依然是以回调函数的方式实现异步</li></ul><h4 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h4><ul><li><p>协程coroutine<br>协程A执行-&gt;协程A暂停，执行权转交给协程B-&gt;一段时间后执行权交还A-&gt;A恢复执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// yield是异步两个阶段的分割线</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">asyncJob</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...其他代码</span></span><br><span class="line">  <span class="keyword">var</span> f = <span class="keyword">yield</span> readFile(fileA);</span><br><span class="line">  <span class="comment">// ...其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Generator函数实现协程<br>Generator函数实际上可以作为异步任务的容器，在异步任务需要暂停的地方加上yield注明即可</p></li><li><p>Generator函数的错误处理和数据交换<br>next方法使得Generator可以接收外部参数，next返回值的value属性是Generator向外的输出值（数据交换实现）<br>错误处理上一课有讲述</p></li></ul><h3 id="Thunk函数"><a href="#Thunk函数" class="headerlink" title="Thunk函数"></a>Thunk函数</h3><h4 id="参数的求值策略"><a href="#参数的求值策略" class="headerlink" title="参数的求值策略"></a>参数的求值策略</h4><ul><li>传名调用和传值调用之争</li><li>后者更简单，但是可能会有需要大量计算求值却没有用到这个参数的情况，造成性能损失</li></ul><h4 id="js中的Thunk函数"><a href="#js中的Thunk函数" class="headerlink" title="js中的Thunk函数"></a>js中的Thunk函数</h4><ul><li>传统的Thunk函数是传名调用的一种实现，即将参数作为一个临时函数的返回值，在需要用到参数的地方对临时函数进行求值</li><li><p>js中的Thunk函数略有不同<br>js中的Thunk函数是将多参数函数替换为单参数函数（这个参数为回调函数）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Thunk = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> fn.call(<span class="keyword">this</span>, ...args, callback);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看起来只是换了个样子，好像并没有什么用</p></li></ul><h4 id="Thunk函数实现Generator函数自动执行"><a href="#Thunk函数实现Generator函数自动执行" class="headerlink" title="Thunk函数实现Generator函数自动执行"></a>Thunk函数实现Generator函数自动执行</h4><ul><li><p>Generator函数自动执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> a <span class="comment">// 表达式a</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g = gen()</span><br><span class="line"><span class="keyword">let</span> res = g.next()</span><br><span class="line"><span class="keyword">while</span>(!res.done) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res.value)</span><br><span class="line">  res = g.next() <span class="comment">// 表达式b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>但是，这不适合异步操作。如果必须保证前一步执行完，才能执行后一步，上面的自动执行就不可行。<br><del>上面这句话是不是可以这样理解，比如表达式a是一个异步操作，回调函数中设置了延时执行，而这个回调函数执行前表达式b可能已经被执行了，进入到下一个循环。所以无法保证执行顺序，所以需要管理回调函数</del><br>next方法是同步的，执行时必须立刻返回值，yield后是同步操作当然没问题，是异步操作时就不可以了。处理方式就是返回一个Thunk函数或者Promise对象。此时value值为该函数/对象，done值还是按规矩办事。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"><span class="keyword">var</span> r1 = g.next();</span><br><span class="line"><span class="comment">// 重复传入一个回调函数</span></span><br><span class="line">r1.value(<span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="keyword">var</span> r2 = g.next(data);</span><br><span class="line">  r2.value(<span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    g.next(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></blockquote></li><li><p>Thunk函数的自动流程管理<br>思路：Generator函数中yield 异步Thunk函数，通过yield将控制权转交给Thunk函数，然后在Thunk函数的回调函数中调用Generator的next方法，将控制权交回给Generator。此时，异步操作确保完成，开启下一个任务。<br>Generator是一个异步操作的容器，实现自动执行需要一个机制，这个机制的关键是控制权的交替，在异步操作有了结果以后自动交回控制权，而回调函数执行正是这么个时间点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Generator函数的执行器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> gen = fn()</span><br><span class="line">  <span class="comment">// 传给Thunk函数的回调函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">cb</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 控制权交给Generator，获取下一个yield表达式（异步任务）</span></span><br><span class="line">    <span class="keyword">let</span> result = gen.next(data)</span><br><span class="line">    <span class="comment">// 没任务了，返回</span></span><br><span class="line">    <span class="keyword">if</span> (result.done) <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// 控制权交给Thunk函数，传入回调</span></span><br><span class="line">    result.value(cb)</span><br><span class="line">  &#125;</span><br><span class="line">  cb()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Generator函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> f1 = <span class="keyword">yield</span> readFileThunk(<span class="string">'/a'</span>)</span><br><span class="line">  <span class="keyword">let</span> f2 = <span class="keyword">yield</span> readFileThunk(<span class="string">'/b'</span>)</span><br><span class="line">  <span class="keyword">let</span> f3 = <span class="keyword">yield</span> readFileThunk(<span class="string">'/c'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Thunk函数readFileThunk</span></span><br><span class="line"><span class="keyword">const</span> Thunk = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> fn.call(<span class="keyword">this</span>, ...args, callback);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> readFileThunk = Thunk(fs.readFile);</span><br><span class="line">readFileThunk(fileA)(callback);</span><br><span class="line"><span class="comment">// 自动执行</span></span><br><span class="line">run(g)</span><br></pre></td></tr></table></figure></li></ul><h3 id="co模块"><a href="#co模块" class="headerlink" title="co模块"></a>co模块</h3><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul><li>不用手写上述的执行器，co模块其实就是将基于Thunk函数和Promise对象的两种自动Generator执行器包装成一个模块</li><li>使用条件：yield后只能为Thunk函数或Promise对象或Promise对象数组</li></ul><h4 id="基于Promise的执行器"><a href="#基于Promise的执行器" class="headerlink" title="基于Promise的执行器"></a>基于Promise的执行器</h4><ul><li>实现<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> gen = fn()</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">cb</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 将上一个任务返回的data作为参数传给next方法，控制权交回到Generator</span></span><br><span class="line">    <span class="comment">//这里将result变量引用&#123;value, done&#125;对象，不要和Generator中的`let result = yield xxx`搞混</span></span><br><span class="line">    <span class="keyword">let</span> result = gen.next(data)</span><br><span class="line">    <span class="keyword">if</span> (result.done) <span class="keyword">return</span> result.value</span><br><span class="line">    result.value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">      <span class="comment">// resolved之后会执行cb(data)，开启下一次循环，实现自动执行</span></span><br><span class="line">      cb(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  cb()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><ul><li><p>其实和上面的实现类似</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> args = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>) <span class="comment">// 除第一个参数外的所有参数</span></span><br><span class="line">  <span class="comment">// 返回一个Promise对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果是Generator函数，执行获取遍历器对象gen</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> gen === <span class="string">'function'</span>) gen = gen.apply(ctx, args);</span><br><span class="line">    <span class="keyword">if</span> (!gen || <span class="keyword">typeof</span> gen.next !== <span class="string">'function'</span>) <span class="keyword">return</span> resolve(gen);</span><br><span class="line">    <span class="comment">// 第一次执行遍历器对象gen的next方法获取第一个任务</span></span><br><span class="line">    onFulfilled();</span><br><span class="line">    <span class="comment">// 每次异步任务执行完，resolved以后会调用，控制权又交还给Generator</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onFulfilled</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> ret;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        ret = gen.next(res); <span class="comment">// 获取&#123;value,done&#125;对象，控制权在这里暂时交给异步任务，执行yield后的异步任务</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">      next(ret); <span class="comment">// 进入next方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 同理可得</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> ret;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        ret = gen.throw(err);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">      next(ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关键</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">ret</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 遍历执行完异步任务后，置为resolved，并将最后value值返回</span></span><br><span class="line">      <span class="keyword">if</span> (ret.done) <span class="keyword">return</span> resolve(ret.value);</span><br><span class="line">      <span class="comment">// 获取下一个异步任务，并转为Promise对象</span></span><br><span class="line">      <span class="keyword">var</span> value = toPromise.call(ctx, ret.value);</span><br><span class="line">      <span class="comment">// 异步任务结束后会调用onFulfilled方法（在这里为yield后的异步任务设置then的回调参数）</span></span><br><span class="line">      <span class="keyword">if</span> (value &amp;&amp; isPromise(value)) <span class="keyword">return</span> value.then(onFulfilled, onRejected);</span><br><span class="line">      <span class="keyword">return</span> onRejected(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'You may only yield a function, promise, generator, array, or object, '</span></span><br><span class="line">        + <span class="string">'but the following object was passed: "'</span> + <span class="built_in">String</span>(ret.value) + <span class="string">'"'</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实还是一样，为Promise对象then方法指定回调函数，在异步任务完成后出发回调函数，在回调函数中执行Generator的next方法，进入下一个异步任务，实现自动执行。<br>举个🌰</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> co =<span class="built_in">require</span>(<span class="string">'co'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    fs.readFile(filename, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, res</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(err);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> resolve(res);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">co(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">yield</span> read(<span class="string">'./a.js'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>处理并发的异步操作<br>把并发操作放数组/对象中放yield后面</p></li></ul><h2 id="lesson4-async函数"><a href="#lesson4-async函数" class="headerlink" title="lesson4 async函数"></a>lesson4 async函数</h2><h3 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h3><ul><li><p>比较</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">asyncReadFile</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> asyncReadFile = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">await</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">await</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看起来只是写法的替换，实际上有这样的区别</p><ul><li>async函数内置执行器，不需要手动执行next方法，不需要引入co模块</li><li>async适用更广，co模块对yield后的内容严格限制为Thunk函数或Promise对象，而await后可以是Promise对象或原始类型值</li><li>返回Promise，这点和co比较像</li></ul></li><li><p>用法</p><ul><li>async标识该函数内部有异步操作</li><li>由于async函数返回的是Promise，所以可以将async函数作为await命令的参数</li><li>async函数可以使用在函数、方法适用的许多场景</li></ul></li></ul><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="返回的Promise"><a href="#返回的Promise" class="headerlink" title="返回的Promise"></a>返回的Promise</h4><ul><li>async函数只有在所有await后的Promise执行完以后才会改变返回的Promise对象的状态（return或者抛错除外）即只有在内部操作完成以后才会执行then方法</li><li>async函数内部return的值会作为返回的Promise的then方法回调函数的参数</li><li>async函数内部抛出的错误会使得返回的Promise变成rejected状态，同时错误会被catch捕获</li></ul><h4 id="async命令及其后的Promise"><a href="#async命令及其后的Promise" class="headerlink" title="async命令及其后的Promise"></a>async命令及其后的Promise</h4><ul><li>async命令后如果不是一个Promise对象，则会被转成一个resolved的Promise</li><li>async命令后的Promise如果抛错了变成rejected状态或者直接rejected了，都会使得async函数的执行中断，错误可以被then方法的回调函数catch到</li><li>如果希望async的一个await Promise不影响到其他的await Promise，可以将这个await Promise放到一个try…catch代码块中，这样后面的依然会正常执行，也可以将多个await Promise放在一个try…catch代码块中，此外还可以加上错误重试</li></ul><h4 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h4><ul><li><p>相互独立的异步任务可以改造下让其并发执行（Promise.all）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo, bar] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([getFoo(), getBar()]);</span><br><span class="line"><span class="comment">// 听说下面这种也可以？</span></span><br><span class="line"><span class="keyword">let</span> fooPromise = getFoo();</span><br><span class="line"><span class="keyword">let</span> barPromise = getBar();</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> fooPromise;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> barPromise;</span><br></pre></td></tr></table></figure></li><li><p>forEach</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">forEach(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> m = <span class="keyword">await</span> pro</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这种写法可能不能正常工作，因为forEach时的若干个操作是并行的，应改为for循环</p></li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul><li>其实就是将执行器和Generator函数封装在一起，详见上一课</li></ul><h3 id="举举🌰"><a href="#举举🌰" class="headerlink" title="举举🌰"></a>举举🌰</h3><ul><li>并发请求，顺序输出<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">logInOrder</span>(<span class="params">urls</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 并发读取远程URL</span></span><br><span class="line">  <span class="keyword">const</span> textPromises = urls.map(<span class="keyword">async</span> url =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(url);</span><br><span class="line">    <span class="keyword">return</span> response.text();</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 按次序输出</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> textPromise <span class="keyword">of</span> textPromises) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> textPromise);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="异步遍历器"><a href="#异步遍历器" class="headerlink" title="异步遍历器"></a>异步遍历器</h3><h4 id="回到过去"><a href="#回到过去" class="headerlink" title="回到过去"></a>回到过去</h4><ul><li>Generator的next方法是同步的，需要立即返回结果，所以在处理异步操作时我们返回的实际上是{value: Promise, done: false}类似这样的对象。理解没错的话Promise对象创建时传入的函数会立即执行，异步操作例如读取文件请求就开始了。而后我们为这个Promise对象指定then方法的参数回调函数去接收异步操作完成的信号，然后在回调函数中再次调用next获取下一个{value: Promise, done: false}</li><li>提案：为异步操作提供原生的遍历器接口，使得value和done值都可以异步返回，称为异步遍历器</li></ul><h4 id="more"><a href="#more" class="headerlink" title="more"></a>more</h4><ul><li>累了，困了，不开心看了，下次再补充</li></ul></div></div><div class="article-footer"><div class="article-meta pull-left"><span class="post-categories"><i class="icon-categories"></i> <a href="/categories/code/">code</a> </span><span class="post-tags"><i class="icon-tags"></i> <a href="/tags/js/">js</a></span></div></div></article></main><footer class="site-footer"><p class="site-info">Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a><br>&copy; 2018 Derek Zhou</p></footer></div></div></body></html>