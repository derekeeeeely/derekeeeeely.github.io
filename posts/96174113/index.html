<!DOCTYPE HTML><html><head><meta charset="utf-8"><title>js-es6 基础篇 | DZ&#39;s Gensokyo | Best Time, Best You and Me</title><meta name="author" content="Derek Zhou"><meta name="description" content="life are flashes and here is my life"><meta name="keywords" content="js"><meta id="viewport" name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,minimal-ui"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta property="og:title" content="js-es6 基础篇"><meta property="og:site_name" content="DZ&#39;s Gensokyo"><meta property="og:image" content="/favicon.ico"><link href="/favicon.ico" rel="icon"><link rel="alternate" href="/atom.xml" title="DZ&#39;s Gensokyo" type="application/atom+xml"><link rel="stylesheet" href="/css/style.css" media="screen" type="text/css"></head><body><div class="blog"><div class="content"><header><div class="site-branding"><h1 class="site-title"><a href="/">DZ&#39;s Gensokyo</a></h1><p class="site-description">Best Time, Best You and Me</p></div><nav class="site-navigation"><ul><li><a href="/">主页</a></li><li><a href="/archives">归档</a></li><li><a href="/tags">标签</a></li><li><a href="/about">关于</a></li></ul></nav></header><main class="site-main posts-loop"><article><h3 class="article-title"><span>js-es6 基础篇</span></h3><div class="article-top-meta"><span class="posted-on"><a href="/posts/96174113/" rel="bookmark"><time class="entry-date published" datetime="2017-10-30T18:17:11.000Z">2017-10-31</time></a></span></div><div class="article-content"><div class="entry"><p>&emsp;&emsp;大佬们es7, es8写得嗨皮的时候，我却还在es6学习…本文为阅读阮一峰老师的系列文章记下的es6基础篇笔记。<br><a id="more"></a></p><h2 id="lesson1-introduce"><a href="#lesson1-introduce" class="headerlink" title="lesson1 introduce"></a>lesson1 introduce</h2><h3 id="新的语法成为标准的过程"><a href="#新的语法成为标准的过程" class="headerlink" title="新的语法成为标准的过程"></a>新的语法成为标准的过程</h3><ul><li>stage<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stage 0 - Strawman（展示阶段）</span><br><span class="line">Stage 1 - Proposal（征求意见阶段）</span><br><span class="line">Stage 2 - Draft（草案阶段）</span><br><span class="line">Stage 3 - Candidate（候选人阶段）</span><br><span class="line">Stage 4 - Finished（定案阶段）</span><br></pre></td></tr></table></figure></li></ul><h3 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h3><ul><li><p>.babelrc</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev babel-preset-latest</span><br><span class="line">&#123;</span><br><span class="line">    presets: [</span><br><span class="line">        <span class="string">"latest"</span>,</span><br><span class="line">        <span class="string">"react"</span>,</span><br><span class="line">        <span class="string">"stage-2"</span></span><br><span class="line">    ],</span><br><span class="line">    plugins: []</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># presets的值集有latest，react，stage-0 to stage-3（对应不同阶段的提案，选择一个）</span></span><br></pre></td></tr></table></figure></li><li><p>babel-cli</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -s生成sourcemap，-o指定文件，-d指定目录</span></span><br><span class="line">babel example.js -o compiled.js -s</span><br><span class="line"><span class="comment"># babel-node提供支持ES6的REPL环境，目标文件不需要考虑转码</span></span><br><span class="line">babel-node es6.js</span><br></pre></td></tr></table></figure></li><li><p>babel-register</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">提供一个钩子，在require加载`.js`, `.jsx`, `.es`, `.es6`后缀的文件时先用babel实时转码，需在require别的文件前先require该模块</span><br><span class="line">require(<span class="string">"babel-register"</span>);</span><br><span class="line">require(<span class="string">"./index.js"</span>);</span><br></pre></td></tr></table></figure></li><li><p>babel-core</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">需要调用babel的api时，需要require该模块</span><br><span class="line">var babel = require(<span class="string">'babel-core'</span>);</span><br><span class="line">// 字符串转码</span><br><span class="line">babel.transform(<span class="string">'code();'</span>, options);</span><br></pre></td></tr></table></figure></li><li><p>babel-polyfill</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">默认情况下babel只转句法，不转一些es6新的对象以及方法，这种情况下需要在脚本头部引入该模块转换使其可用</span><br><span class="line">import <span class="string">'babel-polyfill'</span>;</span><br></pre></td></tr></table></figure></li><li><p>Traceur</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">google提供的babel替代品</span><br></pre></td></tr></table></figure></li></ul><h2 id="lesson2-let-const"><a href="#lesson2-let-const" class="headerlink" title="lesson2 let/const"></a>lesson2 let/const</h2><h3 id="TDZ"><a href="#TDZ" class="headerlink" title="TDZ"></a>TDZ</h3><p>只在声明的块级作用域域内有效、不可重复声明、TDZ</p><ul><li><p>循环体和循环条件中的i有单独的作用域</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="string">'abc'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">//输出3次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>TDZ</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在该区域内let/const定义的变量，只有等到声明以后才可以获取/使用</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// TDZ开始</span></span><br><span class="line">  tmp = <span class="string">'abc'</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">let</span> tmp; <span class="comment">// TDZ结束</span></span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// undefined</span></span><br><span class="line">  tmp = <span class="number">123</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// 123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：带来的问题是typeof不再绝对安全</p></blockquote></li></ul><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><ul><li><p>没有块级作用域的问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 场景1</span></span><br><span class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(tmp);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = <span class="string">'hello world'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">f(); <span class="comment">// undefined因为变量提升，所以在函数执行的上下文中找到了tmp的定义，但是没有完成赋值，所以是undefined</span></span><br><span class="line"><span class="comment">// 场景2 典型的for循环将i变成了全局变量</span></span><br></pre></td></tr></table></figure></li><li><p>块级作用域</p><ul><li>告别丑陋的IIFE</li><li><p>对于es6的浏览器环境还说，函数声明类似于var，可以理解成先函数变量提升<code>var f = undefined</code>，然后再继续后面，所以以下代码是会报错的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am outside!'</span>); &#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="comment">// 重复声明一次函数f</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am inside!'</span>); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f();</span><br><span class="line">&#125;());</span><br><span class="line"><span class="comment">// Uncaught TypeError: f is not a function</span></span><br></pre></td></tr></table></figure></li><li><p>do提案</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在代码块前加<span class="keyword">do</span>，返回最后执行表达式的值</span><br><span class="line"><span class="keyword">let</span> x = <span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> t = f();</span><br><span class="line">  t * t + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><ul><li><p>freeze<br>对于复杂类型变量，const保证的是指向该变量的内存空间的地址是不变的，变量若是可写的是可以修改变量的属性值的。<br>要想冻结变量，需使用<code>Object.freeze()</code>冻结对象及对象所有属性，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> constantize = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">Object</span>.freeze(obj);</span><br><span class="line">    <span class="built_in">Object</span>.keys(obj).forEach( <span class="function">(<span class="params">key, i</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="keyword">typeof</span> obj[key] === <span class="string">'object'</span> ) &#123;</span><br><span class="line">        constantize( obj[key] );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>var function let const class<br>前两者声明的全局变量依然是顶层对象（window/global）的属性，后三者不再是，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩</p></li></ul><h3 id="提案"><a href="#提案" class="headerlink" title="提案"></a>提案</h3><ul><li>考虑到不同环境下顶层对象不同，提案在语言标准层面引入<code>global</code>对象作为顶层对象，即所有环境下global对象都是存在的，如下<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将顶层对象放入变量global中</span></span><br><span class="line"><span class="comment">// CommonJS 的写法</span></span><br><span class="line"><span class="keyword">var</span> global = <span class="built_in">require</span>(<span class="string">'system.global'</span>)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 模块的写法</span></span><br><span class="line"><span class="keyword">import</span> getGlobal <span class="keyword">from</span> <span class="string">'system.global'</span>;</span><br><span class="line"><span class="keyword">const</span> global = getGlobal();</span><br></pre></td></tr></table></figure></li></ul><h2 id="lesson3-解构"><a href="#lesson3-解构" class="headerlink" title="lesson3 解构"></a>lesson3 解构</h2><h3 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h3><ul><li><p>数组解构的本质是<code>模式匹配</code>，只要某种数据结构具有<code>Iterator</code>接口，就都可以采用数组形式解构。egs: Array, Set, Generator.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解构赋值设置默认值是根据右侧是否===undefined来决定右侧是否有值，有则覆盖默认值</span></span><br><span class="line"><span class="keyword">let</span> [i = <span class="number">1</span>] = [] <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">let</span> [i = <span class="number">1</span>] = [<span class="literal">undefined</span>] <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">let</span> [i = <span class="number">1</span>] = [<span class="literal">null</span>] <span class="comment">// null</span></span><br><span class="line"><span class="comment">// 下例可以看出默认值先设置，再进行解构赋值</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// x=1; y=2</span></span><br></pre></td></tr></table></figure><blockquote><p><code>[a, b, c] = arr</code> equals <code>a = arr[0] b = arr[1]</code></p></blockquote></li></ul><h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h3><ul><li><p>对象的解构赋值需要变量与对象属性名相同，本质是先找到同名的属性，然后把值赋给对应的变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo是匹配模式，不是变量，sss是被赋值的变量</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: sss, <span class="attr">bar</span>: ddd &#125; = &#123; <span class="attr">foo</span>: <span class="string">"aaa"</span>, <span class="attr">bar</span>: <span class="string">"bbb"</span> &#125;;</span><br><span class="line">foo <span class="comment">// foo is not defined</span></span><br><span class="line">sss <span class="comment">// "aaa"</span></span><br><span class="line"><span class="comment">// 默认值生效的条件是，对象的属性值严格等于undefined，结构失败为undefined</span></span><br><span class="line"><span class="keyword">let</span> &#123; x = <span class="number">2</span> &#125; = &#123; <span class="attr">x</span>: <span class="literal">null</span> &#125;</span><br><span class="line">x<span class="comment">// null</span></span><br><span class="line"><span class="comment">// 如果解构模式是嵌套的对象，父属性不存在时会报错</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">foo</span>: &#123;bar&#125;&#125; = &#123;<span class="attr">baz</span>: <span class="string">'baz'</span>&#125;</span><br><span class="line"><span class="comment">// 理解下面的为三次解构 node.loc node.loc.start node.loc.start.line</span></span><br><span class="line"><span class="keyword">let</span> &#123; loc, <span class="attr">loc</span>: &#123; start &#125;, <span class="attr">loc</span>: &#123; <span class="attr">start</span>: &#123; line &#125;&#125; &#125; = node</span><br></pre></td></tr></table></figure><blockquote><p>原来项目里天天写的<code>const {a, b} = this.state</code>是解构赋值！<br><code>let {a:c, b:d} = obj</code> equals <code>c = obj.a d = obj.b</code></p></blockquote></li></ul><h3 id="字符串、数值、布尔值、null、undefined"><a href="#字符串、数值、布尔值、null、undefined" class="headerlink" title="字符串、数值、布尔值、null、undefined"></a>字符串、数值、布尔值、null、undefined</h3><ul><li><p>如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b,c] = <span class="string">'skt'</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span>: len&#125; = <span class="string">'skt'</span></span><br></pre></td></tr></table></figure></li><li><p>如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等号右边先转为对象再进行解构赋值，故undefined和null会报错</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="number">123</span>;</span><br><span class="line">s === <span class="built_in">Number</span>.prototype.toString <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><ul><li><p>交换变量值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x, y] = [y, x]</span><br></pre></td></tr></table></figure></li><li><p>从函数返回多个值</p></li><li><p>函数参数的定义、默认值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数是一组有次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[x, y, z]</span>) </span>&#123; ... &#125;</span><br><span class="line">f([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="comment">// 参数是一组无次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123;x, y, z&#125;</span>) </span>&#123; ... &#125;</span><br><span class="line">f(&#123;<span class="attr">z</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure></li><li><p>提取JSON数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData;</span><br></pre></td></tr></table></figure></li><li><p>遍历map</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取key、value</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">" is "</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取输入模块的指定方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SourceMapConsumer, SourceNode &#125; = <span class="built_in">require</span>(<span class="string">"source-map"</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="lesson4-字符串扩展"><a href="#lesson4-字符串扩展" class="headerlink" title="lesson4 字符串扩展"></a>lesson4 字符串扩展</h2><ul><li>unicode表示<br>js中，可以用\uxxxx表示字符，xxxx为该字符的Unicode码位。js内部，字符以UTF-16格式存储，即每个字符为2个字节(0x0000-0xFFFF)，对于需要4字节存储的例如汉字，在处理时可能会出现误判。</li><li><p><code>codePointAt</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否为4字节组成</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is32Bit</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> c.codePointAt(<span class="number">0</span>) &gt; <span class="number">0xFFFF</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>String.fromCodePoint</code><br>返回码点对应字符，支持4字节，即32位UTF-16字符</p></li><li>字符串遍历<br><code>for ... of ...</code>遍历字符串，可以做到支持32位UTF-16字符</li><li>提案 <code>at</code><br>charAt返回的是UTF-16字符的前两个字节，提案at可以支持4字节UTF-16字符，需要垫片库支持</li><li><code>include(), startsWith(), endsWith()</code><br>字面理解，注意可以传一个下标参数，表示查找位置</li><li><p><code>repeat(), padStart(5, s = &#39;&#39;), padEnd(5, e = &#39;&#39;)</code><br>padStart填充在前，padEnd填充在后，若原字符串长度大于第一个参数，则不填充返回原字符串，若加起来大于第一个参数则保留原，去除需添加的多余的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'123456'</span>.padStart(<span class="number">10</span>, <span class="string">'0'</span>) <span class="comment">// "0000123456"</span></span><br><span class="line"><span class="string">'12'</span>.padStart(<span class="number">10</span>, <span class="string">'YYYY-MM-DD'</span>) <span class="comment">// "YYYY-MM-12"</span></span><br></pre></td></tr></table></figure></li><li><p>模板字符串</p></li><li><p>标签模板</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> total = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">let</span> msg = passthru<span class="string">`The total is <span class="subst">$&#123;total&#125;</span> (<span class="subst">$&#123;total*<span class="number">1.05</span>&#125;</span> with tax)`</span>;</span><br><span class="line"><span class="comment">// ['The total is ', ' ', ' (', ' with tax)'], 30, 31.5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">passthru</span>(<span class="params">literals, ...values</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> output = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">let</span> index;</span><br><span class="line"><span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; values.length; index++) &#123;</span><br><span class="line">    output += literals[index] + values[index];</span><br><span class="line">&#125;</span><br><span class="line">output += literals[index]</span><br><span class="line"><span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line">msg <span class="comment">// "The total is 30 (31.5 with tax)"</span></span><br></pre></td></tr></table></figure><blockquote><p>过滤字符串</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">let</span> message =</span><br><span class="line">SaferHTML<span class="string">`&lt;p&gt;<span class="subst">$&#123;sender&#125;</span> has sent you a message.&lt;/p&gt;`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">SaferHTML</span>(<span class="params">templateData</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> s = templateData[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> arg = <span class="built_in">String</span>(<span class="built_in">arguments</span>[i]);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Escape special characters in the substitution.</span></span><br><span class="line">      s += arg.replace(<span class="regexp">/&amp;/g</span>, <span class="string">"&amp;amp;"</span>)</span><br><span class="line">              .replace(<span class="regexp">/&lt;/g</span>, <span class="string">"&amp;lt;"</span>)</span><br><span class="line">              .replace(<span class="regexp">/&gt;/g</span>, <span class="string">"&amp;gt;"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Don't escape special characters in the template.</span></span><br><span class="line">      s += templateData[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>其他用途有：i18n、模板处理、引入其他语言等</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面的hashTemplate函数</span></span><br><span class="line"><span class="comment">// 是一个自定义的模板处理函数</span></span><br><span class="line"><span class="keyword">let</span> libraryHtml = hashTemplate<span class="string">`</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string">    #for book in <span class="subst">$&#123;myBooks&#125;</span></span></span><br><span class="line"><span class="string">    &lt;li&gt;&lt;i&gt;#&#123;book.title&#125;&lt;/i&gt; by #&#123;book.author&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="string">    #end</span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="lesson5-数值扩展"><a href="#lesson5-数值扩展" class="headerlink" title="lesson5 数值扩展"></a>lesson5 数值扩展</h2><ul><li>0o/0O 八进制 0b/0B 二进制</li><li><code>Number.isFinite</code> <code>Number.isNaN</code><br>与全局<code>isFinite</code>、<code>isNaN</code>的差别在于前者只对数值有效，非数值一律返回<code>false</code>后者是先将非数值转化为数值再判断。</li><li><code>Number.ParseInt</code> <code>Number.ParseFloat</code> <code>Number.isInteger</code><br>逐步减少全局性方法，使得语言逐步模块化</li><li><code>Number.EPSILON</code> 可以接受的最小误差范围</li><li><p><code>isSafeInteger</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">9007199254740993</span>)</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">990</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">9007199254740993</span> - <span class="number">990</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="number">9007199254740993</span> - <span class="number">990</span></span><br><span class="line"><span class="comment">// 返回结果 9007199254740002</span></span><br><span class="line"><span class="comment">// 正确答案应该是 9007199254740003</span></span><br></pre></td></tr></table></figure><p>9007199254740993不是一个安全整数，但是Number.isSafeInteger会返回结果，显示计算结果是安全的。这是因为，这个数超出了精度范围，导致在计算机内部，以9007199254740992的形式储存</p></li><li>Math对象扩展<ul><li>指数运算符<code>**</code></li><li><code>提案</code> Integer</li></ul></li></ul><h2 id="lesson6-函数扩展"><a href="#lesson6-函数扩展" class="headerlink" title="lesson6 函数扩展"></a>lesson6 函数扩展</h2><h3 id="参数设置默认值、rest参数"><a href="#参数设置默认值、rest参数" class="headerlink" title="参数设置默认值、rest参数"></a>参数设置默认值、rest参数</h3><ul><li>basic</li><li><p>with解构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m1</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m2</span>(<span class="params">&#123;x, y&#125; = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理解二者区别即可，其余可参见<a href="http://www.derekz.cn/posts/78048d04/" target="_blank" rel="noopener">解构</a></p></li><li><p>函数的<code>length</code>属性：未指定默认值的参数个数</p></li><li><p>参数一旦设置了默认值，函数在声明初始化时会形成单独的作用域，初始化结束后释放掉。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m</span>(<span class="params">y=x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">2</span></span><br><span class="line">    <span class="built_in">console</span>.log(y)</span><br><span class="line">&#125;</span><br><span class="line">m()<span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 如果全局x不存在会报错，第二行相当于发生了let y = x, x指向全局的x, 不受内部x影响</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y = function(</span>) </span>&#123; x = <span class="number">2</span>; &#125;) &#123;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line">y();</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 理解：这里有三个作用域，三个x，各不相干 3</span></span><br><span class="line"><span class="comment">// 去掉var以后参数中的两个x和函数体内x是一样的，外部还是不变 2</span></span><br></pre></td></tr></table></figure></li><li><p>应用<br>指定参数必传，否则报错，即给参数赋值一个默认的函数抛错的结果，没传时得到的是这个抛出的错<br>用默认赋值undefined表示该参数可省略</p></li><li>函数的length不包含rest参数</li><li>rest参数之后不能再有参数</li><li>只要参数使用了默认值、解构赋值、或者扩展运算符，就不能显式指定严格模式</li></ul><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><ul><li><p>注意</p><ul><li>箭头函数体内的this指向函数定义时的对象，不是对应运行时的对象</li><li>不可以当做构造函数</li><li>不可以使用yield</li><li>不可以使用arguments</li><li>不可以使用bind、call、apply来改变箭头函数this指向</li></ul></li><li><p>this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> headAndTail = <span class="function">(<span class="params">head, ...tail</span>) =&gt;</span> [head, tail];</span><br><span class="line">headAndTail(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) <span class="comment">// [1,[2,3,4,5]]</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><p>双冒号运算符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj::func === func.bind(obj)</span><br><span class="line">foo::bar(...arguments) === bar.apply(foo, <span class="built_in">arguments</span>)</span><br></pre></td></tr></table></figure></li><li><p>尾调用优化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数f的最后一步为函数g调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> g(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数调用会在内存在生成调用记录，即调用帧，如A函数中调用B函数，则会在A的调用帧上方形成B的调用帧，B调用完后，返回至A才会消失。尾调用实际上已经不用保存外层A的调用帧了，可以优化。<br><strong>只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”</strong></p></li><li><p>尾递归优化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非尾递归</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( n &lt;= <span class="number">1</span> ) &#123;<span class="keyword">return</span> <span class="number">1</span>&#125;;</span><br><span class="line">  <span class="keyword">return</span> Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 尾递归</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci2</span> (<span class="params">n , ac1 = <span class="number">1</span> , ac2 = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>( n &lt;= <span class="number">1</span> ) &#123;<span class="keyword">return</span> ac2&#125;;</span><br><span class="line">  <span class="keyword">return</span> Fibonacci2 (n - <span class="number">1</span>, ac2, ac1 + ac2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">传统递归需要保存相当多的调用帧，尾递归只保存一个，节省内存，避免发生栈溢出</span><br></pre></td></tr></table></figure></li><li><p>柯里化<br>将多参数函数变成单参数形式（具体下次再论）</p></li><li>es2017支持函数最后一个参数尾逗号</li><li>在不需要错误实例的时候，提案try…catch…菜单catch块不需要参数</li></ul><h2 id="lesson7-数组扩展"><a href="#lesson7-数组扩展" class="headerlink" title="lesson7 数组扩展"></a>lesson7 数组扩展</h2><h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><ul><li><code>...</code> 可以理解为rest参数的逆运算，将数组转化为逗号分隔的参数序列，如<code>Math.max(...[14, 3, 77])</code></li><li><p>复制数组（直接赋值是引用，指向相同地址）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// es5</span></span><br><span class="line">a1 = [<span class="number">1</span>,<span class="number">2</span>];    a2 = a1.concat()</span><br><span class="line"><span class="comment">// es6</span></span><br><span class="line">a1 = [<span class="number">1</span>,<span class="number">2</span>];    a2 = [...a1]</span><br></pre></td></tr></table></figure></li><li><p>合并数组</p></li><li><p>与解构结合<br>扩展运算符用于数组赋值时，只能作为最后一个参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, ...b] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure></li><li><p>字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成数组</span></span><br><span class="line">[...<span class="string">'hello'</span>]</span><br><span class="line"><span class="comment">// 返回字符串正确长度，兼容4字节UTF-16编码的Unicode字符</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">length</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> [...str].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现了 Iterator 接口的对象（下回分解）</p></li><li>Map Set Generator（下回分解）</li></ul><h3 id="Array方法"><a href="#Array方法" class="headerlink" title="Array方法"></a>Array方法</h3><ul><li><p><code>Array.from()</code><br>将<code>arraylike</code>对象和可遍历对象转为数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Array.prototype.slice</span></span><br><span class="line"><span class="built_in">Array</span>.from</span><br><span class="line"><span class="comment">// Array.from(arrayLike).map(x =&gt; x * x)</span></span><br><span class="line"><span class="comment">// 接收第二个参数，类似map，可用于如NodeList对象等处理，获取dom节点的属性</span></span><br><span class="line"><span class="built_in">Array</span>.from(arrayLike, x =&gt; x * x)</span><br><span class="line"><span class="built_in">Array</span>.from([<span class="number">1</span>, , <span class="number">2</span>, , <span class="number">3</span>], (n) =&gt; n || <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 第三个参数，可以绑定this</span></span><br></pre></td></tr></table></figure><p><code>...</code>调用的是遍历器接口（<code>Symbol.iterator</code>），若对象没有部署这个接口，就不能转化为数组，<code>Array.from</code>可以转换任何有length属性的对象</p><p>因吹斯听</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="number">2</span> &#125;, () =&gt; <span class="string">'jack'</span>)</span><br><span class="line">效果：第一个参数为第二个参数（函数）指定执行次数</span><br></pre></td></tr></table></figure></li><li><p><code>Array.of</code><br>总是返回参数值组成的数组，如果没有参数，就返回一个空数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 弥补构造函数Array()的不足（1-2个参数时）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArrayOf</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>copyWithin</code> 用途不明</p></li><li><code>find</code> <code>findIndex</code> 前者返回第一个值/<code>undefined</code>，后者返回位置/-1</li><li><code>fill</code> 数组填充，可以指定起始、结束位置</li><li><code>keys()</code> <code>values()</code> <code>entries()</code> 用于遍历数组，返回遍历器对象，可以使用for…of循环也可以手动调用遍历器对象的next方法。分别对应 键、值、键值对（[0,’a’]）</li><li><code>includes()</code> 判断数组中是否包含某个值，解决了indexOf对NaN的误判（因为NaN!==NaN，indexOf是===判断）</li><li>空位，es6上述数组扩展对空位处理比较一致，值设为undefined，遍历时视为存在</li></ul><h2 id="lesson8-对象扩展"><a href="#lesson8-对象扩展" class="headerlink" title="lesson8 对象扩展"></a>lesson8 对象扩展</h2><h3 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h3><ul><li><p>属性、方法简写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; a &#125; &#123; a() &#123;&#125; &#125;</span><br></pre></td></tr></table></figure></li><li><p>属性名表达式、方法名表达式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; [<span class="string">'a'</span> + <span class="string">'bc'</span>]: <span class="string">'a'</span> &#125;</span><br><span class="line">&#123; [<span class="string">'a'</span> + <span class="string">'bc'</span>]() &#123;&#125; &#125;</span><br><span class="line"><span class="comment">// 注意属性名为对象时，会自动转为字符串`[object Object]`</span></span><br></pre></td></tr></table></figure></li><li><p>方法名name</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这种情况下`obj.foo.name`会报错</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    get foo() &#123;&#125;,</span><br><span class="line">    set foo(x) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 正确写法</span></span><br><span class="line"><span class="keyword">const</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'foo'</span>);</span><br><span class="line">descriptor.get.name <span class="comment">// get foo</span></span><br><span class="line"><span class="comment">// special</span></span><br><span class="line">(<span class="keyword">new</span> <span class="built_in">Function</span>()).name <span class="comment">// "anonymous"</span></span><br><span class="line">doSomething.bind().name <span class="comment">// "bound doSomething"</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is"></a><code>Object.is</code></h4><ul><li>比较<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 除了下列情况外和===的表现一致</span></span><br><span class="line">+<span class="number">0</span> === <span class="number">-0</span> <span class="comment">//true</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a><code>Object.assign</code></h4><ul><li><p>用于对象合并，将源对象的所有可枚举属性复制到目标对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</span><br></pre></td></tr></table></figure></li><li><p>注意<br>非对象出现在第一个参数会被转为对象，出现在后面只有字符串会以字符数组形式参与合并。（因为只有字符串的包装对象，会产生可枚举属性）<br>对于undefined和null无法转为对象，多以出现在第一个参数位会报错，出现在后面会被忽略。<br>浅拷贝，即如果源对象的某个属性是对象，则目标对象拷贝的是该对象的引用</p></li><li><p>用途</p><ul><li>为对象添加属性、方法</li><li><p>克隆对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只克隆原有可枚举属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">origin</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, origin);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 保持继承链</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">origin</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> originProto = <span class="built_in">Object</span>.getPrototypeOf(origin);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.assign(<span class="built_in">Object</span>.create(originProto), origin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>合并多个对象</p></li><li>为属性设置默认值（利用覆盖，注意应为简单类型）</li></ul></li></ul><h4 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors"></a><code>Object.getOwnPropertyDescriptors</code></h4><ul><li>返回指向对象的所有自身属性的描述对象</li><li>由于Object.assign是赋值拷贝，所以无法正确拷贝对象的get和set方法，所以需要有方式去获取描述对象，再结合defineProperties进行</li><li>结合Object.create使用，浅拷贝</li></ul><h4 id="Object-getPropertyOf-Object-setPropertyOf-proto"><a href="#Object-getPropertyOf-Object-setPropertyOf-proto" class="headerlink" title="Object.getPropertyOf, Object.setPropertyOf, __proto__"></a><code>Object.getPropertyOf</code>, <code>Object.setPropertyOf</code>, <code>__proto__</code></h4><ul><li><p><code>__proto__</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj = <span class="built_in">Object</span>.create(someOtherObj);</span><br><span class="line">obj.__proto__ = someOtherObj;</span><br></pre></td></tr></table></figure></li><li><p><code>Object.setPrototypeOf(obj, proto)</code><br>将proto对象设为obj的原型，第一个参数为undefined和null时报错，非对象时自动转</p></li><li><p><code>Object.getPrototypeOf(obj)</code></p></li></ul><h4 id="super"><a href="#super" class="headerlink" title="super"></a><code>super</code></h4><ul><li>指向当前对象的原型对象，只有对象的方法的简写模式中有效，否则报错</li><li><code>super.foo</code>等同于<code>Object.getPrototypeOf(this).foo</code></li></ul><h4 id="Object-keys-Object-values-Object-entries"><a href="#Object-keys-Object-values-Object-entries" class="headerlink" title="Object.keys, Object.values, Object.entries"></a><code>Object.keys</code>, <code>Object.values</code>, <code>Object.entries</code></h4><ul><li><code>Object.entries</code> 用途：<code>new Map(Object.entries(obj))</code></li></ul><h3 id="属性的可枚举和遍历"><a href="#属性的可枚举和遍历" class="headerlink" title="属性的可枚举和遍历"></a>属性的可枚举和遍历</h3><h4 id="可枚举"><a href="#可枚举" class="headerlink" title="可枚举"></a>可枚举</h4><ul><li><p>获取属性的描述对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'foo'</span>)</span><br><span class="line"><span class="comment">//  &#123;</span></span><br><span class="line"><span class="comment">//    value: 123,</span></span><br><span class="line"><span class="comment">//    writable: true,</span></span><br><span class="line"><span class="comment">//    enumerable: true,</span></span><br><span class="line"><span class="comment">//    configurable: true</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>忽略 enumerable为false的操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ... in <span class="comment">// 会返回继承的属性</span></span><br><span class="line"><span class="built_in">Object</span>.keys()</span><br><span class="line"><span class="built_in">JSON</span>.stringify()</span><br><span class="line"><span class="built_in">Object</span>.assign()</span><br></pre></td></tr></table></figure></li><li><p>遍历</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ... in <span class="comment">// 遍历自身和继承的**可枚举**属性，不包含Symbol属性</span></span><br><span class="line"><span class="built_in">Object</span>.keys <span class="comment">// 返回一个数组，只包含自身所有**可枚举**属性，不包含Symbol属性</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(obj) <span class="comment">// 返回一个数组，包含对象自身的**所有**属性，不包含Symbol属性</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(obj) <span class="comment">// 返回一个数组，包含对象本身的所有Symbol属性</span></span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(obj) <span class="comment">// 返回一个数组，包含自身**所有键名**</span></span><br><span class="line"><span class="comment">// 共性：遍历顺序为 数值键-字符串键-Symbol属性</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="扩展运算符-1"><a href="#扩展运算符-1" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><h3 id="Null传导运算符（提案）"><a href="#Null传导运算符（提案）" class="headerlink" title="Null传导运算符（提案）"></a>Null传导运算符（提案）</h3><ul><li><code>obj?.prop, obj?.[expr], func?.(...args), new C?.(...args)</code></li></ul></div></div><div class="article-footer"><div class="article-meta pull-left"><span class="post-categories"><i class="icon-categories"></i> <a href="/categories/code/">code</a> </span><span class="post-tags"><i class="icon-tags"></i> <a href="/tags/js/">js</a></span></div></div></article></main><footer class="site-footer"><p class="site-info">Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a><br>&copy; 2018 Derek Zhou</p></footer></div></div></body></html>