<!DOCTYPE HTML><html><head><meta charset="utf-8"><title>mvx 从todo mvc说起 | DZ&#39;s Gensokyo | Best Time, Best You and Me</title><meta name="author" content="Derek Zhou"><meta name="description" content="life are flashes and here is my life"><meta name="keywords" content="mvx"><meta id="viewport" name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,minimal-ui"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta property="og:title" content="mvx 从todo mvc说起"><meta property="og:site_name" content="DZ&#39;s Gensokyo"><meta property="og:image" content="/favicon.ico"><link href="/favicon.ico" rel="icon"><link rel="alternate" href="/atom.xml" title="DZ&#39;s Gensokyo" type="application/atom+xml"><link rel="stylesheet" href="/css/style.css" media="screen" type="text/css"></head><body><div class="blog"><div class="content"><header><div class="site-branding"><h1 class="site-title"><a href="/">DZ&#39;s Gensokyo</a></h1><p class="site-description">Best Time, Best You and Me</p></div><nav class="site-navigation"><ul><li><a href="/">主页</a></li><li><a href="/archives">归档</a></li><li><a href="/tags">标签</a></li><li><a href="/about">关于</a></li></ul></nav></header><main class="site-main posts-loop"><article><h3 class="article-title"><span>mvx 从todo mvc说起</span></h3><div class="article-top-meta"><span class="posted-on"><a href="/posts/c4697232/" rel="bookmark"><time class="entry-date published" datetime="2017-12-18T08:17:17.000Z">2017-12-18</time></a></span></div><div class="article-content"><div class="entry"><p>&emsp;&emsp;在git上看到一个<a href="https://github.com/tastejs/todomvc" target="_blank" rel="noopener">to do mvc</a>的repo，一时有了兴致，记录下一些点。<br><a id="more"></a></p><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><h4 id="静态-展示-gt-动态-交互"><a href="#静态-展示-gt-动态-交互" class="headerlink" title="静态/展示-&gt;动态/交互"></a>静态/展示-&gt;动态/交互</h4><ul><li>web1.0时代，服务端直接将数据填充进模板，生成Html返回给浏览器，静态网页，纯展示</li><li>web2.0时代，动态网页，前端向服务端请求数据，然后自己处理数据，提供了用户和浏览器的交互</li></ul><h4 id="前端mv-的必要性"><a href="#前端mv-的必要性" class="headerlink" title="前端mv*的必要性"></a>前端mv*的必要性</h4><ul><li>前端进入到需要保存数据、处理数据和生成视图的web2.0时代</li><li>webapp的概念，web不再是页面级，而是application级别，所以需要思考应用的管理，数据的流向等</li></ul><p><img src="http://opo02jcsr.bkt.clouddn.com/ff5d456ff2abab2a42527f3bae237132.png" alt=""></p><h3 id="todo-mv"><a href="#todo-mv" class="headerlink" title="todo mv*"></a>todo mv*</h3><ul><li>其实差别就前端如何管理数据，以及数据如何和视图联系起来</li></ul><h4 id="backbone"><a href="#backbone" class="headerlink" title="backbone"></a>backbone</h4><ul><li>只有Model和View</li><li><p>结构<br>├── index.html<br>├── js</p><pre><code>├── app.js
├── collections
│   └── todos.js
├── models
│   └── todo.js
├── routers
│   └── router.js
└── views
    ├── app-view.js
    └── todo-view.js
</code></pre></li><li><p>以新增为例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// views/app-view.js</span></span><br><span class="line"><span class="comment">// 绑定节点</span></span><br><span class="line">el: <span class="string">'.todoapp'</span>,</span><br><span class="line"><span class="comment">// 声明事件</span></span><br><span class="line">events: &#123;</span><br><span class="line">  <span class="string">'keypress .new-todo'</span>: <span class="string">'createOnEnter'</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用户在view层enter，调用collection的方法创建新的todo model</span></span><br><span class="line">createOnEnter: <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e.which === ENTER_KEY &amp;&amp; <span class="keyword">this</span>.$input.val().trim()) &#123;</span><br><span class="line">    app.todos.create(<span class="keyword">this</span>.newAttributes());</span><br><span class="line">    <span class="keyword">this</span>.$input.val(<span class="string">''</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// collections/todos.js</span></span><br><span class="line"><span class="keyword">var</span> Todos = Backbone.Collection.extend(&#123;</span><br><span class="line">  <span class="comment">// Reference to this collection's model.</span></span><br><span class="line">  model: app.Todo,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// models/todo.js</span></span><br><span class="line">app.Todo = Backbone.Model.extend(&#123;</span><br><span class="line">  defaults: &#123;</span><br><span class="line">    title: <span class="string">''</span>,</span><br><span class="line">    completed: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// viwes/todo-views.js</span></span><br><span class="line"><span class="comment">// 绑定模板</span></span><br><span class="line">template: _.template($(<span class="string">'#item-template'</span>).html()),</span><br><span class="line"><span class="comment">// 监听model的change，注册回调render</span></span><br><span class="line">initialize: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.listenTo(<span class="keyword">this</span>.model, <span class="string">'change'</span>, <span class="keyword">this</span>.render);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// render方法，将model数据填充</span></span><br><span class="line">render: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.model.changed.id !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.$el.html(<span class="keyword">this</span>.template(<span class="keyword">this</span>.model.toJSON()));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义model和collection，在view层通过事件触发model层行为，改变数据后，通过事先注册的监听model变化的回调函数来更新view</p></li></ul><h4 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h4><ul><li>model, view, modelview (mvvm)</li><li>结构<br>├── index.html<br>├── js<br>│ ├── app.js<br>│ ├── routes.js<br>│ └── store.js</li><li><p>新增为例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="comment">// vue对象，连接view和model的vm</span></span><br><span class="line">exports.app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// 绑定节点</span></span><br><span class="line">  el: <span class="string">'.todoapp'</span>,</span><br><span class="line">  <span class="comment">// 定义数据模型</span></span><br><span class="line">  data: &#123;</span><br><span class="line">    todos: todoStorage.fetch(),</span><br><span class="line">    newTodo: <span class="string">''</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 修改数据模型的方法</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    addTodo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> value = <span class="keyword">this</span>.newTodo &amp;&amp; <span class="keyword">this</span>.newTodo.trim();</span><br><span class="line">      <span class="keyword">if</span> (!value) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.todos.push(&#123; <span class="attr">id</span>: <span class="keyword">this</span>.todos.length + <span class="number">1</span>, <span class="attr">title</span>: value, <span class="attr">completed</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">      <span class="keyword">this</span>.newTodo = <span class="string">''</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.html</span></span><br><span class="line"><span class="comment">// v-modal将数据（vm）和节点（v）绑定，通过事件触发vue对象的方法改变数据，并通过观察者模式和自定义的访问器实现view的更新</span></span><br><span class="line">&lt;input <span class="class"><span class="keyword">class</span></span>=<span class="string">"new-todo"</span> autofocus autocomplete=<span class="string">"off"</span> v-model=<span class="string">"newTodo"</span> @keyup.enter=<span class="string">"addTodo"</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p>vm实际上是简化的controller，将model数据简单处理，为view提供正确的数据</p></li></ul><h4 id="react"><a href="#react" class="headerlink" title="react"></a>react</h4><ul><li>react只是视图层解决方案，本质是将图形界面（GUI）函数化。</li><li>view是state的输出，引自阮一峰老师 <code>js view = f(state)</code></li><li>组件state/props用于数据存储流转，render函数输出view，事件驱动产生数据变化，setState重新render…</li><li>结构<br>├── index.html<br>├── js<br>│ ├── app.jsx<br>│ ├── footer.jsx<br>│ ├── todoItem.jsx<br>│ ├── todoModel.js<br>│ └── utils.js<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// todoModel.js</span></span><br><span class="line"><span class="comment">// 定义model，在原型上定义一些方法，比如存数据到localstorage里持久化</span></span><br><span class="line">app.TodoModel = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.key = key;</span><br><span class="line">  <span class="keyword">this</span>.todos = Utils.store(key);</span><br><span class="line">  <span class="keyword">this</span>.onChanges = [];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 注册回调进行订阅</span></span><br><span class="line">app.TodoModel.prototype.subscribe = <span class="function"><span class="keyword">function</span> (<span class="params">onChange</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.onChanges.push(onChange);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 调用inform时通知各个订阅者，执行回调</span></span><br><span class="line">app.TodoModel.prototype.inform = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  Utils.store(<span class="keyword">this</span>.key, <span class="keyword">this</span>.todos);</span><br><span class="line">  <span class="keyword">this</span>.onChanges.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">cb</span>) </span>&#123; cb(); &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// app.jsx</span></span><br><span class="line"><span class="keyword">var</span> TodoApp = React.createClass(&#123;</span><br><span class="line">  <span class="comment">// 初始化state</span></span><br><span class="line">  getInitialState: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      newTodo: <span class="string">''</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 事件触发，setState，重新render</span></span><br><span class="line">  handleChange: <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">newTodo</span>: e.target.value&#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;</span><br><span class="line">      &lt;input onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class="line">      &lt;div&gt;&#123;this.state.newTodo&#125;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">var model = new app.TodoModel('react-todos');</span><br><span class="line">function render() &#123;</span><br><span class="line">  React.render(</span><br><span class="line">    &lt;TodoApp model=&#123;model&#125;/&gt;,</span><br><span class="line">    document.getElementsByClassName('todoapp')[0]</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">model.subscribe(render);</span><br><span class="line">render()</span><br></pre></td></tr></table></figure></li></ul><h4 id="flux"><a href="#flux" class="headerlink" title="flux"></a>flux</h4><p><img src="http://opo02jcsr.bkt.clouddn.com/a1f71617fc991252b13bbb92ecf1f910.png" alt=""></p><ul><li>不同组件的state放在一个外部的通用的store里</li><li>每个组件订阅该store的一部分</li><li>组件内通过dispatch一个action去触发store的更新</li></ul><h4 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h4><p><img src="http://opo02jcsr.bkt.clouddn.com/fd0c3c8b8fdf803f8cc2adc1698a799e.png" alt=""></p><ul><li>状态都存放在store中，组件的重新渲染都由状态改变来触发</li><li><p>用户通过在view层dispatch action触发reducer，在reducer中 new = f(old) 计算得到新的state</p><p><img src="http://opo02jcsr.bkt.clouddn.com/98fc05f593a3c073b475091c9849ac92.png" alt=""></p></li><li><p>UI组件和容器组件</p><ul><li>UI组件负责页面外观</li><li>容器组件负责数据和行为，订阅store，处理store的数据然后传递给UI组件，例如connect方法</li></ul></li><li><p>Provider和connect</p><ul><li><p>前者将react应用包一层，使得组件和store可被连接，同时传入store</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(reducer);</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Provider&gt;,</span></span><br><span class="line"><span class="regexp">  document.body.appendChild(document.createElement('div'))</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure></li><li><p>store由redux得createStore方法提供，该方法接收reducer作为参数，实际上相当于定义了action list对应的处理对象和方案</p></li><li>connect将UI组件和容器组件连接，使得在我们的UI/业务组件中能够获取到最初定义好的store，并在UI组件中通过dispatch action去对上一条所说的处理对象执行处理方案</li></ul></li><li><p>reducer<br>-纯函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收旧的state和action，返回新的state</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state = &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  text: <span class="string">'你好，访问者'</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  name: <span class="string">'访问者'</span></span></span></span><br><span class="line"><span class="function"><span class="params">&#125;, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'change'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        name: action.payload,</span><br><span class="line">        text: <span class="string">'你好，'</span> + action.payload</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>典型的MV*，model对应于store，view对应于业务组件，连接起来或者说数据处理交由action reducer完成，适合于大型应用。</li></ul></li></ul><h4 id="Mobx"><a href="#Mobx" class="headerlink" title="Mobx"></a>Mobx</h4><ul><li>UI 层是观察者，Store 是被观察者。</li><li>🌰 下回分解<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;observable&#125; = mobx;</span><br><span class="line"><span class="keyword">const</span> &#123;observer&#125; = mobxReact;</span><br><span class="line"><span class="keyword">const</span> person = observable(&#123;<span class="attr">name</span>: <span class="string">"张三"</span>, <span class="attr">age</span>: <span class="number">31</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> App = observer(</span><br><span class="line">  (&#123; person &#125;) =&gt; &lt;h1&gt;&#123; person.name &#125;&lt;/h1&gt;</span><br><span class="line">);</span><br><span class="line">ReactDOM.render(&lt;App person=&#123;person&#125; /&gt;, document.body);</span><br><span class="line">person.name = "李四";</span><br></pre></td></tr></table></figure></li></ul></div></div><div class="article-footer"><div class="article-meta pull-left"><span class="post-categories"><i class="icon-categories"></i> <a href="/categories/code/">code</a> </span><span class="post-tags"><i class="icon-tags"></i> <a href="/tags/mvx/">mvx</a></span></div></div></article></main><footer class="site-footer"><p class="site-info">Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a><br>&copy; 2018 Derek Zhou</p></footer></div></div></body></html>