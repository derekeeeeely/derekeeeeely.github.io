<!DOCTYPE HTML><html><head><meta charset="utf-8"><title>dubbo-rpc 初探rpc | DZ&#39;s Gensokyo | Best Time, Best You and Me</title><meta name="author" content="Derek Zhou"><meta name="description" content="life are flashes and here is my life"><meta name="keywords" content="rpc,dubbo"><meta id="viewport" name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,minimal-ui"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta property="og:title" content="dubbo-rpc 初探rpc"><meta property="og:site_name" content="DZ&#39;s Gensokyo"><meta property="og:image" content="/favicon.ico"><link href="/favicon.ico" rel="icon"><link rel="alternate" href="/atom.xml" title="DZ&#39;s Gensokyo" type="application/atom+xml"><link rel="stylesheet" href="/css/style.css" media="screen" type="text/css"></head><body><div class="blog"><div class="content"><header><div class="site-branding"><h1 class="site-title"><a href="/">DZ&#39;s Gensokyo</a></h1><p class="site-description">Best Time, Best You and Me</p></div><nav class="site-navigation"><ul><li><a href="/">主页</a></li><li><a href="/archives">归档</a></li><li><a href="/tags">标签</a></li><li><a href="/about">关于</a></li></ul></nav></header><main class="site-main posts-loop"><article><h3 class="article-title"><span>dubbo-rpc 初探rpc</span></h3><div class="article-top-meta"><span class="posted-on"><a href="/posts/c48da636/" rel="bookmark"><time class="entry-date published" datetime="2017-11-21T14:08:50.000Z">2017-11-21</time></a></span></div><div class="article-content"><div class="entry"><p>&emsp;&emsp;抱着学习理解dubbo的心思，从各方大佬身上取经，记下学习笔记，方便自己，服务志同道合的小伙伴们。<br><a id="more"></a></p><h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><h4 id="远程过程调用协议（Remote-Procedure-Call-Protocol）"><a href="#远程过程调用协议（Remote-Procedure-Call-Protocol）" class="headerlink" title="远程过程调用协议（Remote Procedure Call Protocol）"></a>远程过程调用协议（Remote Procedure Call Protocol）</h4><ul><li><p>speak chinese:<br>&emsp;部署在A服务器上的应用a需要调用部署在B服务器上的b应用提供的c函数/方法，这个时候就需要实现远程过程调用，RPC就是实现这一功能的协议。</p></li><li><p>本地过程调用:<br>&emsp;举个🌰</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> c = a + b;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b1 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> c1 = add(a1, b1);</span><br></pre></td></tr></table></figure><p><code>int c1 = add(a1, b1)</code>执行过程：</p><ul><li>将a1, b1值压栈</li><li>进入add函数，取出栈中a1, b1，赋值给a, b</li><li>计算a + b，将结果存在c</li><li>c压栈，从add函数返回</li><li>从栈中取出c的值，赋值给c1</li></ul></li><li><p>那么问题来了<br>&emsp;本地调用由于函数/参数都存在内存中，可以直接调用/读取，合情合理，不需要做特别处理。<br>&emsp;而上面栗子中的a应用要完成使命，首先需要和b应用通过网络建立进程间通信，然后将参数以某种b应用能够理解的形式传递过去，并且b应用需要按照某种约定准确找到c函数/方法，返回结果的过程类似。<br>&emsp;对于负责业务代码的程序员来说，我们不关注远程调用的细节，我们希望的是远程调用能够做到和本地调用看起来是一样的，这样我们所写的代码不需要考虑调用场景特殊化处理。这一点需要实现以下几部分：</p><ul><li>call ID 映射<br>本地调用函数直接会找到函数指针，远程调用时，地址空间毫无关联，所以需要给所有的函数一个ID，消费端和提供端都需要维护这样一个ID映射，在远程调用时，消费者会带上这个ID，提供端根据ID找到相应的函数再去执行。</li><li>序列化/反序列化<br>由于必须通过网络传输传递参数，传输两端需要能够理解交换的数据，原本存储在内存中的参数值在消费端进行序列化，到达提供端后进行反序列化恢复成内存中的表达形式，然后在提供端执行函数/方法，返回结果类似，同样需要序列化和反序列化。</li><li>网络传输<br>网络传输这一块大部分RPC框架使用TCP协议，实际上能够实现网络传输目的的其他一些协议也是适用的。</li></ul></li></ul><h4 id="RPC结构"><a href="#RPC结构" class="headerlink" title="RPC结构"></a>RPC结构</h4><ul><li><p>图解<br><img src="http://opo02jcsr.bkt.clouddn.com/94086df8115831bd40ef99719aacae9c.jpeg" alt=""></p><ul><li>&emsp;RPC 服务方通过 <code>RpcServer</code> 去export远程接口方法，而客户方通过 <code>RpcClient</code> 去import远程接口方法。</li><li>&emsp;客户方像调用本地方法一样去调用远程接口方法，RPC 框架提供接口的代理实现，实际的调用将委托给代理 <code>RpcProxy</code> 。</li><li>&emsp;代理封装调用信息并将调用转交给 <code>RpcInvoker</code> 去实际执行。</li><li>&emsp;在客户端的 <code>RpcInvoker</code> 通过连接器 <code>RpcConnector</code> 去维持与服务端的通道 <code>RpcChannel</code>，并使用 <code>RpcProtocol</code> 执行协议encode并将编码后的请求消息通过通道发送给服务方。</li><li>&emsp;RPC 服务端接收器 <code>RpcAcceptor</code> 接收客户端的调用请求，同样使用 <code>RpcProtocol</code> 执行协议decode。解码后的调用信息传递给 <code>RpcProcessor</code> 去控制处理调用过程，最后再委托调用给 <code>RpcInvoker</code> 去实际执行并返回调用结果。</li></ul></li></ul><h4 id="RPC组件"><a href="#RPC组件" class="headerlink" title="RPC组件"></a>RPC组件</h4><ul><li><code>RpcServer</code> 用于服务方导出远程接口方法，<code>RpcClient</code> 用于客户方引入接口方法的代理实现</li><li><code>RpcProxy</code> 是远程接口方法的代理实现</li><li><code>RpcInvoker</code><ul><li>客户方实现：负责编码调用信息和发送调用请求到服务方并等待调用结果返回</li><li>服务方实现：负责调用服务端接口的具体实现并返回调用结果</li></ul></li><li><code>RpcProtocol</code> 负责编解码</li><li><code>RpcConnector</code> 负责维持客户方和服务方的连接通道和发送数据到服务方</li><li><code>RpcAcceptor</code> 负责接收客户方请求并返回请求结果</li><li><code>RpcProcessor</code> 负责服务方控制调用过程，包括管理调用线程池、超时时间等</li><li><p><code>RpcChannel</code> 数据传输通道</p><p>组件具体实现后续参考dubbo框架再来学习</p></li></ul><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul><li>远程调用可能由于网络问题没有到达服务方，所以调用未必一定执行</li><li>远程调用抛出的异常可能是RPC框架运行时异常</li><li>远程调用消耗肯定是高于本地调用的，所以考虑导出为远程接口的前提是计算消耗远大于RPC的固有消耗</li></ul><p>上述内容部分引用自 <a href="http://blog.csdn.net/mindfloating/article/details/39474123" target="_blank" rel="noopener">深入浅出 RPC - 深入篇</a></p><h3 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h3><h4 id="惯例吹一波"><a href="#惯例吹一波" class="headerlink" title="惯例吹一波"></a>惯例吹一波</h4><ul><li><p>基于java的高性能开源RPC框架，主要实现了RPC远程调用、集群容错和负载均衡、服务管理和监控三大块功能。</p><p><img src="http://opo02jcsr.bkt.clouddn.com/deabda567257a04070d7183bef92e860.png" alt=""></p></li></ul></div></div><div class="article-footer"><div class="article-meta pull-left"><span class="post-categories"><i class="icon-categories"></i> <a href="/categories/code/">code</a> </span><span class="post-tags"><i class="icon-tags"></i> <a href="/tags/rpc/">rpc</a><a href="/tags/dubbo/">dubbo</a></span></div></div></article></main><footer class="site-footer"><p class="site-info">Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a><br>&copy; 2018 Derek Zhou</p></footer></div></div></body></html>