<!DOCTYPE HTML><html><head><meta charset="utf-8"><title>js-es6 新特性篇 | DZ&#39;s Gensokyo | Best Time, Best You and Me</title><meta name="author" content="Derek Zhou"><meta name="description" content="life are flashes and here is my life"><meta name="keywords" content="js"><meta id="viewport" name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,minimal-ui"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta property="og:title" content="js-es6 新特性篇"><meta property="og:site_name" content="DZ&#39;s Gensokyo"><meta property="og:image" content="/favicon.ico"><link href="/favicon.ico" rel="icon"><link rel="alternate" href="/atom.xml" title="DZ&#39;s Gensokyo" type="application/atom+xml"><link rel="stylesheet" href="/css/style.css" media="screen" type="text/css"></head><body><div class="blog"><div class="content"><header><div class="site-branding"><h1 class="site-title"><a href="/">DZ&#39;s Gensokyo</a></h1><p class="site-description">Best Time, Best You and Me</p></div><nav class="site-navigation"><ul><li><a href="/">主页</a></li><li><a href="/archives">归档</a></li><li><a href="/tags">标签</a></li><li><a href="/about">关于</a></li></ul></nav></header><main class="site-main posts-loop"><article><h3 class="article-title"><span>js-es6 新特性篇</span></h3><div class="article-top-meta"><span class="posted-on"><a href="/posts/f1e10a9/" rel="bookmark"><time class="entry-date published" datetime="2017-11-06T06:12:52.000Z">2017-11-06</time></a></span></div><div class="article-content"><div class="entry"><p>&emsp;&emsp;承上一篇，本笔记包含es6的一些新东西，如Reflect，Proxy，Iterator，Symbol等。<br><a id="more"></a></p><h2 id="lesson1-Symbol"><a href="#lesson1-Symbol" class="headerlink" title="lesson1 Symbol"></a>lesson1 Symbol</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li><p>javaScript第七种原始数据类型Symbol<br><code>let s = Symbol(&#39;foo&#39;)</code><br>通过Symbol函数生成，每个Symbol类型的变量值都独一无二，作为一种类似于字符串的数据结构，可以避免变量名冲突<br>Symbol函数接收一个参数用于描述该Symbol实例，不影响生成的Symbol实例的值<br>Symbol值不能与其他类型进行运算（模板字符串中也不可以），可以显示转为字符串和布尔值（String(), Boolean()）</p></li><li><p>Symbol作为属性名</p><ul><li>不能用<code>.</code>，因为<code>.</code>是去取字符串对应属性名</li><li>在对象中使用作为属性名时，需使用<code>[s]</code>否则也会被当做字符串</li></ul></li><li><p><code>Symbol.for</code>, <code>Symbol.keyFor</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s1) <span class="comment">// "foo"</span></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>); <span class="comment">// 先搜索全局，已存在该key则返回已存在的</span></span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s2) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="内置Symbol值"><a href="#内置Symbol值" class="headerlink" title="内置Symbol值"></a>内置Symbol值</h3><ul><li><p><code>Symbol.hasInstance</code><br>对象的<code>Symbol.hasInstance</code>属性指向一个内部方法，其他对象使用instanceOf判断实例时，会调用这个内部方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Even</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> [<span class="built_in">Symbol</span>.hasInstance](obj) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Number</span>(obj) % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span> instanceOf Even</span><br></pre></td></tr></table></figure></li><li><p><code>Symbol.isConcatSpreadable</code><br>表示该对象用于Array.prototype.concat()时是否可以展开，数组默认可展开，默认值为undefined，对象默认不可展开</p></li><li><p><code>Symbol.species</code><br>指向当前对象的构造函数，创造实例时会调用这个方法，即使用该属性返回的函数作为构造函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> get [<span class="built_in">Symbol</span>.species]() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>Symbol.match</code>, <code>Symbol.replace</code>, <code>Symbol.split</code>, <code>Symbol.search</code></p></li><li><code>Symbol.iterator</code><br>指向该对象的默认遍历器方法<br>对象进行for…of循环时，会调用Symbol.iterator方法，返回该对象的默认遍历器<br>详见后续章节</li><li><code>Symbol.toPrimitive</code></li><li><code>Symbol.toStringTag</code><br>指向一个方法，在该对象上调用<code>Object.prototype.toString()</code>时，如果该属性存在，则他的返回值会出现在toString方法返回的字符串之中，比如[Object Array]<br>新增内置对象举个例子：<code>JSON[Symbol.toStringTag]：&#39;JSON&#39;</code></li></ul><h2 id="lesson2-Set和Map"><a href="#lesson2-Set和Map" class="headerlink" title="lesson2 Set和Map"></a>lesson2 Set和Map</h2><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h4><ul><li><p>Set构造函数生成，成员值唯一，(判断与===区别在于NaN)，两个空对象视为不同</p></li><li><p>实例属性和方法</p><ul><li>属性： <code>Set.prototype.constructor</code>, <code>Set.prototype.size</code></li><li>方法： <code>add(value)</code>, <code>delete(value)</code>, <code>has(value)</code>, <code>clear()</code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from可以将<span class="built_in">Set</span>转为数组</span><br><span class="line"><span class="comment">// 数组去重</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dedupe</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(array));</span><br><span class="line">  <span class="comment">// return [...new Set(array)]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>遍历</p><ul><li>keys(), values(), entries(), forEach() 方法</li><li>遍历顺序为插入顺序，或可用于设置指定顺序的回调函数</li><li>Set的键名键值相同</li><li>Set默认可遍历，默认遍历器生成函数是values方法，这意味着，可以省略values方法，直接用for…of循环遍历 Set<br><code>Set.prototype[Symbol.iterator] === Set.prototype.values</code></li><li><code>...</code>内部使用<code>for ... of</code>，故可以使用<code>[...Set]</code>，转为数组后可以方便使用数组方法如map和filter</li></ul></li></ul><h4 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h4><ul><li>成员只能为对象</li><li>弱引用，垃圾回收机制对对象引用计数时不考虑WeakSet中对对象的引用</li><li><code>new WeakSet()</code> 可以接收任何具有 <code>Iterable</code> 接口的对象作为参数，但必须注意加入<code>WeakSet</code>的成员必须为对象</li><li>WeakSet有以下三个方法：<code>add(value)</code>, <code>delete(value)</code>, <code>has(value)</code>，没有size属性，不可遍历（没有forEach和clear方法）</li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="基本-1"><a href="#基本-1" class="headerlink" title="基本"></a>基本</h4><ul><li>键值对的集合（Hash结构），键和对象不一样，不局限于字符串。</li><li>任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构都可以作为Map构造函数的参数</li><li><p>只有对同一个对象的引用或者严格相等的简单类型（包括NaN）才会生成一样的Map</p></li><li><p>实例属性和方法</p><ul><li>属性： <code>Map.prototype.constructor</code>, <code>Map.prototype.size</code></li><li>方法： <code>set()</code>, <code>get()</code>, <code>delete(value)</code>, <code>has(value)</code>, <code>clear()</code></li></ul></li><li><p>遍历</p><ul><li>类似上述Set的遍历</li><li>Map 结构的默认遍历器接口（Symbol.iterator属性），就是entries方法</li></ul></li></ul><h4 id="与其他数据结构转换"><a href="#与其他数据结构转换" class="headerlink" title="与其他数据结构转换"></a>与其他数据结构转换</h4><ul><li>数组，对象，JSON互转<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strMapToObj</span>(<span class="params">strMap</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> [k,v] <span class="keyword">of</span> strMap) &#123;</span><br><span class="line">    obj[k] = v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h4><ul><li>键名只能为对象</li><li>WeakMap的键名所指向的对象，不计入垃圾回收机制</li><li>WeakMap有以下三个方法：<code>get</code>, <code>set</code>, <code>delete(value)</code>, <code>has(value)</code>，没有size属性，不可遍历（没有forEach和clear方法）</li></ul><p><img src="http://opo02jcsr.bkt.clouddn.com/a3ca4dc0aad89c377838dcf51642e109.jpg" alt=""></p><h2 id="lesson3-Proxy"><a href="#lesson3-Proxy" class="headerlink" title="lesson3 Proxy"></a>lesson3 Proxy</h2><h3 id="观察"><a href="#观察" class="headerlink" title="观察"></a>观察</h3><ul><li><p>举个栗子<br>当你为对象a赋值a.b=c时，你希望在b属性赋值时有一个范围大小的校验，超出范围抛错，这个时候我们可能会想到重载set方法,比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(a, <span class="string">'b'</span>, &#123;</span><br><span class="line">  set(x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x&gt;<span class="number">100</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RangeError</span>(<span class="string">'invalid range'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.b = x</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>动手以后发现一个问题…这样会栈溢出，因为在set内再set了b的值，无限循环…变通一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(a, <span class="string">'b'</span>, &#123;</span><br><span class="line">  get(x) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.c</span><br><span class="line">  &#125;</span><br><span class="line">  set(x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x&gt;<span class="number">100</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RangeError</span>(<span class="string">'invalid range'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.c = x</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然而总要这么写感觉很麻烦，而且如果是对一类属性进行操作时，重复写很没必要，换用Proxy写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">  set(obj, prop, value, receiver) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">'b'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (value&gt;<span class="number">100</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RangeError</span>(<span class="string">'invalid range'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    obj[prop] = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(a, handler)</span><br></pre></td></tr></table></figure><p>看起来也舒服多了，而且可以根据属性名在set方法内做判断，更可扩展</p></li></ul><h3 id="庖丁解牛"><a href="#庖丁解牛" class="headerlink" title="庖丁解牛"></a>庖丁解牛</h3><ul><li><p>代理proxy</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> handler = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="comment">// 将代理的所有内部方法转发至目标</span></span><br><span class="line">proxy.a = <span class="number">1</span> =&gt; target.a = <span class="number">1</span>;</span><br><span class="line">target.b = <span class="number">4</span> =&gt; proxy.b = <span class="number">4</span>;</span><br><span class="line">target !== proxy</span><br><span class="line">target.__proto__ === proxy.__proto__</span><br><span class="line"><span class="comment">// 应在代理对象上操作，代理才能生效</span></span><br><span class="line">handler = &#123;get()&#123;<span class="keyword">return</span> <span class="number">12</span>&#125;&#125;</span><br><span class="line">target.v <span class="comment">// undefined</span></span><br><span class="line">proxy.v <span class="comment">// 12</span></span><br></pre></td></tr></table></figure></li><li><p>Proxy支持的拦截操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">get(target, propKey, receiver) <span class="comment">// proxy.foo, proxy['foo']</span></span><br><span class="line">set(target, propKey, value, receiver) <span class="comment">//proxy.foo = v, proxy['foo'] = v</span></span><br><span class="line">has(target, propKey) <span class="comment">// propKey in proxy</span></span><br><span class="line">deleteProperty(target, propKey) <span class="comment">// delete proxy[propKey]</span></span><br><span class="line">ownKeys(target) <span class="comment">// Object.getOwnPropertyNames(proxy), Object.getOwnPropertySymbols(proxy), Object.keys(proxy)</span></span><br><span class="line">getOwnPropertyDescriptor(target, propKey) <span class="comment">// Object.getOwnPropertyDescriptor(proxy, propKey)</span></span><br><span class="line">defineProperty(target, propKey, propDesc) <span class="comment">// Object.defineProperty(proxy, propKey, propDesc), Object.defineProperties(proxy, propDescs)</span></span><br><span class="line">preventExtensions(target) <span class="comment">// Object.preventExtensions(proxy)</span></span><br><span class="line">getPrototypeOf(target) <span class="comment">// Object.getPrototypeOf(proxy)</span></span><br><span class="line">isExtensible(target) <span class="comment">// Object.isExtensible(proxy)</span></span><br><span class="line">setPrototypeOf(target, proto) <span class="comment">// Object.setPrototypeOf(proxy, proto)</span></span><br><span class="line">apply(target, object, args) <span class="comment">// 拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)</span></span><br><span class="line">construct(target, args) <span class="comment">// new proxy(...args)</span></span><br></pre></td></tr></table></figure></li><li><p>代理句柄handler<br>句柄对象的方法可以复写代理的内部方法，具体为上述的14种。</p><ul><li><p>举个🌰</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Tree</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, handler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span> (<span class="params">target, key, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> target)) &#123;</span><br><span class="line">      target[key] = Tree();  <span class="comment">// 自动创建一个子树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> tree = <span class="keyword">new</span> Tree()</span><br><span class="line">tree.branch1.branch2.twig = <span class="string">"green"</span></span><br></pre></td></tr></table></figure></li><li><p>再来个🌰</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现对in操作符隐藏属性</span></span><br><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  has (target, key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">'_'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> key <span class="keyword">in</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">_prop</span>: <span class="string">'foo'</span>, <span class="attr">prop</span>: <span class="string">'foo'</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="string">'_prop'</span> <span class="keyword">in</span> proxy <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><p>特别注意<br>如果目标对象不可扩展或者目标对象的属性不可写或者不可配置时，代理不能生效，可能会报错<br>需注意一些特定的方法对返回值有要求，不如重写isExtensible方法时，返回值与目标对象的isExtensible属性应一致，否则会报错<br>利用代理重写可以做很多事情比如隐藏属性、对某些属性、操作符屏蔽、拦截内在方法并且加上自己想要的逻辑处理去得到预期结果等</p></li></ul></li></ul><h3 id="饭后甜点"><a href="#饭后甜点" class="headerlink" title="饭后甜点"></a>饭后甜点</h3><ul><li><p>Proxy.revocable<br>返回一个对象，proxy属性对应Proxy实例，revoke属性为revoke方法可以取消Proxy实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;proxy, revoke&#125; = <span class="built_in">Proxy</span>.revocable(target, handler);</span><br><span class="line">proxy.foo = <span class="number">1</span></span><br><span class="line">revoke()</span><br><span class="line">proxy.foo <span class="comment">// TypeError: Revoked</span></span><br></pre></td></tr></table></figure></li><li><p>this问题</p><ul><li>代理以后目标对象内部的this指向的是Proxy实例而不是目标对象</li><li><p>有时候可能因为this指向问题导致代理达不到预期效果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jane的name属性实际存储在外部的WeakMap对象的_name上，导致后续取不到值</span></span><br><span class="line"><span class="keyword">const</span> _name = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    _name.set(<span class="keyword">this</span>, name);</span><br><span class="line">  &#125;</span><br><span class="line">  get name() &#123;</span><br><span class="line">    <span class="keyword">return</span> _name.get(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> jane = <span class="keyword">new</span> Person(<span class="string">'Jane'</span>);</span><br><span class="line">jane.name <span class="comment">// 'Jane'</span></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(jane, &#123;&#125;);</span><br><span class="line">proxy.name <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li><li><p>某些原生对象的部分属性需要this指向原生对象时才能获取，如Date.getDate()，此时proxy get时需要注意this绑定原始对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2015-01-01'</span>);</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  get(target, prop) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">'getDate'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> target.getDate.bind(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, prop);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line">proxy.getDate() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><ul><li>TO BE CONTINUED!</li></ul><h2 id="lesson4-Reflect"><a href="#lesson4-Reflect" class="headerlink" title="lesson4 Reflect"></a>lesson4 Reflect</h2><h3 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h3><ul><li>Reflect对象与Proxy对象一样，是为了操作对象而提供的新API，存在的原因如下：<ul><li>将Object对象的一些内部方法添加到Reflect对象上，且以后的新方法都部署到Reflect对象上，完成分离</li><li>让对象操作变成函数行为</li><li>修改Object对象一些内部方法在出错时的返回</li><li>Proxy覆写对象方法时，提供一个Reflect对象用来获取原始方法，以设置默认值，再此基础上再做功能添加和修改</li></ul></li></ul><h3 id="揭面"><a href="#揭面" class="headerlink" title="揭面"></a>揭面</h3><ul><li><p>静态方法<br>对应于Proxy可覆写的方法，有13个静态方法</p></li><li><p>注意</p><ul><li><p>Proxy和Reflect联用的时候要小心，可能一个拦截会触发另一个拦截</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = &#123;</span><br><span class="line">  a: <span class="string">'a'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">  set(target, key, value, receiver) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'set'</span>);</span><br><span class="line">    <span class="built_in">Reflect</span>.set(target, key, value, receiver)</span><br><span class="line">  &#125;,</span><br><span class="line">  defineProperty(target, key, attribute) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'defineProperty'</span>);</span><br><span class="line">    <span class="built_in">Reflect</span>.defineProperty(target, key, attribute);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(p, handler);</span><br><span class="line">obj.a = <span class="string">'A'</span>;</span><br><span class="line"><span class="comment">// set</span></span><br><span class="line"><span class="comment">// defineProperty</span></span><br></pre></td></tr></table></figure><p>在Reflect.set传入receiver的时候触发了Proxy.defineProperty，不传入receiver时不会触发defineProperty拦截</p></li><li><p>对于参数的要求、转换和报错处理</p></li></ul></li></ul><h3 id="🌰"><a href="#🌰" class="headerlink" title="🌰"></a>🌰</h3><ul><li>使用Proxy实现观察者模式<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = observable(&#123;</span><br><span class="line">  name: <span class="string">'张三'</span>,</span><br><span class="line">  age: <span class="number">20</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;person.name&#125;</span>, <span class="subst">$&#123;person.age&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">observe(print);</span><br><span class="line">person.name = <span class="string">'李四'</span>;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// 李四, 20</span></span><br><span class="line"><span class="comment">/**************************/</span></span><br><span class="line"><span class="keyword">const</span> queuedObservers = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="keyword">const</span> observe = <span class="function"><span class="params">fn</span> =&gt;</span> queuedObservers.add(fn);</span><br><span class="line"><span class="keyword">const</span> observable = <span class="function"><span class="params">obj</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;set&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params">target, key, value, receiver</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">  queuedObservers.forEach(<span class="function"><span class="params">observer</span> =&gt;</span> observer());</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="lesson5-遍历器Iterator"><a href="#lesson5-遍历器Iterator" class="headerlink" title="lesson5 遍历器Iterator"></a>lesson5 遍历器Iterator</h2><h3 id="遇见"><a href="#遇见" class="headerlink" title="遇见"></a>遇见</h3><ul><li><p>why Iterator<br>js中数据集合的概念越来越多，如果能有一种统一的访问方式将是极好的。Iterator的设计就基于此，通过为相应数据结构部署iterator接口让该数据结构可通过统一的方式:for…of遍历</p></li><li><p>遍历过程：</p><ul><li>创建一个指针对象指向当前数据结构的初始位置（遍历器对象实际为一个指针对象）</li><li>调用指针对象的next方法，直到指向数据结构的结束位置<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历器生成函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeIterator</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> nextIndex &lt; array.length ?</span><br><span class="line">        &#123;<span class="attr">value</span>: array[nextIndex++]&#125; :</span><br><span class="line">        &#123;<span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>一种数据结构，只要部署了Iterator接口，就视为可遍历的</p></li></ul><h3 id="相识"><a href="#相识" class="headerlink" title="相识"></a>相识</h3><h4 id="默认Iterator接口"><a href="#默认Iterator接口" class="headerlink" title="默认Iterator接口"></a>默认Iterator接口</h4><ul><li>默认的Iterator接口部署在[Symbol.iterator]属性上，<code>Symbol.iterator</code>属性键为Symbol对象，值为一个函数，即遍历器生成函数，执行该函数会返回一个遍历器对象，该对象具有一个next方法，调用该方法可以返回{value, done}对象，代表了当前成员的信息</li><li>部分数据结构如Array、Set、Map、String等已经部署了Iterator接口，对象则需要手动添加这样的方法实现Iterator接口</li><li>对于非线性数据结构，Iterator接口实际上就是一种线性转换，下例为class实现遍历器<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RangeIterator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(start, stop) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = start;</span><br><span class="line">    <span class="keyword">this</span>.stop = stop;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line">  next() &#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="keyword">this</span>.value;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.stop) &#123;</span><br><span class="line">      <span class="keyword">this</span>.value++;</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: value&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">range</span>(<span class="params">start, stop</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RangeIterator(start, stop);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> range(<span class="number">0</span>, <span class="number">3</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// 0, 1, 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="举个🌰"><a href="#举个🌰" class="headerlink" title="举个🌰"></a>举个🌰</h4><ul><li><p>实现指针</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.value = value;</span><br><span class="line">  <span class="keyword">this</span>.next = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// for...of时会调用改遍历器生成函数</span></span><br><span class="line">Node.prototype[<span class="built_in">Symbol</span>.iterator]= <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回的遍历器对象</span></span><br><span class="line">  <span class="keyword">var</span> iterator = &#123;</span><br><span class="line">    next: next</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当前成员</span></span><br><span class="line">  <span class="keyword">var</span> current = <span class="keyword">this</span></span><br><span class="line">  next() &#123;</span><br><span class="line">    <span class="keyword">if</span>(current) &#123;</span><br><span class="line">      <span class="keyword">var</span> value = current.value;</span><br><span class="line">      <span class="comment">// 移动指针</span></span><br><span class="line">      current = current.next;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: value &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> iterator</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 新建对象，因为在原型上实现的遍历器生成函数，所以每个实例都实现了遍历器接口</span></span><br><span class="line"><span class="keyword">var</span> one = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> two = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> three = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 当前成员的next指向下一个成员，在next方法中实现指针移动</span></span><br><span class="line">one.next = two;</span><br><span class="line">two.next = three;</span><br><span class="line"><span class="comment">// 对对象使用for...of时，去查找[Symbol.iterator]属性，找到后循环调用next方法，直到返回值得done属性为true</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">of</span> one)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// 1, 2, 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果<code>Symbol.iterator</code>方法对应的不是遍历器生成函数，则会报错</p></li></ul><h3 id="在何方"><a href="#在何方" class="headerlink" title="在何方"></a>在何方</h3><h4 id="调用场合"><a href="#调用场合" class="headerlink" title="调用场合"></a>调用场合</h4><ul><li>解构赋值</li><li><p>扩展运算符<br>任何实现了Iterator接口（可遍历）的数据结构都可以通过<code>...</code>将其转化为数组</p></li><li><p><code>yield*</code>后跟一个可遍历数据结构时，会调用该结构的遍历器接口</p></li><li><code>for...of</code>, <code>Array.from</code>, <code>Map</code>, <code>Set</code>, <code>Promise.all()</code>, <code>Promise.race()</code></li></ul><h4 id="字符串、数组等的遍历器"><a href="#字符串、数组等的遍历器" class="headerlink" title="字符串、数组等的遍历器"></a>字符串、数组等的遍历器</h4><ul><li><p>字符串<br>for…of能够正确识别32位UTF-16字符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someString = <span class="string">"hi"</span>;</span><br><span class="line"><span class="keyword">typeof</span> someString[<span class="built_in">Symbol</span>.iterator]</span><br><span class="line"><span class="comment">// "function"</span></span><br><span class="line"><span class="keyword">var</span> iterator = someString[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="comment">// 当然你也可以修改Symbol.iterator方法达到你想要的遍历结果</span></span><br><span class="line">iterator.next()  <span class="comment">// &#123; value: "h", done: false &#125;</span></span><br><span class="line">iterator.next()  <span class="comment">// &#123; value: "i", done: false &#125;</span></span><br><span class="line">iterator.next()  <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>return, throw方法<br>这两个方法都是在设置遍历器生成函数时可选的，一般配合generator使用，所以下次再说</p></li><li><p>数组</p><ul><li>for … of 只返回具有数字索引的键值的值</li><li>类数组对象可以使用数组的默认遍历生成器达到遍历效果（要求是数字索引以及具有length属性）</li></ul></li><li><p>Map, Set</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map遍历返回的是数组[k, v]，Set返回的是值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">' : '</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类数组对象<br>利用Array.from将其转化为数组，再使用数组的遍历器接口用for…of实现遍历</p></li></ul><h4 id="for-…-of-注意"><a href="#for-…-of-注意" class="headerlink" title="for … of 注意"></a>for … of 注意</h4><ul><li>可以结合break、continue、return使用</li><li>提供了多种数据结构的统一访问方式</li><li>相比for … in，后者遍历的是键，且键名为字符串，还可能会遍历原型上的键</li></ul></div></div><div class="article-footer"><div class="article-meta pull-left"><span class="post-categories"><i class="icon-categories"></i> <a href="/categories/code/">code</a> </span><span class="post-tags"><i class="icon-tags"></i> <a href="/tags/js/">js</a></span></div></div></article></main><footer class="site-footer"><p class="site-info">Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a><br>&copy; 2018 Derek Zhou</p></footer></div></div></body></html>