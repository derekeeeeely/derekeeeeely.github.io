<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[web crawler share]]></title>
    <url>%2Fposts%2F835c8e5b%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;简单的爬虫分享，未完待续…爬虫+pandora分享spider搜索引擎使用网络爬虫爬取网站信息，用于建立索引供用户搜索googlerobots.txt google爬取页面/接口，提取有效信息背景快递业务各大快递网点信息 yunda饿了么、美团外卖商家商家信息及配送相关信息动手node-crawler github访问页面，处理返回，提取数据12345678910111213141516// 列表爬虫const spider = new Carwler(&#123; callback(err, res, done) &#123; // do sth const detailQueue = [] detailSpider.queue(detailQueue) &#125;&#125;)// 详情爬虫const detailSpider = new Crawler()// 开始const run = () =&gt; &#123; const listQueue = [] // 需要爬取的内容队列 spider.queue(listQueue)&#125;cheerio去除了浏览器端相关部分的jQuery，能够解析标签，在server端对html进行一些和客户端jQuery一样的操作puppeteer谷歌出品，必属精品打开一个headless chrome，模拟访问，页面执行123456789101112131415161718async start() &#123; // launch browser this.browser = await puppeteer.launch(); this.logger.info("Service puppeteerService Started");&#125;async take(url) &#123; // create page const page = await this.browser.newPage(); page.setViewport(&#123; width: 1920, height: 1080 &#125;); await page.goto(url); // screenshot const buf = await page.screenshot(&#123; type: "jpeg", quality: 60 &#125;); await page.close(); return &#123; // 现在 IPC Hub 不能直接传递 Buffer，需要 base64。 list: buf.toString("base64") &#125;;&#125;example articleapi doc问题饿了么商家区域覆盖代理重试，加日志代理动态替换morepandoraservice]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>crawler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计网基础 持续更新ing]]></title>
    <url>%2Fposts%2F52924cd5%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;年底了，无心写代码，回头看看一些基础知识，持续更新中…网络层级实体层光纤，双绞线，无线电波等传输介质实体层的使命是实现物理连接数据链路层0 1表示低高电位，根据0 1分组形式构成一组独特的电信号链路层的使命是确定0 1分组以太网协议：一组电信号构成一个数据包，称为一帧，一帧包含标头(head)和数据包(data)一帧构成：6个字节（6*8个二进制位，对应12个十六进制位，对应网卡地址）目的物理地址6个字节 源物理地址 （MAC地址前6位是厂商编号，后6位是厂商的网卡流水号）2个字节 类型（标识帧中所含信息的上层协议）46-1500个字节 数据4个字节 CRC（循环冗余检测）校验码广播：以广播形式向本网络内所有计算机发送数据包，计算机根据head里的目的地址对比自身，相同则接收网络层链路层能实现同一子网内的计算机间通信，但对于不同子网的两台计算机，不能通过广播和MAC地址联系起来于是网络层定义了网络地址，用于判断计算机所处子网网络层的使命是实现不同子网的主机到主机间的通信IP协议：IP数据包放到以太网数据包的data部分，同样包含head和data两部分IPV4规定网络地址由32个二进制位组成（0.0.0.0 - 255.255.255.255）IP地址包括网络部分和主机部分，子网掩码为11111(网络部分位)000(主机部分位)，以IP地址和子网掩码相加判断是否位于同一子网IP数据包head为20-60字节，head+data最大为65535字节，超过1500字节需要分割发送（链路层以太网协议）ARP协议：通过IP地址获取MAC地址同一子网的所有计算机接收到一个包含目标IP地址和一个置空的MAC地址(FF:FF:FF:FF)的数据包，比对IP地址后作出回应，报告自己的MAC地址不同子网交由网关处理此时我们可以通过IP地址跨域子网间屏障，通过ARP协议根据IP地址再找到目标物理地址，实现互联网上任意两台主机的通信传输层端口是使用网卡的程序的编号主机+端口 = socket套接字传输层使命是实现端口到端口的通信UDP协议：数据包由head和data组成，head为8字节，总长不超过65535，一起放于IP数据包的data部分TCP协议：有确认机制的UDP，相比前者多了确认过程，更复杂也更可靠应用层应用层使命是规定应用程序的数据格式（DHCP,DNS,HTTP,FTP,SSH等）]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dz-pj 在线音乐SPA]]></title>
    <url>%2Fposts%2Ff0693436%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;一时兴起，写了个简单的音乐站，满足自己平时听歌的需要。欢迎朋友们试用、提issue、star~相关技术点viewreactantd平时做中后台业务习惯了，图个方便直接拿来用了，也不是很丑…storemobx相比于redux更轻，代码侵入小，虽然没有中间件，但小应用也够用来管理前端状态了serveraxios图个方便简单…后续封装个完善的请求模块NeteaseCloudMusicApi在自己的server上clone了大佬的这个项目，跑起来以后为前端提供api，获取数据源打包部署parcel如官网所说，零配置，作为嫌弃webpack麻烦到死的我来说真的是够用了。优势自带热更新零配置速度快劣势热更新有问题没有sourceMap，调试很麻烦nginx简单配置steps本地build上传github reposerver上git pull项目核心&emsp;&emsp;由于audio和lyric是两个分开的组件，为了维护状态，这两个组件看起来都不是很独立。&emsp;&emsp;后续考虑封装成一个更合理，更封闭的组件，比如对使用者来说只要传入musicList就可用。audio组件思路监听audio组件的事件举个栗子123456789101112131415// 实时进度条this.audio.addEventListener('timeupdate', () =&gt; &#123; let progress = 0 // 下一首的时候会先进到这里？！没获取到长度的时候会报错 if (!!this.audio.duration) &#123; progress = (this.audio.currentTime / this.audio.duration) * 100 &#125; this.props.passTime(this.audio.currentTime) this.props.form.setFieldsValue(&#123; slider: progress &#125;) this.setState(&#123; progress &#125;)&#125;)播放过程中监听时间变化，显示实时进度条、定位实时歌词位置。使用propspassTime (func)，用于将当前时间传出，存入store，方便lyric定位歌词位置musicList，播放列表insertMark，插入播放列表标志位 // 后续考虑优化changeMark (func)，用于将当前歌曲在播放列表中位置传出，存入store，方便lyric获取歌词功能支持搜索歌曲，添加到播放列表支持播放歌曲、切换上下首、切换循环单曲和列表顺序模式支持播放中拖动进度条、显示当前时间、调节播放音量lyric flow组件思路parse歌词字符串从网易云获取到的歌词长这样：我想要的是这样的：parse细节如下，其实也很简单，只要把对应歌词和时间对应上就好了1234567891011121314151617181920212223242526export default function parse(text) &#123; const lines = text.split('\n') const pattern = /\[\d&#123;2&#125;:\d&#123;2&#125;.\d*\]/g const lyrics = [] lines.map(line =&gt; &#123; const timeLines = line.match(pattern) const lyricLine = line.replace(pattern, "") if(timeLines &amp;&amp; timeLines.length) &#123; for (let i=0; i&lt;timeLines.length; i++) &#123; const timeLine = timeLines[i] const min = timeLine.replace(/(\[|\:|\]|\.)/g, "").slice(0, 2) const sec = timeLine.replace(/(\[|\:|\]|\.)/g, "").slice(2, 4) const seconds = (+min) * 60 + (+sec) lyrics.push(&#123; [seconds]: lyricLine || '......' &#125;) &#125; &#125; &#125;) lyrics.sort((a, b) =&gt; &#123; const keyA = +Object.keys(a)[0] const keyB = +Object.keys(b)[0] return keyA - keyB &#125;) return lyrics&#125;监听播放时间，根据时间对应找到落在的歌词位置，显示旁边两条歌词使用propslyric 当前歌曲的歌词currentTime 当前播放时间功能现在是显示两条，后续考虑做成文字走马灯，高亮当前播放的一条收获技术audio以前基本没用过，现在至少知道了一些生命周期事件以及常用属性的mobx和redux思想感觉是蛮接近的，都是单一数据源，都符合flux思想组件都需要去订阅store，mobx用inject，redux需要connectredux把store搞成一个大块头，mobx把多个store分开mobx直接通过action更新store，redux则通过action去调用reducer更新storeredux数据流的概念使得可以加入中间件，更好地处理异步请求小型应用用mobx绝对是方便快捷的正则是个好东西，虽然以前基本不写，但感觉还是要好好学，学好将受益无穷啊willReceiveProps以前用得少，最近疯狂在用，是时候回顾下react生命周期了待挖掘react-router 4react 16parcel这些东西都用上了，但是没有去具体了解，接下来会找个项目的机会好好研究下。]]></content>
      <categories>
        <category>projects</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node-v8 Isolate和GC]]></title>
    <url>%2Fposts%2F5f9de541%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Node/V8学习笔记系列1，关于Isolate（V8实例）和GC（垃圾回收机制）。JavaScript引擎js引擎：源代码-&gt;抽象语法树AST-&gt;字节码-&gt;JIT-&gt;本地代码V8：AST-&gt;JIT-&gt;本地代码V8Isolate&emsp;&emsp;V8引擎实例，是一个独立的虚拟机，对应一个或多个线程，但同时只允许一个线程进入。Isolate之间完全隔离，不共享任何资源。Handle&emsp;&emsp;V8对所有js值和对象的内存分配都是在Heap内，Heap由V8独立维护，失去引用的对象会被GC回收。Handle是对Heap中对象的引用，GC需要管理Handle，对象的Handle引用变化时GC可以回收该对象或者移动该对象的分区。&emsp;&emsp;Handle分为Local和Persistance两种。前者为局部对象，后者类似全局对象，需要类似于C++的new和delete的操作Persistent::New, Persistent::Dispose进行内存管理。&emsp;&emsp;Persistent::MakeWeak可以弱化引用，触发GC对被引用对象的回收。Scope&emsp;&emsp;作用域，是Handle（句柄）的容器，一个作用域内可以有很多句柄。&emsp;&emsp;HandleScope用于管理Handle，Context::Scope用于管理Context对象Context&emsp;&emsp;上下文环境，也可以理解为运行环境。&emsp;&emsp;例如：在A函数内有一个Context，调用B函数，又有一个Context，退出B回到A时又恢复了A的Context。GC&emsp;&emsp;基本问题：识别需要回收的内存。&emsp;&emsp;根对象或者被另一个活跃对象引用的对象是活跃的。V8的堆构成识别指针&emsp;&emsp;通过在指针的末位标记这个字是指针还是对象对象晋升&emsp;&emsp;对象在经历了多次新生代的清理后还幸存的时候，会被移动到老生代，即被晋升跨区指向&emsp;&emsp;新对象诞生时并没有指向他的指针，比如在老生区对象写操作的时候，产生了一个队新对象的引用，此时在写缓冲区被记录下这样的跨区指向。GC三步曲枚举根节点引用发现并标记活跃对象垃圾内存清理分代回收分两种：Scavenge和Mark-SweepScavenge 分配指针达到新生代末尾时清理Mark-Sweep 活跃超过两个小周期的对象，需要将其移动到老生区]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>v8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dz's 你好2018]]></title>
    <url>%2Fposts%2F8b1fc7d6%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;可能很难实现但还是怀着希望认认真真写下来的新年计划。学习前端javaScript和typeScript2018希望能追上js的脚步，掌握js这门语言的本质和es6-8的一些新东西typeScript希望能用起来，用得6起来node深入理解node的异步I/O实现，读一读libuv源码读一读node的几个內建模块源码尝试写npm包用node手撸server，比如搞个爬虫浏览器尝试了解V8实现框架类库react源码学习，掌握react和全家桶打包工具如webpack/Parcel熟练dubbo框架深入理解maybeweex小游戏、小程序其他兴趣点全栈之路计算机几门课程计算机原理计算机网络编译原理数据结构、算法学一门外语Python/go语言基础用学的这门语言实现一个系统其他兴趣点其他github写几个自己的项目技术博客记录每天的技术积累英语学习生活身体运动每周至少运动两次跑步、周末爬山、打球都可以早睡早起，好吃好喝平时8点起床，12点睡觉早餐都要吃，周末在家好好多吃点灵魂阅读写作每天至少阅读半小时非技术类书籍每天一份工作笔记（quiver），一份日记（手写日记本）每周至少一篇技术文章，一篇个人文章娱乐平时每天玩游戏时间不超过1小时多听听歌，看看电影，追追剧还能练练听力摄影学习学习其他每周给家里至少打一次电话记住宝宝的喜好，记下每一次旅行，每一个特殊的时刻记账，不乱花钱，学会攒钱，有机会学学理财]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>thinking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dz's 2017那些事]]></title>
    <url>%2Fposts%2F815e4034%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这是一篇正经的需要上交的年度总结。前言&emsp;&emsp;大概是第一次年度总结，大概率还会有第二次，希望有第二十次。&emsp;&emsp;提笔前很自然地想，这一年经历了些什么，有什么是值得写下来的，为什么值得，为什么要写下来？&emsp;&emsp;借着这次团队作业的机会，问问自己这些问题，写下来备忘。若有读来感到不适的内容，读者大大们可以自由略过啦~&emsp;&emsp;曾经有过每天打开ONE（没错，就是岳父的那个one）看一句话的习惯，后来大概懒了忘了，开始好几天看一次，一次读完错过的那些天。于是会想时间每天、每秒匀速地流动，实际上每天都是一样的。为了让时间的流动可感受，我们结合地球运行的规律定义了我们日常的时间：从秒到年。我们把每年的开始作为节日，作为一个重要的刻度，赋予这一天特殊的身份，可实际上抛去我们自己定义的时间观念，这一天其实既平凡又渺小。&emsp;&emsp;选择在这一天来做总结，不是因为这一天多么重要，而是因为知晓这一年你的感受、经历非常重要。时间会让人遗忘，遗忘的不止是做过什么，学过什么，更重要的是自己凭借对自己的拷问而定下的从开始到结束的目标。即便没有明确的目标，也有一条能够推导到这一目标的线索，即人对于自我的认识，这种认识在成长过程中也许会一点点修正，也许始终如一，我们需要用一个特定时刻来总结和记住的大概就是这样的对自我的认识。（对自我的认知当然包括自我感情的认知啦，例如对某某的爱意，介于这是一篇正经的需要上交的年度总结，还是跳过这部分啦）&emsp;&emsp;这是我理解的必要性。起源&emsp;&emsp;要说去年今天的心情，还得提一提大学。介于现在并不想回忆大学时光，简单总结到一句话：学没学好，玩没玩够。&emsp;&emsp;2016年毕业，毕业前是处境艰难的学渣阶级，绩点虽然没惨到毕不了业，但离保研的底线还是差了一些，美其名为不喜欢实验室做研究，准备落草工业界占山为王。4月边做毕设边实习，写下第一行js代码，毕业后转正，履历上多了个前端工程师的title。作为一只对力量一无所知的小绵羊，很幸运的一点是碰上了一个trust young的团队。一开始什么都不会写的时候，也是什么都可以写的时候，正好创业公司又缺人，几个月下来，前端、后台、数据组甚至运维大哥都成了可以一起干活的小伙伴。那个时候认识了个厉害的词叫全栈，后来知道我们的圈子太小，我的眼光太窄，我以为的全栈与真正的全栈相去甚远。&emsp;&emsp;大学的时候对什么都不感兴趣，工作以后却好像对什么都感兴趣，然而事实我心知肚明，我只是不知道该干什么而已。&emsp;&emsp;2017年1月1日，我心里没有答案。来杭前&emsp;&emsp;春节前，leader约谈绩效，第一次有人找我聊方向。&emsp;&emsp;leader提醒我，我在做的事情有点杂了。我明白他的好意（leader人很好，非常庆幸能在第一份工作遇上他这样的领路人），我记得当时给他的回答是接下来会深入前端。我确实是这么想的，只是心里还抱着一个疑问没有和任何人提起：我为什么要选择写代码？&emsp;&emsp;大学计算机专业，看起来写代码合情合理，但实际上任何时候选择都有很多，只是看自己愿不愿意。我的不愿意是因为害怕和对自己的不了解，害怕失败，害怕让家人失望，不了解自己的兴趣、长处和能力强弱。这些是大学里不需要思考的问题，懒了几年的我在猝不及防的毕业到来时没有勇气做出别的选择。&emsp;&emsp;完成第一个需求以后，事情开始变得不太一样了。&emsp;&emsp;需求本身可能很简单，但在开发者眼里，看到的可能是复杂的逻辑、无奈的实现，甚至是隐藏的bug。我们也许不关心一行代码对应哪些指令，操作哪几个寄存器，经历多少时钟周期，但我们不能遗忘这行代码长途跋涉，历经千山万水最终为我们实现功能的艰辛和执着。（读到这里感觉不适请快进。。。）这些都是属于开发者的东西，也是我在工作最初的一段时间内感到充实的原因。纯洁如白纸的我为了实现第一个需求开启了计算机人的自学模式，发现从不会到想办法解决的过程中自己异常的专注，不管问题有没有解决，至少感觉时间没有虚度。&emsp;&emsp;这种充实在后来几个月却渐渐消失了，因为熟悉了以后开始做重复的工作，而且因为量大，这样的工作占据了一天绝大多数时间。不仅没有挑战，不需要学习，而且没有多少时间剩余去学自己想学的，写自己的代码。（所以个人觉得对于程序员来说一份好的工作要么应该是充满挑战的，要么是能让你有富余时间做自己的）&emsp;&emsp;春节过后，公司突然慢了下来，工作外的时间变多了，就又开始做些有趣的事情了。&emsp;&emsp;没记错的话那时候在和微信打交道，小程序啊公众号啊，觉得挺新奇的。（当初自作主张给公司的公众号接了个第三方的聊天机器人，至今好像还没被大佬们发现…）程序员的世界是这样的，一个问题抛出来，可能会变成一张网，想要彻底弄清楚一件事情，你会发现你的问题越来越多，所以需要不断地全面地去学习理解。这是我觉得很有意思，也很想做的事情，我理解的是要形成一个完整的知识体系需要持续的不懈的学习，从兴趣点出发去往外一点点拓展而不是刻意去按部就班学，会是更好的选择。&emsp;&emsp;3月的时候，公司业绩被萨德影响却显得异常平静，而我则接了个整站重构的需求，和后台大兄弟两人坐在一块，起早贪黑撸起袖子干得不亦乐乎。可能重构的时候太投入了，并没有觉得公司会倒下。。。&emsp;&emsp;4月，暴风雨袭来，公司开始大规模裁员，从CTO到普通员工接连出走。其实决定离开的时候还是有些不舍的，毕竟是毕业后第一份工作，遇上的第一批共事的可爱的人们，一个还不错的工作氛围。&emsp;&emsp;离职前的一个月，处于放养状态的我开始手撸博客，用的正是为公司官网重构时学习的nuxt框架。作为一名渣渣前端新人，靠着吃大学仅有的一点老本完成开发、部署，搞了个自己的服务器，自己的博客站。哇，当时真是开心得不行，三天两头看阿里云服务器访问日志，结果可想而知，只有我自己。把这个东西勉强称为作品的话，虽然非常希望有人认可，但更重要的还是作品实现的过程中做出的努力和学到的东西。&emsp;&emsp;生活的理想是为了理想的生活，对于人生经历尚浅的我来说，这是目前最能接受的一句话了。工作让我衣食无忧，碰巧程序员的世界里又不缺挑战，这些挑战让我的一年不是1*365天的重复，而是每天都能通过学习而收获，进而丰富自己的认知。学习中重要的不是仅仅几个框架、几门语言，而是实现目标的思维方式和逻辑过程，能够收获这些，大概就是我现阶段理想的生活了。香波地&emsp;&emsp;6月转移阵地来杭州，加入点我达大家庭。&emsp;&emsp;开始的几天感觉像是乡下孩子进城，眼前看到的都是新奇有趣的事情，才发现自己的池子有多浅，以至于一时沉迷学习无法自拔。碗里水少的一个好处在于能多装，学习react/redux/dubbo这些东西的过程比我想象得要顺利些。看项目的时候发现很多以前根本不知道的东西，瞬间觉得自己怎么这么菜，前端的水比自己想得深太多太多了。&emsp;&emsp;新手保护结束后，提起键盘就是干。从小需求开始熟悉项目，主要是新老鹰眼，其实这两个项目本质上还是很接近的，react作为view层的实现，基于flux思想的数据流动分别由reflux和redux来实现。cs = 数据结构 + 算法，就做需求而言，我需要用到复杂算法的机会很少，所以了解了数据结构和数据整个流向其实开发问题就不大了。&emsp;&emsp;前两个月基本上都是这样，感觉都是一个套路，需求完成得挺快也没什么问题，多余很多时间花在了自己看书学习上。然后问题出现了，简单的需求确实可以在知之不详的情况下快速开发，但碰到细节问题的时候凭着半吊子的水平就显得捉襟见肘了。只看到大概就以为理解了，实际上核心的实现以及隐藏的问题都需要花时间啃透，于是开始在卡住的地方尝试深挖，看看源码，各种查资料。踩坑学习之旅通常都是痛并快乐着的。&emsp;&emsp;8月以后每天开始写小笔记，quiver上简单记一记，有项目时间安排，有学到的东西，也有未来几天的计划。好记性不如烂笔头，我的理解是记下来的好处更多的不是在于以后能翻出来看（我写的笔记好像基本没看过），而在于延长了学习的时间，动笔的时候会更深入地去思考这些内容，是不是有更深的地方可以挖掘。项目和计划写下来的好处是每天都有了时间规划，不会因为无聊而被迫去思考宇宙和人生，有效地保护了发际线。&emsp;&emsp;解决了技术上的问题以后，碰到的是一些流程上的坑。可以感觉到的是我司其实一开始在项目开发流程上也是不太合理的，几个月调整下来，虽然还有些问题，但应该是比较稳定规范了。这个过程对我来说也促成了一种转变，上一家的时候，项目时间相对自由，即便有的时候开发时间限定死了，还是可以允许带bug提测。上线也是一样，除了app外没有严格限制时间，有问题可能临时修复，马上就发掉了。可以说对开发的质量要求并不高。。。近期我司的发布窗口和故障系统可以说很严格了，虽然带来了一些麻烦，但确实能够提高我们对自己的要求。&emsp;&emsp;说到这里必须先检讨下近期的几个需求，好几个都是一眼就能够发现的问题却硬生生被忽略掉，上线才冒出头，命大没算故障，却是敲了好几道警钟。主要还是自己不够小心，一直很不喜欢去review自己的代码，因为要是去看的话大概率会想推倒重来。一方面还是要写代码的时候多想想可能的问题，一方面自测的时候要上心点，至少跑一遍测试用例，保证代码质量。&emsp;&emsp;近两个月的话其实工作上还是照旧，只是需求一个个做下来，对需求理解更到位了，和服务对接时的成本更低了，开发过程中要开的会多了。忙里偷闲又搞了个博客，把之前手撸的那个干掉了，不知道这次这个博客能活多久。&emsp;&emsp;坦白说，我个人是属于那种很难找到归属感的人。。。一个人、一群人，相处久了，感情都会自然沉淀，但是我不能把这种感情理解为团队归属感。我可以说很喜欢大家，是因为和大家在一起工作很舒服，一起吃饭聊天玩耍很开心。以人为镜我学到了很多，与人为伴使我感到温暖，也丰富了我的生活，为此我心存感激。但是这样的心情并不是只对团队中的大家才有的，虽然很遗憾，但我确实还找不到归属感。生活&emsp;&emsp;还是暂时不聊了。一言以蔽之&emsp;&emsp;说是年度总结，其实也没怎么写具体的工作和收获内容，不是不愿，而是觉得这些才是我想写下来的，以后可能会翻一翻的内容。（如果需要具体工作内容总结大佬可以私聊下，回头我补一份。。。）写下这篇文章，希望在以后的某一天能够帮忙回忆起这一年的心中所想，是否和曾经的自己已经大不一样，生活是否如那年期许？2018.1.1&emsp;&emsp;越是学习，越觉得自己功力浅薄，好在今天的目标和6月定下的相差无二。&emsp;&emsp;前路漫漫，惟愿日拱一卒。]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>thinking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mvx 从todo mvc说起]]></title>
    <url>%2Fposts%2Fc4697232%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在git上看到一个to do mvc的repo，一时有了兴致，记录下一些点。历史静态/展示-&gt;动态/交互web1.0时代，服务端直接将数据填充进模板，生成Html返回给浏览器，静态网页，纯展示web2.0时代，动态网页，前端向服务端请求数据，然后自己处理数据，提供了用户和浏览器的交互前端mv*的必要性前端进入到需要保存数据、处理数据和生成视图的web2.0时代webapp的概念，web不再是页面级，而是application级别，所以需要思考应用的管理，数据的流向等todo mv*其实差别就前端如何管理数据，以及数据如何和视图联系起来backbone只有Model和View结构├── index.html├── js├── app.js ├── collections │ └── todos.js ├── models │ └── todo.js ├── routers │ └── router.js └── views ├── app-view.js └── todo-view.js 以新增为例1234567891011121314151617181920212223242526272829303132333435363738394041424344// views/app-view.js// 绑定节点el: '.todoapp',// 声明事件events: &#123; 'keypress .new-todo': 'createOnEnter',&#125;// 用户在view层enter，调用collection的方法创建新的todo modelcreateOnEnter: function (e) &#123; if (e.which === ENTER_KEY &amp;&amp; this.$input.val().trim()) &#123; app.todos.create(this.newAttributes()); this.$input.val(''); &#125;&#125;// collections/todos.jsvar Todos = Backbone.Collection.extend(&#123; // Reference to this collection's model. model: app.Todo,&#125;)// models/todo.jsapp.Todo = Backbone.Model.extend(&#123; defaults: &#123; title: '', completed: false &#125;&#125;)// viwes/todo-views.js// 绑定模板template: _.template($('#item-template').html()),// 监听model的change，注册回调renderinitialize: function () &#123; this.listenTo(this.model, 'change', this.render);&#125;// render方法，将model数据填充render: function () &#123; if (this.model.changed.id !== undefined) &#123; return; &#125; this.$el.html(this.template(this.model.toJSON())); return this;&#125;定义model和collection，在view层通过事件触发model层行为，改变数据后，通过事先注册的监听model变化的回调函数来更新viewvuemodel, view, modelview (mvvm)结构├── index.html├── js│ ├── app.js│ ├── routes.js│ └── store.js新增为例1234567891011121314151617181920212223242526// app.js// vue对象，连接view和model的vmexports.app = new Vue(&#123; // 绑定节点 el: '.todoapp', // 定义数据模型 data: &#123; todos: todoStorage.fetch(), newTodo: '', &#125;, // 修改数据模型的方法 methods: &#123; addTodo: function() &#123; var value = this.newTodo &amp;&amp; this.newTodo.trim(); if (!value) &#123; return; &#125; this.todos.push(&#123; id: this.todos.length + 1, title: value, completed: false &#125;); this.newTodo = ''; &#125; &#125;&#125;)// index.html// v-modal将数据（vm）和节点（v）绑定，通过事件触发vue对象的方法改变数据，并通过观察者模式和自定义的访问器实现view的更新&lt;input class="new-todo" autofocus autocomplete="off" v-model="newTodo" @keyup.enter="addTodo"&gt;vm实际上是简化的controller，将model数据简单处理，为view提供正确的数据reactreact只是视图层解决方案，本质是将图形界面（GUI）函数化。view是state的输出，引自阮一峰老师 js view = f(state)组件state/props用于数据存储流转，render函数输出view，事件驱动产生数据变化，setState重新render…结构├── index.html├── js│ ├── app.jsx│ ├── footer.jsx│ ├── todoItem.jsx│ ├── todoModel.js│ └── utils.js1234567891011121314151617181920212223242526272829303132333435363738394041424344// todoModel.js// 定义model，在原型上定义一些方法，比如存数据到localstorage里持久化app.TodoModel = function (key) &#123; this.key = key; this.todos = Utils.store(key); this.onChanges = [];&#125;;// 注册回调进行订阅app.TodoModel.prototype.subscribe = function (onChange) &#123; this.onChanges.push(onChange);&#125;;// 调用inform时通知各个订阅者，执行回调app.TodoModel.prototype.inform = function () &#123; Utils.store(this.key, this.todos); this.onChanges.forEach(function (cb) &#123; cb(); &#125;);&#125;;// app.jsxvar TodoApp = React.createClass(&#123; // 初始化state getInitialState: function () &#123; return &#123; newTodo: '' &#125;; &#125;, // 事件触发，setState，重新render handleChange: function (e) &#123; this.setState(&#123;newTodo: e.target.value&#125;); &#125;, render: function () &#123; return &lt;div&gt; &lt;input onChange=&#123;this.handleChange&#125; /&gt; &lt;div&gt;&#123;this.state.newTodo&#125;&lt;/div&gt; &lt;/div&gt; &#125;&#125;)var model = new app.TodoModel('react-todos');function render() &#123; React.render( &lt;TodoApp model=&#123;model&#125;/&gt;, document.getElementsByClassName('todoapp')[0] );&#125;model.subscribe(render);render()flux不同组件的state放在一个外部的通用的store里每个组件订阅该store的一部分组件内通过dispatch一个action去触发store的更新redux状态都存放在store中，组件的重新渲染都由状态改变来触发用户通过在view层dispatch action触发reducer，在reducer中 new = f(old) 计算得到新的stateUI组件和容器组件UI组件负责页面外观容器组件负责数据和行为，订阅store，处理store的数据然后传递给UI组件，例如connect方法Provider和connect前者将react应用包一层，使得组件和store可被连接，同时传入store1234567const store = createStore(reducer);ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.body.appendChild(document.createElement('div')));store由redux得createStore方法提供，该方法接收reducer作为参数，实际上相当于定义了action list对应的处理对象和方案connect将UI组件和容器组件连接，使得在我们的UI/业务组件中能够获取到最初定义好的store，并在UI组件中通过dispatch action去对上一条所说的处理对象执行处理方案reducer-纯函数12345678910111213// 接收旧的state和action，返回新的statefunction reducer(state = &#123; text: '你好，访问者', name: '访问者'&#125;, action) &#123; switch (action.type) &#123; case 'change': return &#123; name: action.payload, text: '你好，' + action.payload &#125;; &#125;&#125;典型的MV*，model对应于store，view对应于业务组件，连接起来或者说数据处理交由action reducer完成，适合于大型应用。MobxUI 层是观察者，Store 是被观察者。🌰 下回分解12345678const &#123;observable&#125; = mobx;const &#123;observer&#125; = mobxReact;const person = observable(&#123;name: "张三", age: 31&#125;);const App = observer( (&#123; person &#125;) =&gt; &lt;h1&gt;&#123; person.name &#125;&lt;/h1&gt;);ReactDOM.render(&lt;App person=&#123;person&#125; /&gt;, document.body);person.name = "李四";]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>mvx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dz-life 摄影小笔记]]></title>
    <url>%2Fposts%2F2082e7b0%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;我能想到最浪漫的事…之一，就是用镜头记录下你最美的瞬间。小呆学摄影基础篇概念曝光也即是进光量，可以通过光圈、快门共同控制快门快门控制进光时间，高速快门（如1/8000）拍清晰瞬间（如猎豹抓🐑），低速快门拍运动过程（如丝绸状水流，动云+静山的动静结合图）光圈光圈控制进光量，大光圈（数值小如1.2）可以配合快速快门，在曝光准确的情况下防抖大光圈的清晰范围更少（小景深），造成前景清晰，背景模糊的虚实关系，画个图可以理解单反镜头物镜是一组凸透镜，变焦镜头支持一个区间的焦距，比如尼康18-140，属于中长焦的镜头焦距影响的是目标物体占据成像区域的面积比例，emmm，画个图大概就清楚了，长焦拍得这个比例更大，看起来好像离物体更近机身全画幅/半画幅通过相机的感光元件的成像面积区分，画个图应该能理解，全画幅能够达到拍摄范围更广的效果是否支持全画幅要看机身类型结构单反的物镜兼职取景镜，利用毛玻璃反射和五棱镜/五面镜折射/反射，将倒立的像矫正完成光学取景感光元件相当于曾经的底片，快门按下，毛玻璃弹起，光线射到感光元件成像进阶光圈优先 A/AV光圈直接影响景深，所以这种模式适用广泛，拍人比如2.8，3.5大光圈，拍景物，为了前中后景都清晰，可以用8以上快门优先 S/TV快门可以控制画面的运动效果，看是要高速瞬间还是丝滑轨迹1/60 拍不动的人 1/400拍个汽车 1/2拍丝绸般水流曝光补偿看测光标尺，设置曝光补偿]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>摄影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dubbo-rpc 初探rpc]]></title>
    <url>%2Fposts%2Fc48da636%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;抱着学习理解dubbo的心思，从各方大佬身上取经，记下学习笔记，方便自己，服务志同道合的小伙伴们。RPC远程过程调用协议（Remote Procedure Call Protocol）speak chinese:&emsp;部署在A服务器上的应用a需要调用部署在B服务器上的b应用提供的c函数/方法，这个时候就需要实现远程过程调用，RPC就是实现这一功能的协议。本地过程调用:&emsp;举个🌰1234567int add(int a, int b) &#123; int c = a + b; return c;&#125;int a1 = 1;int b1 = 2;int c1 = add(a1, b1);int c1 = add(a1, b1)执行过程：将a1, b1值压栈进入add函数，取出栈中a1, b1，赋值给a, b计算a + b，将结果存在cc压栈，从add函数返回从栈中取出c的值，赋值给c1那么问题来了&emsp;本地调用由于函数/参数都存在内存中，可以直接调用/读取，合情合理，不需要做特别处理。&emsp;而上面栗子中的a应用要完成使命，首先需要和b应用通过网络建立进程间通信，然后将参数以某种b应用能够理解的形式传递过去，并且b应用需要按照某种约定准确找到c函数/方法，返回结果的过程类似。&emsp;对于负责业务代码的程序员来说，我们不关注远程调用的细节，我们希望的是远程调用能够做到和本地调用看起来是一样的，这样我们所写的代码不需要考虑调用场景特殊化处理。这一点需要实现以下几部分：call ID 映射本地调用函数直接会找到函数指针，远程调用时，地址空间毫无关联，所以需要给所有的函数一个ID，消费端和提供端都需要维护这样一个ID映射，在远程调用时，消费者会带上这个ID，提供端根据ID找到相应的函数再去执行。序列化/反序列化由于必须通过网络传输传递参数，传输两端需要能够理解交换的数据，原本存储在内存中的参数值在消费端进行序列化，到达提供端后进行反序列化恢复成内存中的表达形式，然后在提供端执行函数/方法，返回结果类似，同样需要序列化和反序列化。网络传输网络传输这一块大部分RPC框架使用TCP协议，实际上能够实现网络传输目的的其他一些协议也是适用的。RPC结构图解&emsp;RPC 服务方通过 RpcServer 去export远程接口方法，而客户方通过 RpcClient 去import远程接口方法。&emsp;客户方像调用本地方法一样去调用远程接口方法，RPC 框架提供接口的代理实现，实际的调用将委托给代理 RpcProxy 。&emsp;代理封装调用信息并将调用转交给 RpcInvoker 去实际执行。&emsp;在客户端的 RpcInvoker 通过连接器 RpcConnector 去维持与服务端的通道 RpcChannel，并使用 RpcProtocol 执行协议encode并将编码后的请求消息通过通道发送给服务方。&emsp;RPC 服务端接收器 RpcAcceptor 接收客户端的调用请求，同样使用 RpcProtocol 执行协议decode。解码后的调用信息传递给 RpcProcessor 去控制处理调用过程，最后再委托调用给 RpcInvoker 去实际执行并返回调用结果。RPC组件RpcServer 用于服务方导出远程接口方法，RpcClient 用于客户方引入接口方法的代理实现RpcProxy 是远程接口方法的代理实现RpcInvoker客户方实现：负责编码调用信息和发送调用请求到服务方并等待调用结果返回服务方实现：负责调用服务端接口的具体实现并返回调用结果RpcProtocol 负责编解码RpcConnector 负责维持客户方和服务方的连接通道和发送数据到服务方RpcAcceptor 负责接收客户方请求并返回请求结果RpcProcessor 负责服务方控制调用过程，包括管理调用线程池、超时时间等RpcChannel 数据传输通道组件具体实现后续参考dubbo框架再来学习问题远程调用可能由于网络问题没有到达服务方，所以调用未必一定执行远程调用抛出的异常可能是RPC框架运行时异常远程调用消耗肯定是高于本地调用的，所以考虑导出为远程接口的前提是计算消耗远大于RPC的固有消耗上述内容部分引用自 深入浅出 RPC - 深入篇Dubbo惯例吹一波基于java的高性能开源RPC框架，主要实现了RPC远程调用、集群容错和负载均衡、服务管理和监控三大块功能。]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>rpc</tag>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-es6 异步篇]]></title>
    <url>%2Fposts%2F7819203f%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;承上一篇，本文记录了es6的Promise对象、Generator函数和async await语法糖，异步真是让人又爱又恨。lesson1 Promise你的名字Promise 诞于社区，初为异步编程之解决方案，后有ES6将其写入语言标准，终成今人所言之 Promise 对象Promise对象特点有二：状态不受外界影响、一旦状态改变后不会再次改变基本用法Promise对象为一个构造函数，用于生成Promise实例12345678// 接受一个函数作为参数，函数参数有两个，为js引擎内部实现的两个函数let pr = new Promise(function(resolve, reject) &#123; if () &#123; resolve() // pending -&gt; resolved &#125; else &#123; reject() // pending -&gt; rejected &#125;&#125;)Promise实例生成后可以使用then方法指定两种状态下的回调函数123456// 第二个函数可选pr.then( function(value) &#123; // do something&#125;, function(error) &#123; // throw error&#125;)so…封装一个函数，返回一个Promise对象，在Promise实例创建时传入的函数参数内进行逻辑处理（决定何时改变状态并传递值到回调函数）利用Promise实例的then方法接收上一步的传递值处理后续（resolve传递的值可以为Promise对象，reject传递的值多为Error对象）注意：resolve或reject并不会终结 Promise 的参数函数的执行，因为立即resolve或reject的Promise是在本次时间循环尾部，晚于本轮的同步任务注意：一般resolve或者reject之后Promise任务完成了，后续应该写在then的回调函数内，所以可以这样return resolve(value)我愚蠢的孩子们Promise.prototype.then参数：两个函数，后一个可选返回：新的Promise实例可以采用链式写法，上一个回调函数的返回值会作为参数传递到下一个回调函数内若上一个回调函数返回的是Promise则需要等状态改变再调用下一个回调函数1234567getJSON("/post/1.json").then( // 返回的是一个Promise，其状态改变后根据状态选择调用下面的then中的哪个回调函数 post =&gt; getJSON(post.commentURL)).then( comments =&gt; console.log("resolved: ", comments), err =&gt; console.log("rejected: ", err));Promise.prototype.catch实际上：是.then(null, rejection)的别名链式写法最后一个catch可以捕获前面任何一个Promise对象then方法抛出的error推荐使用catch，而不是两个回调函数作为参数若没有指定错误处理的回调，Promise会吃掉错误，不会退出进程、终止脚本运行catch方法里还可以再抛错，再链式catch…Promise.all参数： 具有Iterator接口返回： Promise实例们1var p = Promise.all([p1, p2, p3]);p1, p2, p3都为fullfilled时p才fullfilled，其中一个rejected则p就rejected如果其中一个Promise实例定义了catch，错误会被自己的catch捕获然后返回一个新的Promise实例，在执行完catch后该实例也resolved，所以不会被外部p的catch捕获到，若没有，当然会被外面捕获到啦Promise.race概述：同样是多个Promise实例，第一个状态改变的Promise实例会使得p状态跟着改变用处🌰：一定时间内获取不到就rejected12345678const p = Promise.race([ fetch('/resource-that-may-take-a-while'), new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; reject(new Error('request timeout')), 5000) &#125;)]);p.then(response =&gt; console.log(response));p.catch(error =&gt; console.log(error));Promise.resolve/Promise.reject嗯123Promise.resolve('foo')// 等价于下面，即生成一个Promise实例，状态为resolved，且将值传给回调函数new Promise(resolve =&gt; resolve('foo'))情况参数为thenable对象，即具有then方法的对象 =&gt;将对象封装为Promise对象，立即执行原对象的then方法，然后在根据状态变化去调用Promise.then的回调函数不是thenable对象或者不是对象参见嗯不传参数，返回一个resolved的Promise对象注意：立即resolve的Promise对象，是在本轮“事件循环”（event loop）的结束时，而不是在下一轮“事件循环”的开始时注意：Promise.reject(res)有一点不同，在于参数res直接作为rejected的理由，原封不动地被catchPromise.done/Promise.finally前者表示无论如何都会接收到可能的错误，全局抛出，后者是无论如何都会在最后执行传入的callback12345678910111213141516// donePromise.prototype.done = function (onFulfilled, onRejected) &#123; this.then(onFulfilled, onRejected) .catch(function (reason) &#123; // 抛出一个全局错误 setTimeout(() =&gt; &#123; throw reason &#125;, 0); &#125;);&#125;;// finallyPromise.prototype.finally = function (callback) &#123; let P = this.constructor; return this.then( value =&gt; P.resolve(callback()).then(() =&gt; value), reason =&gt; P.resolve(callback()).then(() =&gt; &#123; throw reason &#125;) );&#125;;Promise.try提案：模拟try，是异步就异步，是同步就同步，就提提，再说lesson2 Generator初探概念一个遍历器生成函数，一个状态机调用Generator函数，返回一个遍历器，代表Generator函数的内部指针（此时yield后的表达式不会求值）每次调用next方法会执行下一个yield前的语句并且返回一个{value, done}对象，其中value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值，done属性是一个布尔值，表示是否遍历结束若没有yield了，next执行到函数结束，并将return结果作为value返回，若无return则为undefined。这之后调用next将返回{value: undefined, done: true}yield惰性调用next方法时，将yield后的表达式的值作为value返回，只有下次再调用next才会执行这之后的语句，达到了暂停执行的效果，相当于具备了一个惰性求值的功能没有yield时，Generator函数为一个单纯的暂缓执行函数（需要调用next执行）yield只能用于Generator函数Iterator接口Generator函数为遍历器生成函数，可以赋给对象的Symbol.iterator方法，本身也具有Symbol.iterator属性123456function* gen()&#123; // some code&#125;var g = gen();g[Symbol.iterator]() === g// truefor…ofGenerator函数返回的是遍历器对象，可以直接用for…of访问注意：done为true的会被for…of忽略利用Generator为对象实现Iterator接口12345678910111213function* objectEntries() &#123; let propKeys = Object.keys(this); for (let propKey of propKeys) &#123; yield [propKey, this[propKey]]; &#125;&#125;let jane = &#123; first: 'Jane', last: 'Doe' &#125;;jane[Symbol.iterator] = objectEntries;for (let [key, value] of jane) &#123; console.log(`$&#123;key&#125;: $&#123;value&#125;`);&#125;// first: Jane// last: Doe方法Generator.prototype.next()参数通过传入参数为Generator函数内部注入不同的值来调整函数接下来的行为第一次next传递的参数会被忽略（实在想传得包一层）123456789101112// 这里利用参数实现了重置function* f() &#123; for(var i = 0; true; i++) &#123; var reset = yield i; if(reset) &#123; i = -1; &#125; &#125;&#125;var g = f();g.next() // &#123; value: 0, done: false &#125;g.next() // &#123; value: 1, done: false &#125;// 传递的参数会被赋值给i（yield后的表达式的值(i)），然后执行var reset = i赋值给resetg.next(true) // &#123; value: 0, done: false &#125;Generator.prototype.throw()Generator函数返回的对象都具有throw方法，用于在函数体外抛出错误，在函数体内可以捕获（只能catch一次）参数可以为Error对象如果函数体内没有部署try…catch代码块，那么throw抛出的错会被外部try…catch代码块捕获，如果外部也没有，则程序报错，中断执行throw方法被内部catch以后附带执行一次next函数内部的error可以被外部catch如果Generator执行过程中内部抛错，且没被内部catch，则不会再执行下去了，下次调用next会视为该Generator已运行结束Generator函数返回的对象在被next访问完后内部属性[[GeneratorStatus]]值变为’closed’了Generator.prototype.return()try ... finally存在时，return会在finally执行完后执行，最后的返回结果是return方法的参数，这之后Generator运行结束，下次访问会得到{value: undefined, done: true}try ... finally不存在时，直接执行return，后续和上一条一致实际上以上三种方法都是让Generator恢复执行，并用语句替换yield表达式yield*表达式在一个Generator内部直接调用另一个Generator是没用的，如果需要在一个Generator内部yield另一个Generator对象的成员，则需要使用yield*1234567891011121314function* inner() &#123; yield 'a' // yield outer() // 返回一个遍历器对象 yield* outer() // 返回一个遍历器对象的内部值 yield 'd'&#125;function* outer() &#123; yield 'b' yield 'c'&#125;let s = inner()for (let i of s) &#123; console.log(i)&#125; // a b c dyield*后跟一个遍历器对象（所有实现了iterator的数据结构实际上都可以被yield*遍历）被代理的Generator函数如果有return，return的值会被for…of忽略，所以next不会返回，但是实际上可以向外部Generetor内部返回一个值，如下：1234567891011121314151617181920212223function *foo() &#123; yield 2; yield 3; return "foo";&#125;function *bar() &#123; yield 1; var v = yield *foo(); console.log( "v: " + v ); yield 4;&#125;var it = bar();it.next()// &#123;value: 1, done: false&#125;it.next()// &#123;value: 2, done: false&#125;it.next()// &#123;value: 3, done: false&#125;it.next();// "v: foo"// &#123;value: 4, done: false&#125;it.next()// &#123;value: undefined, done: true&#125;举个🌰12345678910111213141516171819202122// 处理嵌套数组function* Tree(tree)&#123; if(Array.isArray(tree))&#123; for(let i=0;i&lt;tree.length;i++) &#123; yield* Tree(tree[i]) &#125; &#125; else &#123; yield tree &#125;&#125;let ss = [[1,2],[3,4,5],6,[7]]for (let i of Tree(ss)) &#123; console.log(i)&#125; // 1 2 3 4 5 6 7// 理解for ...of 实际上是一个while循环var it = iterateJobs(jobs);var res = it.next();while (!res.done)&#123; var result = res.value; // ... res = it.next();&#125;Extra作为对象的属性的Generator函数写法很清奇12345678910let obj = &#123; * sss() &#123; // ... &#125;&#125;let obj = =&#123; sss: function* () &#123; // ... &#125;&#125;Generator函数的thisGenerator函数返回的是遍历器对象，会继承prototype的方法，但是由于返回的不是this，所以会出现：12345function* ss () &#123; this.a = 1&#125;let f = ss()f.a // undefined想要在内部的this绑定遍历器对象？js灵活特性尽显…1234567891011function * ss() &#123; this.a = 1 yield this.b = 2; yield this.c = 3;&#125;let f = ss.call(ss.prototype) // 由于f.__proto__ === ss.prototype，传入遍历器对象的隐藏原型给thisf.next()f.next()f.a // 1f.b // 2f.c // 3应用举个🌰123456789// 利用暂停状态的特性let clock = function* () &#123; while(true) &#123; console.log('tick') yield console.log('tock') yield &#125;&#125;异步操作的同步化表达123456789101112131415// Generator函数function* main() &#123; var result = yield request("http://some.url"); var resp = JSON.parse(result); console.log(resp.value);&#125;// ajax请求函数，回调函数中要将response传给next方法function request(url) &#123; makeAjaxCall(url, function(response)&#123; it.next(response); &#125;);&#125;// 需要第一次执行next方法，返回yield后的表达式，触发异步请求，跳到request函数中执行var it = main();it.next();控制流管理123456789// 同步stepslet steps = [step1Func, step2Func, step3Func];function *iterateSteps(steps)&#123; for (var i=0; i&lt; steps.length; i++)&#123; var step = steps[i]; yield step(); &#125;&#125;// 异步后续讨论部署Iterator接口看做数组结构使用lesson3 Generator的异步应用前言异步一个任务拆分成两个阶段，比如任务是读取一个文件并返回一个结果a。拆分为向操作系统发起请求，然后执行别的操作，再在操作系统返回文件以后去返回一个结果a。不连续的执行，称为异步回调函数传统的异步实现是通过将第二阶段的操作以函数形式作为参数传递到任务处理方法内，在第一阶段的执行有了结果以后，回调函数才会执行node约定，回调函数的第一个参数必须为错误对象，因为第一阶段执行完后，任务得上下文环境结束了。这之后抛出的错误需要传入回调函数才能被捕获处理Promise其实只是写法上的区别，依然是以回调函数的方式实现异步Generator函数协程coroutine协程A执行-&gt;协程A暂停，执行权转交给协程B-&gt;一段时间后执行权交还A-&gt;A恢复执行123456// yield是异步两个阶段的分割线function* asyncJob() &#123; // ...其他代码 var f = yield readFile(fileA); // ...其他代码&#125;Generator函数实现协程Generator函数实际上可以作为异步任务的容器，在异步任务需要暂停的地方加上yield注明即可Generator函数的错误处理和数据交换next方法使得Generator可以接收外部参数，next返回值的value属性是Generator向外的输出值（数据交换实现）错误处理上一课有讲述Thunk函数参数的求值策略传名调用和传值调用之争后者更简单，但是可能会有需要大量计算求值却没有用到这个参数的情况，造成性能损失js中的Thunk函数传统的Thunk函数是传名调用的一种实现，即将参数作为一个临时函数的返回值，在需要用到参数的地方对临时函数进行求值js中的Thunk函数略有不同js中的Thunk函数是将多参数函数替换为单参数函数（这个参数为回调函数）1234567const Thunk = function(fn) &#123; return function (...args) &#123; return function (callback) &#123; return fn.call(this, ...args, callback); &#125; &#125;;&#125;;看起来只是换了个样子，好像并没有什么用Thunk函数实现Generator函数自动执行Generator函数自动执行12345678910function* gen() &#123; yield a // 表达式a yield 2&#125;let g = gen()let res = g.next()while(!res.done) &#123; console.log(res.value) res = g.next() // 表达式b&#125;但是，这不适合异步操作。如果必须保证前一步执行完，才能执行后一步，上面的自动执行就不可行。上面这句话是不是可以这样理解，比如表达式a是一个异步操作，回调函数中设置了延时执行，而这个回调函数执行前表达式b可能已经被执行了，进入到下一个循环。所以无法保证执行顺序，所以需要管理回调函数next方法是同步的，执行时必须立刻返回值，yield后是同步操作当然没问题，是异步操作时就不可以了。处理方式就是返回一个Thunk函数或者Promise对象。此时value值为该函数/对象，done值还是按规矩办事。1234567891011var g = gen();var r1 = g.next();// 重复传入一个回调函数r1.value(function (err, data) &#123; if (err) throw err; var r2 = g.next(data); r2.value(function (err, data) &#123; if (err) throw err; g.next(data); &#125;);&#125;);Thunk函数的自动流程管理思路：Generator函数中yield 异步Thunk函数，通过yield将控制权转交给Thunk函数，然后在Thunk函数的回调函数中调用Generator的next方法，将控制权交回给Generator。此时，异步操作确保完成，开启下一个任务。Generator是一个异步操作的容器，实现自动执行需要一个机制，这个机制的关键是控制权的交替，在异步操作有了结果以后自动交回控制权，而回调函数执行正是这么个时间点。1234567891011121314151617181920212223242526272829303132// Generator函数的执行器function run(fn) &#123; let gen = fn() // 传给Thunk函数的回调函数 function cb(err, data) &#123; // 控制权交给Generator，获取下一个yield表达式（异步任务） let result = gen.next(data) // 没任务了，返回 if (result.done) return // 控制权交给Thunk函数，传入回调 result.value(cb) &#125; cb()&#125;// Generator函数function* g() &#123; let f1 = yield readFileThunk('/a') let f2 = yield readFileThunk('/b') let f3 = yield readFileThunk('/c')&#125;// Thunk函数readFileThunkconst Thunk = function(fn) &#123; return function (...args) &#123; return function (callback) &#123; return fn.call(this, ...args, callback); &#125; &#125;;&#125;;var readFileThunk = Thunk(fs.readFile);readFileThunk(fileA)(callback);// 自动执行run(g)co模块说明不用手写上述的执行器，co模块其实就是将基于Thunk函数和Promise对象的两种自动Generator执行器包装成一个模块使用条件：yield后只能为Thunk函数或Promise对象或Promise对象数组基于Promise的执行器实现1234567891011121314function run(fn) &#123; let gen = fn() function cb(data) &#123; // 将上一个任务返回的data作为参数传给next方法，控制权交回到Generator //这里将result变量引用&#123;value, done&#125;对象，不要和Generator中的`let result = yield xxx`搞混 let result = gen.next(data) if (result.done) return result.value result.value.then(function(data)&#123; // resolved之后会执行cb(data)，开启下一次循环，实现自动执行 cb(data) &#125;) &#125; cb()&#125;源码分析其实和上面的实现类似12345678910111213141516171819202122232425262728293031323334353637383940414243function co(gen) &#123; var ctx = this; var args = slice.call(arguments, 1) // 除第一个参数外的所有参数 // 返回一个Promise对象 return new Promise(function(resolve, reject) &#123; // 如果是Generator函数，执行获取遍历器对象gen if (typeof gen === 'function') gen = gen.apply(ctx, args); if (!gen || typeof gen.next !== 'function') return resolve(gen); // 第一次执行遍历器对象gen的next方法获取第一个任务 onFulfilled(); // 每次异步任务执行完，resolved以后会调用，控制权又交还给Generator function onFulfilled(res) &#123; var ret; try &#123; ret = gen.next(res); // 获取&#123;value,done&#125;对象，控制权在这里暂时交给异步任务，执行yield后的异步任务 &#125; catch (e) &#123; return reject(e); &#125; next(ret); // 进入next方法 &#125; // 同理可得 function onRejected(err) &#123; var ret; try &#123; ret = gen.throw(err); &#125; catch (e) &#123; return reject(e); &#125; next(ret); &#125; // 关键 function next(ret) &#123; // 遍历执行完异步任务后，置为resolved，并将最后value值返回 if (ret.done) return resolve(ret.value); // 获取下一个异步任务，并转为Promise对象 var value = toPromise.call(ctx, ret.value); // 异步任务结束后会调用onFulfilled方法（在这里为yield后的异步任务设置then的回调参数） if (value &amp;&amp; isPromise(value)) return value.then(onFulfilled, onRejected); return onRejected(new TypeError('You may only yield a function, promise, generator, array, or object, ' + 'but the following object was passed: "' + String(ret.value) + '"')); &#125; &#125;)&#125;其实还是一样，为Promise对象then方法指定回调函数，在异步任务完成后出发回调函数，在回调函数中执行Generator的next方法，进入下一个异步任务，实现自动执行。举个🌰123456789101112131415161718'use strict';const fs = require('fs');const co =require('co');function read(filename) &#123; return new Promise(function(resolve, reject) &#123; fs.readFile(filename, 'utf8', function(err, res) &#123; if (err) &#123; return reject(err); &#125; return resolve(res); &#125;); &#125;);&#125;co(function *() &#123; return yield read('./a.js');&#125;).then(function(res)&#123; console.log(res);&#125;);处理并发的异步操作把并发操作放数组/对象中放yield后面lesson4 async函数语法糖比较123456789101112function* asyncReadFile () &#123; const f1 = yield readFile('/etc/fstab'); const f2 = yield readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());&#125;;const asyncReadFile = async function () &#123; const f1 = await readFile('/etc/fstab'); const f2 = await readFile('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());&#125;;看起来只是写法的替换，实际上有这样的区别async函数内置执行器，不需要手动执行next方法，不需要引入co模块async适用更广，co模块对yield后的内容严格限制为Thunk函数或Promise对象，而await后可以是Promise对象或原始类型值返回Promise，这点和co比较像用法async标识该函数内部有异步操作由于async函数返回的是Promise，所以可以将async函数作为await命令的参数async函数可以使用在函数、方法适用的许多场景语法返回的Promiseasync函数只有在所有await后的Promise执行完以后才会改变返回的Promise对象的状态（return或者抛错除外）即只有在内部操作完成以后才会执行then方法async函数内部return的值会作为返回的Promise的then方法回调函数的参数async函数内部抛出的错误会使得返回的Promise变成rejected状态，同时错误会被catch捕获async命令及其后的Promiseasync命令后如果不是一个Promise对象，则会被转成一个resolved的Promiseasync命令后的Promise如果抛错了变成rejected状态或者直接rejected了，都会使得async函数的执行中断，错误可以被then方法的回调函数catch到如果希望async的一个await Promise不影响到其他的await Promise，可以将这个await Promise放到一个try…catch代码块中，这样后面的依然会正常执行，也可以将多个await Promise放在一个try…catch代码块中，此外还可以加上错误重试使用注意相互独立的异步任务可以改造下让其并发执行（Promise.all）123456let [foo, bar] = await Promise.all([getFoo(), getBar()]);// 听说下面这种也可以？let fooPromise = getFoo();let barPromise = getBar();let foo = await fooPromise;let bar = await barPromise;forEach123forEach(async function a() &#123; let m = await pro&#125;)这种写法可能不能正常工作，因为forEach时的若干个操作是并行的，应改为for循环实现其实就是将执行器和Generator函数封装在一起，详见上一课举举🌰并发请求，顺序输出1234567891011async function logInOrder(urls) &#123; // 并发读取远程URL const textPromises = urls.map(async url =&gt; &#123; const response = await fetch(url); return response.text(); &#125;); // 按次序输出 for (const textPromise of textPromises) &#123; console.log(await textPromise); &#125;&#125;异步遍历器回到过去Generator的next方法是同步的，需要立即返回结果，所以在处理异步操作时我们返回的实际上是{value: Promise, done: false}类似这样的对象。理解没错的话Promise对象创建时传入的函数会立即执行，异步操作例如读取文件请求就开始了。而后我们为这个Promise对象指定then方法的参数回调函数去接收异步操作完成的信号，然后在回调函数中再次调用next获取下一个{value: Promise, done: false}提案：为异步操作提供原生的遍历器接口，使得value和done值都可以异步返回，称为异步遍历器more累了，困了，不开心看了，下次再补充]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-es6 新特性篇]]></title>
    <url>%2Fposts%2Ff1e10a9%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;承上一篇，本笔记包含es6的一些新东西，如Reflect，Proxy，Iterator，Symbol等。lesson1 Symbol概述javaScript第七种原始数据类型Symbollet s = Symbol(&#39;foo&#39;)通过Symbol函数生成，每个Symbol类型的变量值都独一无二，作为一种类似于字符串的数据结构，可以避免变量名冲突Symbol函数接收一个参数用于描述该Symbol实例，不影响生成的Symbol实例的值Symbol值不能与其他类型进行运算（模板字符串中也不可以），可以显示转为字符串和布尔值（String(), Boolean()）Symbol作为属性名不能用.，因为.是去取字符串对应属性名在对象中使用作为属性名时，需使用[s]否则也会被当做字符串Symbol.for, Symbol.keyFor1234let s1 = Symbol.for("foo");Symbol.keyFor(s1) // "foo"let s2 = Symbol("foo"); // 先搜索全局，已存在该key则返回已存在的Symbol.keyFor(s2) // undefined内置Symbol值Symbol.hasInstance对象的Symbol.hasInstance属性指向一个内部方法，其他对象使用instanceOf判断实例时，会调用这个内部方法123456class Even &#123; static [Symbol.hasInstance](obj) &#123; return Number(obj) % 2 === 0; &#125;&#125;1 instanceOf EvenSymbol.isConcatSpreadable表示该对象用于Array.prototype.concat()时是否可以展开，数组默认可展开，默认值为undefined，对象默认不可展开Symbol.species指向当前对象的构造函数，创造实例时会调用这个方法，即使用该属性返回的函数作为构造函数123static get [Symbol.species]() &#123; return this;&#125;Symbol.match, Symbol.replace, Symbol.split, Symbol.searchSymbol.iterator指向该对象的默认遍历器方法对象进行for…of循环时，会调用Symbol.iterator方法，返回该对象的默认遍历器详见后续章节Symbol.toPrimitiveSymbol.toStringTag指向一个方法，在该对象上调用Object.prototype.toString()时，如果该属性存在，则他的返回值会出现在toString方法返回的字符串之中，比如[Object Array]新增内置对象举个例子：JSON[Symbol.toStringTag]：&#39;JSON&#39;lesson2 Set和MapSet基本Set构造函数生成，成员值唯一，(判断与===区别在于NaN)，两个空对象视为不同实例属性和方法属性： Set.prototype.constructor, Set.prototype.size方法： add(value), delete(value), has(value), clear()123456Array.from可以将Set转为数组// 数组去重function dedupe(array) &#123; return Array.from(new Set(array)); // return [...new Set(array)]&#125;遍历keys(), values(), entries(), forEach() 方法遍历顺序为插入顺序，或可用于设置指定顺序的回调函数Set的键名键值相同Set默认可遍历，默认遍历器生成函数是values方法，这意味着，可以省略values方法，直接用for…of循环遍历 SetSet.prototype[Symbol.iterator] === Set.prototype.values...内部使用for ... of，故可以使用[...Set]，转为数组后可以方便使用数组方法如map和filterWeakSet成员只能为对象弱引用，垃圾回收机制对对象引用计数时不考虑WeakSet中对对象的引用new WeakSet() 可以接收任何具有 Iterable 接口的对象作为参数，但必须注意加入WeakSet的成员必须为对象WeakSet有以下三个方法：add(value), delete(value), has(value)，没有size属性，不可遍历（没有forEach和clear方法）Map基本键值对的集合（Hash结构），键和对象不一样，不局限于字符串。任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构都可以作为Map构造函数的参数只有对同一个对象的引用或者严格相等的简单类型（包括NaN）才会生成一样的Map实例属性和方法属性： Map.prototype.constructor, Map.prototype.size方法： set(), get(), delete(value), has(value), clear()遍历类似上述Set的遍历Map 结构的默认遍历器接口（Symbol.iterator属性），就是entries方法与其他数据结构转换数组，对象，JSON互转1234567function strMapToObj(strMap) &#123; let obj = Object.create(null); for (let [k,v] of strMap) &#123; obj[k] = v; &#125; return obj;&#125;WeakMap键名只能为对象WeakMap的键名所指向的对象，不计入垃圾回收机制WeakMap有以下三个方法：get, set, delete(value), has(value)，没有size属性，不可遍历（没有forEach和clear方法）lesson3 Proxy观察举个栗子当你为对象a赋值a.b=c时，你希望在b属性赋值时有一个范围大小的校验，超出范围抛错，这个时候我们可能会想到重载set方法,比如：123456789let a = &#123;&#125;Object.defineProperty(a, 'b', &#123; set(x) &#123; if (x&gt;100) &#123; throw new RangeError('invalid range') &#125; this.b = x &#125;&#125;)动手以后发现一个问题…这样会栈溢出，因为在set内再set了b的值，无限循环…变通一下：123456789101112let a = &#123;&#125;Object.defineProperty(a, 'b', &#123; get(x) &#123; return this.c &#125; set(x) &#123; if (x&gt;100) &#123; throw new RangeError('invalid range') &#125; this.c = x &#125;&#125;)然而总要这么写感觉很麻烦，而且如果是对一类属性进行操作时，重复写很没必要，换用Proxy写法：123456789101112let a = &#123;&#125;let handler = &#123; set(obj, prop, value, receiver) &#123; if (prop === 'b') &#123; if (value&gt;100) &#123; throw new RangeError('invalid range') &#125; &#125; obj[prop] = value &#125;&#125;let proxy = new Proxy(a, handler)看起来也舒服多了，而且可以根据属性名在set方法内做判断，更可扩展庖丁解牛代理proxy123456789101112let target = &#123;&#125;;let handler = &#123;&#125;;let proxy = new Proxy(target, handler);// 将代理的所有内部方法转发至目标proxy.a = 1 =&gt; target.a = 1;target.b = 4 =&gt; proxy.b = 4;target !== proxytarget.__proto__ === proxy.__proto__// 应在代理对象上操作，代理才能生效handler = &#123;get()&#123;return 12&#125;&#125;target.v // undefinedproxy.v // 12Proxy支持的拦截操作12345678910111213get(target, propKey, receiver) // proxy.foo, proxy['foo']set(target, propKey, value, receiver) //proxy.foo = v, proxy['foo'] = vhas(target, propKey) // propKey in proxydeleteProperty(target, propKey) // delete proxy[propKey]ownKeys(target) // Object.getOwnPropertyNames(proxy), Object.getOwnPropertySymbols(proxy), Object.keys(proxy)getOwnPropertyDescriptor(target, propKey) // Object.getOwnPropertyDescriptor(proxy, propKey)defineProperty(target, propKey, propDesc) // Object.defineProperty(proxy, propKey, propDesc), Object.defineProperties(proxy, propDescs)preventExtensions(target) // Object.preventExtensions(proxy)getPrototypeOf(target) // Object.getPrototypeOf(proxy)isExtensible(target) // Object.isExtensible(proxy)setPrototypeOf(target, proto) // Object.setPrototypeOf(proxy, proto)apply(target, object, args) // 拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)construct(target, args) // new proxy(...args)代理句柄handler句柄对象的方法可以复写代理的内部方法，具体为上述的14种。举个🌰12345678910111213function Tree() &#123; return new Proxy(&#123;&#125;, handler);&#125;var handler = &#123; get: function (target, key, receiver) &#123; if (!(key in target)) &#123; target[key] = Tree(); // 自动创建一个子树 &#125; return Reflect.get(target, key, receiver); &#125;&#125;var tree = new Tree()tree.branch1.branch2.twig = "green"再来个🌰123456789101112// 实现对in操作符隐藏属性var handler = &#123; has (target, key) &#123; if (key[0] === '_') &#123; return false; &#125; return key in target; &#125;&#125;;var target = &#123; _prop: 'foo', prop: 'foo' &#125;;var proxy = new Proxy(target, handler);'_prop' in proxy // false特别注意如果目标对象不可扩展或者目标对象的属性不可写或者不可配置时，代理不能生效，可能会报错需注意一些特定的方法对返回值有要求，不如重写isExtensible方法时，返回值与目标对象的isExtensible属性应一致，否则会报错利用代理重写可以做很多事情比如隐藏属性、对某些属性、操作符屏蔽、拦截内在方法并且加上自己想要的逻辑处理去得到预期结果等饭后甜点Proxy.revocable返回一个对象，proxy属性对应Proxy实例，revoke属性为revoke方法可以取消Proxy实例1234let &#123;proxy, revoke&#125; = Proxy.revocable(target, handler);proxy.foo = 1revoke()proxy.foo // TypeError: Revokedthis问题代理以后目标对象内部的this指向的是Proxy实例而不是目标对象有时候可能因为this指向问题导致代理达不到预期效果1234567891011121314// jane的name属性实际存储在外部的WeakMap对象的_name上，导致后续取不到值const _name = new WeakMap();class Person &#123; constructor(name) &#123; _name.set(this, name); &#125; get name() &#123; return _name.get(this); &#125;&#125;const jane = new Person('Jane');jane.name // 'Jane'const proxy = new Proxy(jane, &#123;&#125;);proxy.name // undefined某些原生对象的部分属性需要this指向原生对象时才能获取，如Date.getDate()，此时proxy get时需要注意this绑定原始对象1234567891011const target = new Date('2015-01-01');const handler = &#123; get(target, prop) &#123; if (prop === 'getDate') &#123; return target.getDate.bind(target); &#125; return Reflect.get(target, prop); &#125;&#125;;const proxy = new Proxy(target, handler);proxy.getDate() // 1进阶TO BE CONTINUED!lesson4 Reflect初识Reflect对象与Proxy对象一样，是为了操作对象而提供的新API，存在的原因如下：将Object对象的一些内部方法添加到Reflect对象上，且以后的新方法都部署到Reflect对象上，完成分离让对象操作变成函数行为修改Object对象一些内部方法在出错时的返回Proxy覆写对象方法时，提供一个Reflect对象用来获取原始方法，以设置默认值，再此基础上再做功能添加和修改揭面静态方法对应于Proxy可覆写的方法，有13个静态方法注意Proxy和Reflect联用的时候要小心，可能一个拦截会触发另一个拦截1234567891011121314151617let p = &#123; a: 'a'&#125;;let handler = &#123; set(target, key, value, receiver) &#123; console.log('set'); Reflect.set(target, key, value, receiver) &#125;, defineProperty(target, key, attribute) &#123; console.log('defineProperty'); Reflect.defineProperty(target, key, attribute); &#125;&#125;;let obj = new Proxy(p, handler);obj.a = 'A';// set// defineProperty在Reflect.set传入receiver的时候触发了Proxy.defineProperty，不传入receiver时不会触发defineProperty拦截对于参数的要求、转换和报错处理🌰使用Proxy实现观察者模式1234567891011121314151617181920const person = observable(&#123; name: '张三', age: 20&#125;);function print() &#123; console.log(`$&#123;person.name&#125;, $&#123;person.age&#125;`)&#125;observe(print);person.name = '李四';// 输出// 李四, 20/**************************/const queuedObservers = new Set();const observe = fn =&gt; queuedObservers.add(fn);const observable = obj =&gt; new Proxy(obj, &#123;set&#125;);function set(target, key, value, receiver) &#123; const result = Reflect.set(target, key, value, receiver); queuedObservers.forEach(observer =&gt; observer()); return result;&#125;lesson5 遍历器Iterator遇见why Iteratorjs中数据集合的概念越来越多，如果能有一种统一的访问方式将是极好的。Iterator的设计就基于此，通过为相应数据结构部署iterator接口让该数据结构可通过统一的方式:for…of遍历遍历过程：创建一个指针对象指向当前数据结构的初始位置（遍历器对象实际为一个指针对象）调用指针对象的next方法，直到指向数据结构的结束位置1234567891011// 遍历器生成函数function makeIterator(array) &#123; var nextIndex = 0; return &#123; next: function() &#123; return nextIndex &lt; array.length ? &#123;value: array[nextIndex++]&#125; : &#123;done: true&#125;; &#125; &#125;;&#125;一种数据结构，只要部署了Iterator接口，就视为可遍历的相识默认Iterator接口默认的Iterator接口部署在[Symbol.iterator]属性上，Symbol.iterator属性键为Symbol对象，值为一个函数，即遍历器生成函数，执行该函数会返回一个遍历器对象，该对象具有一个next方法，调用该方法可以返回{value, done}对象，代表了当前成员的信息部分数据结构如Array、Set、Map、String等已经部署了Iterator接口，对象则需要手动添加这样的方法实现Iterator接口对于非线性数据结构，Iterator接口实际上就是一种线性转换，下例为class实现遍历器123456789101112131415161718192021class RangeIterator &#123; constructor(start, stop) &#123; this.value = start; this.stop = stop; &#125; [Symbol.iterator]() &#123; return this; &#125; next() &#123; var value = this.value; if (value &lt; this.stop) &#123; this.value++; return &#123;done: false, value: value&#125;; &#125; return &#123;done: true, value: undefined&#125;; &#125;&#125;function range(start, stop) &#123; return new RangeIterator(start, stop);&#125;for (var value of range(0, 3)) &#123; console.log(value); // 0, 1, 2&#125;举个🌰实现指针12345678910111213141516171819202122232425262728293031323334function Node(value) &#123; this.value = value; this.next = null&#125;// for...of时会调用改遍历器生成函数Node.prototype[Symbol.iterator]= function() &#123; // 返回的遍历器对象 var iterator = &#123; next: next &#125; // 当前成员 var current = this next() &#123; if(current) &#123; var value = current.value; // 移动指针 current = current.next; return &#123; done: false, value: value &#125;; &#125; return &#123; done: true, value: undefined &#125;; &#125; return iterator&#125;// 新建对象，因为在原型上实现的遍历器生成函数，所以每个实例都实现了遍历器接口var one = new Node(1);var two = new Node(2);var three = new Node(3);// 当前成员的next指向下一个成员，在next方法中实现指针移动one.next = two;two.next = three;// 对对象使用for...of时，去查找[Symbol.iterator]属性，找到后循环调用next方法，直到返回值得done属性为truefor (var i of one)&#123; console.log(i); // 1, 2, 3&#125;如果Symbol.iterator方法对应的不是遍历器生成函数，则会报错在何方调用场合解构赋值扩展运算符任何实现了Iterator接口（可遍历）的数据结构都可以通过...将其转化为数组yield*后跟一个可遍历数据结构时，会调用该结构的遍历器接口for...of, Array.from, Map, Set, Promise.all(), Promise.race()字符串、数组等的遍历器字符串for…of能够正确识别32位UTF-16字符12345678var someString = "hi";typeof someString[Symbol.iterator]// "function"var iterator = someString[Symbol.iterator]();// 当然你也可以修改Symbol.iterator方法达到你想要的遍历结果iterator.next() // &#123; value: "h", done: false &#125;iterator.next() // &#123; value: "i", done: false &#125;iterator.next() // &#123; value: undefined, done: true &#125;return, throw方法这两个方法都是在设置遍历器生成函数时可选的，一般配合generator使用，所以下次再说数组for … of 只返回具有数字索引的键值的值类数组对象可以使用数组的默认遍历生成器达到遍历效果（要求是数字索引以及具有length属性）Map, Set1234// Map遍历返回的是数组[k, v]，Set返回的是值for (let [key, value] of map) &#123; console.log(key + ' : ' + value);&#125;类数组对象利用Array.from将其转化为数组，再使用数组的遍历器接口用for…of实现遍历for … of 注意可以结合break、continue、return使用提供了多种数据结构的统一访问方式相比for … in，后者遍历的是键，且键名为字符串，还可能会遍历原型上的键]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-es6 基础篇]]></title>
    <url>%2Fposts%2F96174113%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;大佬们es7, es8写得嗨皮的时候，我却还在es6学习…本文为阅读阮一峰老师的系列文章记下的es6基础篇笔记。lesson1 introduce新的语法成为标准的过程stage12345Stage 0 - Strawman（展示阶段）Stage 1 - Proposal（征求意见阶段）Stage 2 - Draft（草案阶段）Stage 3 - Candidate（候选人阶段）Stage 4 - Finished（定案阶段）babel.babelrc12345678910npm install --save-dev babel-preset-latest&#123; presets: [ "latest", "react", "stage-2" ], plugins: []&#125;# presets的值集有latest，react，stage-0 to stage-3（对应不同阶段的提案，选择一个）babel-cli1234# -s生成sourcemap，-o指定文件，-d指定目录babel example.js -o compiled.js -s# babel-node提供支持ES6的REPL环境，目标文件不需要考虑转码babel-node es6.jsbabel-register123提供一个钩子，在require加载`.js`, `.jsx`, `.es`, `.es6`后缀的文件时先用babel实时转码，需在require别的文件前先require该模块require("babel-register");require("./index.js");babel-core1234需要调用babel的api时，需要require该模块var babel = require('babel-core');// 字符串转码babel.transform('code();', options);babel-polyfill12默认情况下babel只转句法，不转一些es6新的对象以及方法，这种情况下需要在脚本头部引入该模块转换使其可用import 'babel-polyfill';Traceur1google提供的babel替代品lesson2 let/constTDZ只在声明的块级作用域域内有效、不可重复声明、TDZ循环体和循环条件中的i有单独的作用域1234for (let i = 0; i &lt; 3; i++) &#123; let i = 'abc'; console.log(i); //输出3次&#125;TDZ12345678910// 在该区域内let/const定义的变量，只有等到声明以后才可以获取/使用if (true) &#123; // TDZ开始 tmp = 'abc'; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123&#125;注意：带来的问题是typeof不再绝对安全块级作用域没有块级作用域的问题12345678910// 场景1var tmp = new Date();function f() &#123; console.log(tmp); if (false) &#123; var tmp = 'hello world'; &#125;&#125;f(); // undefined因为变量提升，所以在函数执行的上下文中找到了tmp的定义，但是没有完成赋值，所以是undefined// 场景2 典型的for循环将i变成了全局变量块级作用域告别丑陋的IIFE对于es6的浏览器环境还说，函数声明类似于var，可以理解成先函数变量提升var f = undefined，然后再继续后面，所以以下代码是会报错的123456789function f() &#123; console.log('I am outside!'); &#125;(function () &#123; if (false) &#123; // 重复声明一次函数f function f() &#123; console.log('I am inside!'); &#125; &#125; f();&#125;());// Uncaught TypeError: f is not a functiondo提案12345在代码块前加do，返回最后执行表达式的值let x = do &#123; let t = f(); t * t + 1;&#125;;constfreeze对于复杂类型变量，const保证的是指向该变量的内存空间的地址是不变的，变量若是可写的是可以修改变量的属性值的。要想冻结变量，需使用Object.freeze()冻结对象及对象所有属性，如下：12345678var constantize = (obj) =&gt; &#123;Object.freeze(obj); Object.keys(obj).forEach( (key, i) =&gt; &#123; if ( typeof obj[key] === 'object' ) &#123; constantize( obj[key] ); &#125; &#125;);&#125;;var function let const class前两者声明的全局变量依然是顶层对象（window/global）的属性，后三者不再是，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩提案考虑到不同环境下顶层对象不同，提案在语言标准层面引入global对象作为顶层对象，即所有环境下global对象都是存在的，如下1234567// 将顶层对象放入变量global中// CommonJS 的写法var global = require('system.global')();// ES6 模块的写法import getGlobal from 'system.global';const global = getGlobal();lesson3 解构数组解构数组解构的本质是模式匹配，只要某种数据结构具有Iterator接口，就都可以采用数组形式解构。egs: Array, Set, Generator.123456// 解构赋值设置默认值是根据右侧是否===undefined来决定右侧是否有值，有则覆盖默认值let [i = 1] = [] // 1let [i = 1] = [undefined] // 1let [i = 1] = [null] // null// 下例可以看出默认值先设置，再进行解构赋值let [x = 1, y = x] = [1, 2]; // x=1; y=2[a, b, c] = arr equals a = arr[0] b = arr[1]对象解构对象的解构赋值需要变量与对象属性名相同，本质是先找到同名的属性，然后把值赋给对应的变量1234567891011// foo是匹配模式，不是变量，sss是被赋值的变量let &#123; foo: sss, bar: ddd &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;foo // foo is not definedsss // "aaa"// 默认值生效的条件是，对象的属性值严格等于undefined，结构失败为undefinedlet &#123; x = 2 &#125; = &#123; x: null &#125;x// null// 如果解构模式是嵌套的对象，父属性不存在时会报错let &#123;foo: &#123;bar&#125;&#125; = &#123;baz: 'baz'&#125;// 理解下面的为三次解构 node.loc node.loc.start node.loc.start.linelet &#123; loc, loc: &#123; start &#125;, loc: &#123; start: &#123; line &#125;&#125; &#125; = node原来项目里天天写的const {a, b} = this.state是解构赋值！let {a:c, b:d} = obj equals c = obj.a d = obj.b字符串、数值、布尔值、null、undefined如下12let [a,b,c] = 'skt'let &#123;length: len&#125; = 'skt'如下123// 等号右边先转为对象再进行解构赋值，故undefined和null会报错let &#123;toString: s&#125; = 123;s === Number.prototype.toString // true用途交换变量值1[x, y] = [y, x]从函数返回多个值函数参数的定义、默认值123456// 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;);提取JSON数据1let &#123; id, status, data: number &#125; = jsonData;遍历map1234// 获取key、valuefor (let [key, value] of map) &#123; console.log(key + " is " + value);&#125;获取输入模块的指定方法1const &#123; SourceMapConsumer, SourceNode &#125; = require("source-map");lesson4 字符串扩展unicode表示js中，可以用\uxxxx表示字符，xxxx为该字符的Unicode码位。js内部，字符以UTF-16格式存储，即每个字符为2个字节(0x0000-0xFFFF)，对于需要4字节存储的例如汉字，在处理时可能会出现误判。codePointAt1234// 判断是否为4字节组成function is32Bit(c) &#123; return c.codePointAt(0) &gt; 0xFFFF;&#125;String.fromCodePoint返回码点对应字符，支持4字节，即32位UTF-16字符字符串遍历for ... of ...遍历字符串，可以做到支持32位UTF-16字符提案 atcharAt返回的是UTF-16字符的前两个字节，提案at可以支持4字节UTF-16字符，需要垫片库支持include(), startsWith(), endsWith()字面理解，注意可以传一个下标参数，表示查找位置repeat(), padStart(5, s = &#39;&#39;), padEnd(5, e = &#39;&#39;)padStart填充在前，padEnd填充在后，若原字符串长度大于第一个参数，则不填充返回原字符串，若加起来大于第一个参数则保留原，去除需添加的多余的。12'123456'.padStart(10, '0') // "0000123456"'12'.padStart(10, 'YYYY-MM-DD') // "YYYY-MM-12"模板字符串标签模板12345678910111213let total = 30;let msg = passthru`The total is $&#123;total&#125; ($&#123;total*1.05&#125; with tax)`;// ['The total is ', ' ', ' (', ' with tax)'], 30, 31.5function passthru(literals, ...values) &#123;let output = "";let index;for (index = 0; index &lt; values.length; index++) &#123; output += literals[index] + values[index];&#125;output += literals[index]return output;&#125;msg // "The total is 30 (31.5 with tax)"过滤字符串123456789101112131415161718 let message =SaferHTML`&lt;p&gt;$&#123;sender&#125; has sent you a message.&lt;/p&gt;`; function SaferHTML(templateData) &#123; let s = templateData[0]; for (let i = 1; i &lt; arguments.length; i++) &#123; let arg = String(arguments[i]); // Escape special characters in the substitution. s += arg.replace(/&amp;/g, "&amp;amp;") .replace(/&lt;/g, "&amp;lt;") .replace(/&gt;/g, "&amp;gt;"); // Don't escape special characters in the template. s += templateData[i]; &#125; return s; &#125;其他用途有：i18n、模板处理、引入其他语言等123456789// 下面的hashTemplate函数// 是一个自定义的模板处理函数let libraryHtml = hashTemplate`&lt;ul&gt; #for book in $&#123;myBooks&#125; &lt;li&gt;&lt;i&gt;#&#123;book.title&#125;&lt;/i&gt; by #&#123;book.author&#125;&lt;/li&gt; #end&lt;/ul&gt;`;lesson5 数值扩展0o/0O 八进制 0b/0B 二进制Number.isFinite Number.isNaN与全局isFinite、isNaN的差别在于前者只对数值有效，非数值一律返回false后者是先将非数值转化为数值再判断。Number.ParseInt Number.ParseFloat Number.isInteger逐步减少全局性方法，使得语言逐步模块化Number.EPSILON 可以接受的最小误差范围isSafeInteger123456789Number.isSafeInteger(9007199254740993)// falseNumber.isSafeInteger(990)// trueNumber.isSafeInteger(9007199254740993 - 990)// true9007199254740993 - 990// 返回结果 9007199254740002// 正确答案应该是 90071992547400039007199254740993不是一个安全整数，但是Number.isSafeInteger会返回结果，显示计算结果是安全的。这是因为，这个数超出了精度范围，导致在计算机内部，以9007199254740992的形式储存Math对象扩展指数运算符**提案 Integerlesson6 函数扩展参数设置默认值、rest参数basicwith解构123456function m1(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;function m2(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125;理解二者区别即可，其余可参见解构函数的length属性：未指定默认值的参数个数参数一旦设置了默认值，函数在声明初始化时会形成单独的作用域，初始化结束后释放掉。12345678910111213141516let x = 1function m(y=x)&#123; let x = 2 console.log(y)&#125;m()// 1// 如果全局x不存在会报错，第二行相当于发生了let y = x, x指向全局的x, 不受内部x影响var x = 1;function foo(x, y = function() &#123; x = 2; &#125;) &#123;var x = 3;y();console.log(x);&#125;// 理解：这里有三个作用域，三个x，各不相干 3// 去掉var以后参数中的两个x和函数体内x是一样的，外部还是不变 2应用指定参数必传，否则报错，即给参数赋值一个默认的函数抛错的结果，没传时得到的是这个抛出的错用默认赋值undefined表示该参数可省略函数的length不包含rest参数rest参数之后不能再有参数只要参数使用了默认值、解构赋值、或者扩展运算符，就不能显式指定严格模式箭头函数注意箭头函数体内的this指向函数定义时的对象，不是对应运行时的对象不可以当做构造函数不可以使用yield不可以使用arguments不可以使用bind、call、apply来改变箭头函数this指向this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this12const headAndTail = (head, ...tail) =&gt; [head, tail];headAndTail(1, 2, 3, 4, 5) // [1,[2,3,4,5]]其他双冒号运算符12obj::func === func.bind(obj)foo::bar(...arguments) === bar.apply(foo, arguments)尾调用优化1234// 函数f的最后一步为函数g调用function f(x)&#123; return g(x);&#125;函数调用会在内存在生成调用记录，即调用帧，如A函数中调用B函数，则会在A的调用帧上方形成B的调用帧，B调用完后，返回至A才会消失。尾调用实际上已经不用保存外层A的调用帧了，可以优化。只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”尾递归优化123456789101112// 非尾递归function Fibonacci (n) &#123; if ( n &lt;= 1 ) &#123;return 1&#125;; return Fibonacci(n - 1) + Fibonacci(n - 2);&#125;// 尾递归function Fibonacci2 (n , ac1 = 1 , ac2 = 1) &#123; if( n &lt;= 1 ) &#123;return ac2&#125;; return Fibonacci2 (n - 1, ac2, ac1 + ac2);&#125;传统递归需要保存相当多的调用帧，尾递归只保存一个，节省内存，避免发生栈溢出柯里化将多参数函数变成单参数形式（具体下次再论）es2017支持函数最后一个参数尾逗号在不需要错误实例的时候，提案try…catch…菜单catch块不需要参数lesson7 数组扩展扩展运算符... 可以理解为rest参数的逆运算，将数组转化为逗号分隔的参数序列，如Math.max(...[14, 3, 77])复制数组（直接赋值是引用，指向相同地址）1234// es5a1 = [1,2]; a2 = a1.concat()// es6a1 = [1,2]; a2 = [...a1]合并数组与解构结合扩展运算符用于数组赋值时，只能作为最后一个参数1const [a, ...b] = [1,2,3,4]字符串123456// 生成数组[...'hello']// 返回字符串正确长度，兼容4字节UTF-16编码的Unicode字符function length(str) &#123;return [...str].length;&#125;实现了 Iterator 接口的对象（下回分解）Map Set Generator（下回分解）Array方法Array.from()将arraylike对象和可遍历对象转为数组1234567// Array.prototype.sliceArray.from// Array.from(arrayLike).map(x =&gt; x * x)// 接收第二个参数，类似map，可用于如NodeList对象等处理，获取dom节点的属性Array.from(arrayLike, x =&gt; x * x)Array.from([1, , 2, , 3], (n) =&gt; n || 0)// 第三个参数，可以绑定this...调用的是遍历器接口（Symbol.iterator），若对象没有部署这个接口，就不能转化为数组，Array.from可以转换任何有length属性的对象因吹斯听12Array.from(&#123; length: 2 &#125;, () =&gt; 'jack')效果：第一个参数为第二个参数（函数）指定执行次数Array.of总是返回参数值组成的数组，如果没有参数，就返回一个空数组1234// 弥补构造函数Array()的不足（1-2个参数时）function ArrayOf()&#123; return [].slice.call(arguments);&#125;copyWithin 用途不明find findIndex 前者返回第一个值/undefined，后者返回位置/-1fill 数组填充，可以指定起始、结束位置keys() values() entries() 用于遍历数组，返回遍历器对象，可以使用for…of循环也可以手动调用遍历器对象的next方法。分别对应 键、值、键值对（[0,’a’]）includes() 判断数组中是否包含某个值，解决了indexOf对NaN的误判（因为NaN!==NaN，indexOf是===判断）空位，es6上述数组扩展对空位处理比较一致，值设为undefined，遍历时视为存在lesson8 对象扩展写法属性、方法简写1&#123; a &#125; &#123; a() &#123;&#125; &#125;属性名表达式、方法名表达式123&#123; ['a' + 'bc']: 'a' &#125;&#123; ['a' + 'bc']() &#123;&#125; &#125;// 注意属性名为对象时，会自动转为字符串`[object Object]`方法名name1234567891011// 这种情况下`obj.foo.name`会报错const obj = &#123; get foo() &#123;&#125;, set foo(x) &#123;&#125;&#125;;// 正确写法const descriptor = Object.getOwnPropertyDescriptor(obj, 'foo');descriptor.get.name // get foo// special(new Function()).name // "anonymous"doSomething.bind().name // "bound doSomething"方法Object.is比较12345// 除了下列情况外和===的表现一致+0 === -0 //trueNaN === NaN // falseObject.is(+0, -0) // falseObject.is(NaN, NaN) // trueObject.assign用于对象合并，将源对象的所有可枚举属性复制到目标对象1Object.assign(target, source1, source2);注意非对象出现在第一个参数会被转为对象，出现在后面只有字符串会以字符数组形式参与合并。（因为只有字符串的包装对象，会产生可枚举属性）对于undefined和null无法转为对象，多以出现在第一个参数位会报错，出现在后面会被忽略。浅拷贝，即如果源对象的某个属性是对象，则目标对象拷贝的是该对象的引用用途为对象添加属性、方法克隆对象123456789// 只克隆原有可枚举属性function clone(origin) &#123; return Object.assign(&#123;&#125;, origin);&#125;// 保持继承链function clone(origin) &#123; let originProto = Object.getPrototypeOf(origin); return Object.assign(Object.create(originProto), origin);&#125;合并多个对象为属性设置默认值（利用覆盖，注意应为简单类型）Object.getOwnPropertyDescriptors返回指向对象的所有自身属性的描述对象由于Object.assign是赋值拷贝，所以无法正确拷贝对象的get和set方法，所以需要有方式去获取描述对象，再结合defineProperties进行结合Object.create使用，浅拷贝Object.getPropertyOf, Object.setPropertyOf, __proto____proto__12obj = Object.create(someOtherObj);obj.__proto__ = someOtherObj;Object.setPrototypeOf(obj, proto)将proto对象设为obj的原型，第一个参数为undefined和null时报错，非对象时自动转Object.getPrototypeOf(obj)super指向当前对象的原型对象，只有对象的方法的简写模式中有效，否则报错super.foo等同于Object.getPrototypeOf(this).fooObject.keys, Object.values, Object.entriesObject.entries 用途：new Map(Object.entries(obj))属性的可枚举和遍历可枚举获取属性的描述对象12345678let obj = &#123; foo: 123 &#125;;Object.getOwnPropertyDescriptor(obj, 'foo')// &#123;// value: 123,// writable: true,// enumerable: true,// configurable: true// &#125;忽略 enumerable为false的操作1234for ... in // 会返回继承的属性Object.keys()JSON.stringify()Object.assign()遍历123456for ... in // 遍历自身和继承的**可枚举**属性，不包含Symbol属性Object.keys // 返回一个数组，只包含自身所有**可枚举**属性，不包含Symbol属性Object.getOwnPropertyNames(obj) // 返回一个数组，包含对象自身的**所有**属性，不包含Symbol属性Object.getOwnPropertySymbols(obj) // 返回一个数组，包含对象本身的所有Symbol属性Reflect.ownKeys(obj) // 返回一个数组，包含自身**所有键名**// 共性：遍历顺序为 数值键-字符串键-Symbol属性扩展运算符Null传导运算符（提案）obj?.prop, obj?.[expr], func?.(...args), new C?.(...args)]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo快速搭建博客]]></title>
    <url>%2Fposts%2Fd76cea4a%2F</url>
    <content type="text"><![CDATA[&emsp;利用一天时间搭一个简单漂亮的静态博客，平时记记笔记、写写文章，日积月累，收获也许会让你意想不到。前言&emsp;对于酷爱尝新的程序员们来说，博客可能是为数不多的仍被广泛使用的旧东西之一了。不论是为了技术积累，还是为了提高逼格，多数程序员心中都曾有过搭建博客站的想法。&emsp;在搭建博客的时候，大佬或者不麻烦会死星人都喜欢撸起袖子自己干，然而对于像我一样的一批渣渣小白来说要脱离现成框架自己搞出个名堂来绝非易事。换工作的空档期，忙得只剩下时间，也手撸了个博客站，除去编码时间，大部分的时间花在服务器部署上，对于一名前端切图狗来说，还是费了不少心思的，有兴趣的这里送上传送门。&emsp;就效果来说自己动手肯定是可以学到更多东西的，愿意投入时间是值得去尝试的，而且自己开发是可以根据需要个性化定制的，这是第三方服务不能很好地提供的。随之而来的坏处其一是开发成本和学习成本，独立博客站需要一定的技术积累，有一定的门槛，并不适合所有人。其二是即便你有能力有时间做到，后期是否会花心思去维护打理也是一个问题。想起我自己一开始满腔热血，下定决心要搞出个完美博客，结果七天草草收工，预先想加上的功能一个个都无疾而终，甚至到昨天域名都还没备案。&emsp;我以为独立博客站适合于自由职业者或者能够在短时间内把自己的需要实现的大佬们，因为这两者后期要么有时间维护要么不需要过多时间去维护。在博客站搭建完成以后他们就可以把重心放回到自己的工作和生活当中，在有技术积累或者装逼需要的时候只需要记录、上传这些简单的操作。&emsp;更加省心的选择是成熟的第三方框架，比如本站所用的Hexo，不得不说Hexo提供的功能和样式都是很有吸引力的，本身也不需要多少学习成本，甚至于非程序员也可以跟着教程实现。本文还是针对对于git有了解的想要快速搭建博客的程序员们，如果这方面有问题的话，也可以先去了解下git相关的东西。Hexo 走你大胆假设你的SSH key配置无误你安装好了node/npm你在你的Github上建了一个 your_user_name.github.io 的 repo安装123456789101112131415# 全局安装hexocnpm install hexo -g# 安装hexo deploy包cnpm install hexo-deployer-git --save# 初始化博客目录cd your_blog_dirhexo init# 安装依赖包npm install# 启动本地服务，访问127.0.0.1:4000，bingo！你将看到hexo默认首页hexo serverHexo设置基本设置12345678910111213141516171819# 编辑根目录下的配置文件vi _config.yml# 部署配置deploy: type: git repository: git@github.com:derekeeeeely/derekeeeeely.github.io.git branch: master# 站点设置title: DZ's Gensokyosubtitle: Best Time, Best You and Medescription: life are flashes and here is my lifeauthor: Derek Zhoulanguage: zh-Hanstimezone:# 你的域名url: http://derekz.cn完成基本设置后可以使用系一部分提到的命令进行创建文章、生成文件、部署到Git等操作常用命令1234567891011121314151617181920# 新建文章hexo new XXX# 在source目录下生成一个XXX文件夹，可以配置到head的导航处（后面有说明）hexo new page XXX# local server, 简化hexo shexo server# 生成静态页面，简化hexo ghexo generate# 部署到Github，简化hexo dhexo deploy# 清除public，修改未生效时（有待研究hexo的热更新）hexo clean# 生成+部署hexo d -gHexo主题 — Next&emsp;Hexo 提供了很多主题的选项，本站使用的是Next，也是比较流行，个人认为比较好看的主题。笔者用的版本是5.1.3，应该是比较高的版本，本身已经集成了很多有用的插件，配置起来更方便一些。其他版本和其他主题应该也多有相似之处，可供参考。Next 安装123456# 项目根目录clone Next主题代码git clone https://github.com/iissnan/hexo-theme-next.git themes/next# 修改项目配置，设置主题为Next，后续的很多设置都在Next的_config.yml 文件中进行，可以看成一个extend的关系vi _config.ymltheme: nextNext 插件篇敲黑板，划重点啦，好不好用，逼格高不高就看这里了。导航条1234567891011121314151617# menu设置menu: home: / || home categories: /categories/ || th tags: /tags/ || tags archives: /archives/ || archive #schedule: /schedule/ || calendar # sitemap: /sitemap.xml || sitemap commonweal: /404.html || heartbeat about: /about/ || user# Enable/Disable menu icons.menu_icons: enable: true# Next的四种主题，Mist表现中规中矩scheme: Mist&emsp;menu对应Next的Mist主题下头部导航，需要new出相应的页面，其中归档(archives)是默认有的，分类(categories)、标签(tags)、404页面和关于(about)是需要创建或编辑的。站内搜索1234567# 安装依赖包cnpm install hexo-generator-search --savecnpm install hexo-generator-searchdb --save# Local search 打开local_search: enable: true阅读量统计12345# leanCloud配置 （Next config已存在）leancloud_visitors: enable: true app_id: ssssssssssssssssssssssss app_key: sssssssssssssssssssssss&emsp;使用leancloud做统计，Next的插件目录底下的lean-analytics.swig文件已经存在leanCloud的引入和统计代码，我们只需要注册leanCloud，使用app_id和app_key做身份校验，按如上填写好就可以了。字数统计和阅读时间估计12345678910# 安装依赖包cnpm install hexo-wordcount --save# wordcount 设置（Next config已存在）post_wordcount: item_text: true wordcount: true min2read: true totalcount: false separated_meta: truesiderbar设置123456789101112# 社交链接/icon设置social: GitHub: https://github.com/derekeeeeely 微博: http://weibo.com/u/3248682277social_icons: enable: true GitHub: github 微博: weibo# links友情链接links: 我的小站: http://119.23.217.75&emsp;Next的icon默认使用的是Font Awesome库，需要注意的是key应该保持一致。友情链接可以放些自己的或者自己收藏的社区啊论坛啊大佬博客之类的，方便快速跳转。本站这里是因为自己另一个博客的域名没备案，所以放了IP，不要在意这些细节。有关于RSS和头像这部分没有累列出来，RSS是因为最后得到的是一个XML，老实说我不知道这个XML拿来有啥用，头像的话其实就改样式，不想自己写的话随便搜搜都有的，也就不贴出来了2333。文件压缩1234567891011121314151617181920212223242526# 安装依赖包cnpm install hexo-all-minifier --save# 在根目录配置文件中添加html_minifier: enable: true ignore_error: false exclude:css_minifier: enable: true exclude: - '*.min.css'js_minifier: enable: true mangle: true output: compress: exclude: - '*.min.js'image_minifier: enable: true interlaced: false multipass: false optimizationLevel: 2 pngquant: false progressive: false文章链接唯一化12345678910# 安装依赖包npm install hexo-abbrlink --save# 在根目录配置文件中修改permalink: posts/:abbrlink/ # “posts/” 可自行更换# abbrlink configabbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: hex # 进制：dec(default) and hex进阶黑科技SEO (观察效果ing)1234567891011121314151617181920212223242526# 安装依赖包cnpm install hexo-generator-sitemap --savecnpm install hexo-generator-baidu-sitemap --save# 根目录配置中添加sitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml# source目录添加robots.txtUser-agent: *Allow: /Allow: /archives/Allow: /categories/Allow: /tags/Disallow: /vendors/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /fancybox/Sitemap: http://www.derekz.cn/sitemap.xmlSitemap: http://www.derekz.cn/baidusitemap.xml&emsp;上述配置完后需要自备梯子翻墙登录google search console，按照提示一步一步走，验证域名所有权-&gt;抓取对应路由页面数据-&gt;加入资源索引，由于次数有限制，需要确定好哦。七牛云及图床&emsp;七牛云注册以后会提供10G的免费存储空间，一般来说存些图片是够用的了，问题在于我们在写markdown的时候图片链接复制是在是太麻烦了。这里提供几个选项：ipic 免费版图片上传至微博，每月付费可上传至七牛云（RMB玩家可以考虑）picU 只支持七牛云，可以一键截图上传并复制好图片链接（比较好用，但是笔者的这个不知道为啥用得好好的某一天突然就验证不通过了）qiniu-image-tool 需要安装qshell（七牛云的一个命令行工具）以及 Alfred（非RMB玩家能接受破解版的话可以去这里下载哦）域名指向&emsp;推荐阿里云，顺便一提，阿里云的ECS最低配首年只要300块，有服务器需求的可以尝试。&emsp;注册好域名后需要添加域名解析，讲道理的话配置CNAME为www和@、记录值为XXX.github.io就可以的，但是实际操作上我在阿里云域名解析这里尝试配置第二条的时候一直报错，没办法，ping了下XXX.github.io拿到IP后加了一条记录类型为A、记录值为IP的记录，如下图所示：&emsp;还需要做的一件事是在source目录底下创建一个CNAME文件，内容的话就填写你的域名，然后push到远端，重新部署。保存文件&emsp;为了保留本地文件，参考前辈做法，在自己的这个repo上checkout一个新的分支derekzhou，将代码提交。以后每次更新文章时先push到derekzhou分支，然后执行hexo的命令去生成public文件deploy到master。这样就算本机坏了也没影响，源代码还是可以从git上clone下来。1234567891011# .gitignore.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*//.deploy_git/public# /_config.yml&emsp;有任何疑问，欢迎git、weibo各种方式@我，博客的评论功能这两天会加上，因为好像现在梯子都被砍，第三方的一些评论服务也不好用了，有时间再看看吧。感谢各位看官老爷们~]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
