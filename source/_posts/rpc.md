---
title: Dubbo小笔记
tags: rpc
categories:
  - code
  - note
abbrlink: 773e5c14
date: 2017-11-21 22:08:50
---

&emsp;&emsp;抱着学习理解dubbo的心思，从各方大佬身上取经，记下学习笔记，方便自己，服务志同道合的小伙伴们
<!-- more -->

### Chapter1 RPC

#### 远程过程调用协议（Remote Procedure Call Protocol）

  - speak chinese:
    &emsp;部署在A服务器上的应用a需要调用部署在B服务器上的b应用提供的c函数/方法，这个时候就需要实现远程过程调用，RPC就是实现这一功能的协议。

  - 本地过程调用:
    &emsp;举个🌰
    ```c
    int add(int a, int b) {
      int c = a + b;
      return c;
    }
    int a1 = 1;
    int b1 = 2;
    int c1 = add(a1, b1);
    ```
    `int c1 = add(a1, b1)`执行过程：
      - 将a1, b1值压栈
      - 进入add函数，取出栈中a1, b1，赋值给a, b
      - 计算a + b，将结果存在c
      - c压栈，从add函数返回
      - 从栈中取出c的值，赋值给c1

  - 那么问题来了
    &emsp;本地调用由于函数/参数都存在内存中，可以直接调用/读取，合情合理，不需要做特别处理。
    &emsp;而上面栗子中的a应用要完成使命，首先需要和b应用通过网络建立进程间通信，然后将参数以某种b应用能够理解的形式传递过去，并且b应用需要按照某种约定准确找到c函数/方法，返回结果的过程类似。
    &emsp;对于负责业务代码的程序员来说，我们不关注远程调用的细节，我们希望的是远程调用能够做到和本地调用看起来是一样的，这样我们所写的代码不需要考虑调用场景特殊化处理。这一点需要实现以下几部分：
    - call ID 映射
      本地调用函数直接会找到函数指针，远程调用时，地址空间毫无关联，所以需要给所有的函数一个ID，消费端和提供端都需要维护这样一个ID映射，在远程调用时，消费者会带上这个ID，提供端根据ID找到相应的函数再去执行。
    - 序列化/反序列化
      由于必须通过网络传输传递参数，传输两端需要能够理解交换的数据，原本存储在内存中的参数值在消费端进行序列化，到达提供端后进行反序列化恢复成内存中的表达形式，然后在提供端执行函数/方法，返回结果类似，同样需要序列化和反序列化。
    - 网络传输
      网络传输这一块大部分RPC框架使用TCP协议，实际上能够实现网络传输目的的其他一些协议也是适用的。

#### RPC结构

- 图解
  ![](http://opo02jcsr.bkt.clouddn.com/94086df8115831bd40ef99719aacae9c.jpeg)

  - &emsp;RPC 服务方通过 `RpcServer` 去export远程接口方法，而客户方通过 `RpcClient` 去import远程接口方法。
  - &emsp;客户方像调用本地方法一样去调用远程接口方法，RPC 框架提供接口的代理实现，实际的调用将委托给代理 `RpcProxy` 。
  - &emsp;代理封装调用信息并将调用转交给 `RpcInvoker` 去实际执行。
  - &emsp;在客户端的 `RpcInvoker` 通过连接器 `RpcConnector` 去维持与服务端的通道 `RpcChannel`，并使用 `RpcProtocol` 执行协议encode并将编码后的请求消息通过通道发送给服务方。
  - &emsp;RPC 服务端接收器 `RpcAcceptor` 接收客户端的调用请求，同样使用 `RpcProtocol` 执行协议decode。解码后的调用信息传递给 `RpcProcessor` 去控制处理调用过程，最后再委托调用给 `RpcInvoker` 去实际执行并返回调用结果。

#### RPC组件

  - `RpcServer` 用于服务方导出远程接口方法，`RpcClient` 用于客户方引入接口方法的代理实现
  - `RpcProxy` 是远程接口方法的代理实现
  - `RpcInvoker`
    - 客户方实现：负责编码调用信息和发送调用请求到服务方并等待调用结果返回
    - 服务方实现：负责调用服务端接口的具体实现并返回调用结果
  - `RpcProtocol` 负责编解码
  - `RpcConnector` 负责维持客户方和服务方的连接通道和发送数据到服务方
  - `RpcAcceptor` 负责接收客户方请求并返回请求结果
  - `RpcProcessor` 负责服务方控制调用过程，包括管理调用线程池、超时时间等
  - `RpcChannel` 数据传输通道

  组件具体实现后续参考dubbo框架再来学习

#### 问题

  - 远程调用可能由于网络问题没有到达服务方，所以调用未必一定执行
  - 远程调用抛出的异常可能是RPC框架运行时异常
  - 远程调用消耗肯定是高于本地调用的，所以考虑导出为远程接口的前提是计算消耗远大于RPC的固有消耗


上述内容部分引用自 [深入浅出 RPC - 深入篇](http://blog.csdn.net/mindfloating/article/details/39474123)


### Dubbo

#### 惯例吹一波

- 基于java的高性能开源RPC框架，主要实现了RPC远程调用、集群容错和负载均衡、服务管理和监控三大块功能。

  ![](http://opo02jcsr.bkt.clouddn.com/deabda567257a04070d7183bef92e860.png)
